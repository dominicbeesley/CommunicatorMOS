; 6502bench SourceGen v1.8.1
CO_off_stack    .eq     0      {const}    ;coroutine stack
COP_00_OPWRC    .eq     0      {const}    ;OPWRC - write character in A to VDU
__EVESC         .eq     1      {const}    ;ESCape flag
COP_01_OPWRS    .eq     1      {const}    ;Print the zero-terminate text following the cop instruction
HDMMM           .eq     1      {const}    ;MM Global handle - ???
MM_HANDLE_1_SPECIAL_QRY .eq 1      {const}
__EVPRE         .eq     2      {const}    ;Event mask indicates a pre-empt
__MMFP          .eq     $02    {const}    ;Free a pool
CO_off_Parent   .eq     2      {const}    ;Pointer to parent coroutine
COP_02_OPWRA    .eq     2      {const}    ;OPWRA - write string at BHA
COP_03_OPNLI    .eq     3      {const}    ;OSNEWL
HNDFILE_off_module .eq  3      {const}    ;file handle block offset to module pointer
__MMBP          .eq     4      {const}    ;Undocumented mm call - TODO check for deprecated
CO_off_flags    .eq     4      {const}    ;Coroutine block offset - flags
COP_04_OPRDC    .eq     $04    {const}
CO_off_B        .eq     5      {const}    ;offset in couroutine of bank register
__MMASD         .eq     6      {const}    ;Allocate small descending
CO_off_DP       .eq     6      {const}    ;offset in couroutine block of DP pointer
COP_06_OPOSB    .eq     6      {const}    ;OSBYTE
COP_07_OPOSW    .eq     7      {const}    ;OSWORD
HDMMW           .eq     7      {const}    ;A memory pool well known handle - QRY - looks to be used with some unknown hardare at 450000
VDU_07_BELL     .eq     7      {const}
CO_off_8_BRKBLOCK .eq   8      {const}    ;Contains a pointer to block that contains a pointer to a break handler in bank 0
VDUMOD_OPX_8_EXPLODE .eq 8      {const}
__MMASA         .eq     $0a    {const}    ;Allocate small ascending
__STGIT         .eq     $0a    {const}
COP_0A_OPBGT    .eq     $0a    {const}    ;BGET
VDUMOD_OPX_A    .eq     $0a    {const}
COP_0B_OPBPT    .eq     $0b    {const}    ;BPUT
COP_0B_OPBPUT   .eq     $0b    {const}    ;BPUT
HND_off_B_type  .eq     $0b    {const}    ;Offset of the type byte in a handle block
__MMALA         .eq     $0c    {const}    ;Allocate large asending area
__STGLN         .eq     $0c    {const}
VDUMOD_OPX_C_HIMEM .eq  $0c    {const}
VDU_0D_CR       .eq     $0d    {const}
__MMBAS         .eq     $0e    {const}    ;Return Pool Base in BHA
__STGRD         .eq     $0e    {const}
COP_0E_OPCOM    .eq     $0e    {const}    ;Interpret command in BHA
VDUMOD_OPX_E_HIMEMBYX .eq $0e    {const}
COP_0F_OPERR    .eq     $0f    {const}
COP_10_OPADP    .eq     $10    {const}    ;Allocate direct page
HND_type_10_file .eq    $10    {const}    ;handle type for files
MMLEN           .eq     $10    {const}    ;COPMM reason code, Y contains handle, exit BHA contains length
VDUMOD_OPX_10_GETCURSOR .eq $10    {const}
__MMTOP         .eq     $12    {const}    ;Return the address of the top of the pool
COP_13_OPAST    .eq     $13    {const}    ;allocate stack
__STSBK         .eq     $14    {const}    ;Read Break Signature
VDUMOD_OPX_14_FLASH_QRY .eq $14    {const}
VDU_15_DELLN    .eq     $15    {const}
FSOP_16_BGET    .eq     $16    {const}    ;Call a filing system module to get a byte from a handle
VDUMOD_OPX_16_GETCHARXY .eq $16    {const}
__MMAZB         .eq     $18    {const}    ;Allocate Bank 0 area
COP_18_OPRLH    .eq     $18    {const}    ;Read hex number
FSOP_18_BPUT    .eq     $18    {const}
VDUMOD_OPX_24_READVDUVAR .eq 24     {const}
FSOP_1A_BGET_odd .eq    $1a    {const}    ;FS service call 1A - used for BGET on odd numbered handles
FSOP_1C_BPUT_odd .eq    $1c    {const}
FSOP_1E_CheckEOF .eq    $1e    {const}
COFLAG_hasBRKhandler .eq $20    {const}   ;When set there's a break handler
COP_20_OPSEV    .eq     $20    {const}    ;Set Event - QRY - set escape when called with A=0003
COP_21_OPPRE    .eq     $21    {const}    ;allow pre-emption
VDUMOD_OPX_22_READSTATUS .eq $22    {const}
COP_24_OPCVD    .eq     $24    {const}    ;Convert direct page index
COP_26_OPBHA    .eq     $26    {const}    ;Set BHA to start of string immediate
COP_28_OPCMD    .eq     $28    {const}
COP_29_OPRFR    .eq     $29    {const}    ;Find reference to module, entry BHA points name, X contains pointer in DP to 8 byte block
COP_2C_OPFMA    .eq     $2c    {const}    ;Find module by address
COP_2D_OPWRM    .eq     $2d    {const}    ;OPWRM - write module name
COP_2F_OPIIQ    .eq     $2f    {const}    ;intercept interrupt
COP_32_OPSUM    .eq     $32    {const}    ;Compute end-around-carry sum
COP_34_OPRMI    .eq     $34    {const}    ;Read module info
COP_36_OPNLU    .eq     $36    {const}    ;Name lookup
COFLAG_HASDP    .eq     $40    {const}    ;coroutine block flags bitmask for has valid DP
__VDU_42        .eq     $42    {const}    ;Vdu module command 42
__VDU_44        .eq     $44    {const}    ;Copy screen contents to BHA
COP_44_OPOPN    .eq     $44    {const}
COP_45_OPCLS    .eq     $45    {const}    ;Close file
__VDU_46        .eq     $46    {const}    ;Restore variables
COP_46_OPEND    .eq     $46    {const}    ;Check for EOF
__VDU_48        .eq     $48    {const}    ;restore the screen contents
__VDU_4A        .eq     $4a    {const}    ;VDU module call 4A
COP_4F_OPSAV    .eq     $4f    {const}    ;save a file from memory
COP_50_OPRLE    .eq     $50    {const}    ;Read Load/Execute/Length of file
COP_51_OPWLE    .eq     $51    {const}    ;Write Load/Exec address of file
COP_57_OPRLL    .eq     $57    {const}    ;read logical length (extent)
COP_5C_OPREN    .eq     $5c    {const}    ;rename file
COP_61_OPERC    .eq     $61    {const}
DPLOC_SYS       .eq     $ac00  {const}
STACKTOP_SYS_QRY .eq    $adff  {const}    ;Set at reset QRY
STACKTOP_RESET  .eq     $ffe0  {const}    ;Stack during reset
DPCOP_Y         .eq     1      {addr/2}   ;offset of Y in COP entry/exit frame
DPCOP_X         .eq     3      {addr/3}   ;offset of X in COP entry/exit frame
DPCOP_AH        .eq     5      {addr/2}   ;offset of AH in COP entry/exit frame
DPCOP_B         .eq     7      {addr/1}   ;offset of B(ank) in COP entry/exit frame
DPCOP_DP        .eq     8      {addr/2}   ;offset of DP in COP entry/exit frame
DPCOP_P         .eq     10     {addr/1}   ;offset of P in COP entry/exit frame
DPCOP_PC        .eq     11     {addr/2}   ;offset of PC in COP entry/exit frame
DPCOP_K         .eq     13     {addr/1}   ;offset of K (program bank) in COP entry/exit frame
__MMFND         .eq     $14               ;Find a memory pool by task pool handle
__STTBK         .eq     $16               ;Read BRK message text
COP_2E_OPFPO    .eq     $2e               ;find pool owner
__VDU_40        .eq     $40               ;VDU module call 40 - QRY get screen size in HA
COP_4E_OPLOD    .eq     $4e               ;load a file into memory
COP_5B_OPDEL    .eq     $5b               ;delete file
VDU_7F_BKSP     .eq     $7f               ;Backspace
DPSYS_D8_B_SAV  .eq     $d8    {addr/1}   ;OSWORD saves caller's bank register
BANK0_MEM_IRQ6502 .eq   $4040             ;QRY? Vector for IRQ in 6502 mode set at reset
SYSVARS         .eq     $a500  {addr/207} ;QRY SYSVARS
QOSBY_VECTOR    .eq     $a524  {addr/2}
SYSVARS_INSV    .eq     $a52a  {addr/2}
SYSVARS_REMV    .eq     $a52c  {addr/2}
SYSVARS_CNPV    .eq     $a52e  {addr/2}
SYSVAR_CFS_TIMEOUT .eq  $a540  {addr/1}
SYSVAR_41_input_stream .eq $a541          ;Currently selected input stream
SYSVAR_RS232_MODE .eq   $a545  {addr/1}
SYSVAR_48_UNKNOWN_ULA .eq $a548
SYSVAR_51_FLASHCTDN .eq $a551  {addr/1}
SYSVAR_FLASH_MARK .eq   $a553
SYSVAR_58_ESCBRK_EFFECT .eq $a558  {addr/1}
SYSVAR_ELK_SOFTKEY_STRLEN .eq $a55d  {addr/1}
SYSVAR_FLAGS_SOMETHINGOSBYTEY .eq $a55e  {addr/1}
SYSVAR_SOFTKEY_STRLEN .eq $a568  {addr/1}
SYSVAR_VDU_QLEN .eq     $a56a  {addr/1}
SYSVAR_SOUND_EXT_FLAG .eq $a56b  {addr/1}
SYSVARS_6C_ESCCHAR .eq  $a56c  {addr/1}
SYSVARS_75_ESCACTION .eq $a575  {addr/1}
SYSVARS_7C_OUTDEST .eq  $a57c  {addr/1}   ;output destination - FX3
SYSVARS_ULA_MISC_COPY .eq $a582  {addr/1}
SYSVAR_SOFTKEY_CONS .eq $a584
SYSVARS_8d_lastbreak .eq $a58d
SYSVAR_OSBYTE_255_STARTUP .eq $a58f
SYSVARS_B0_INKEYCTDN .eq $a5b0  {addr/2}
SYSVARS_OSWORD_0_PARMS .eq $a5b2  {addr/3}
SYSVARS_ELK_BUFFER_BUSY .eq $a5c3  {addr/8}
DPSYS_OSWORD0_BUFPTR .eq $a5e3  {addr/2}
SOUND_QRY_T     .eq     $a814
SOUND_QRY_S     .eq     $a81b
SOUND_STATUS_QRY .eq    $a820  {addr/1}
SOUND_TONE_QRY  .eq     $a821  {addr/1}
SOUND_QRY_X     .eq     $a822  {addr/1}
SOUND_CUR_CHAN_QRY .eq  $a825  {addr/1}
SYSFNK          .eq     $ab00  {addr/256} ;Soft Keys Area
DPSYS           .eq     $ac00  {addr/256} ;System's direct page area
DPSYS_PAGEMODE_CTR .eq  $ac69
DPSYS_DPECO     .eq     $ac9d  {addr/2}   ;Econet Direct Page Save QRY
DPSYS_MOD_ECO   .eq     $ac9f  {addr/6}   ;Econet module block
DPSYS_MOD_NET   .eq     $acaf  {addr/6}   ;Module block for high level network module QRY - find out name
DPSYS_MOD_VDU   .eq     $acbf  {addr/8}   ;vdu module reference
DPSYS_D1_EXEC_handle .eq $acd1  {addr/2}
DPVAR_ACD4_HANDSET_STATUS_QRY .eq $acd4  {addr/1}
DPSYS_D6_OSW_DPSAV .eq  $acd6  {addr/2}   ;OSWORD caller's saved DP
DPSYS_GSREAD_flags .eq  $acdd  {addr/1}   ;bit 7 is quotes detected, bit 6 is terminate on space
DPSYS_OSB_X     .eq     $acea  {addr/1}   ;OSBYTE saved X
DPSYS_OSB_Y     .eq     $aceb  {addr/1}   ;OSBYTE saved Y
DPSYS_OSB_A     .eq     $acec  {addr/1}   ;OSBYTE save in SYS DP
DPSYS_GSREAD_ptr .eq    $aced  {addr/3}   ;GSREAD pointer in __ST
DPSYS_OSB_IND   .eq     $acf6  {addr/2}
DP_HANDLE_VIDEO_QRY .eq $fe0c  {addr/2}   ;QRY see fe/d355
B0LST_MODULES_QRY .eq   $fe0e  {addr/2}
tblB0JumpTableFE80_QRY .eq $fe80  {addr/52} ;QRY set up from ROM during reset at FEb4e8
tblB0JumpTableFEE0_QRY .eq $fee0  {addr/32}
EXSYS           .eq     $ff00  {addr/256} ;Extended system variables
MM_HANDLE_TAB   .eq     $ff00  {addr/80}  ;Looks to contain a set of memory handles
EXSYS_HANDLEBLOCK_LONGPTR .eq $ff02  {addr/3}
EXSYS_CO_A_SAVE .eq     $ff05  {addr/2}   ;used in CCO
EXSYS_0D_BRKADDR_SAVE .eq $ff0d  {addr/3}
EXSYS_CUR_COROUTINE .eq $ff10  {addr/2}   ;Stores the current coroutine's pointer
SYS_ESCAPE_FLAG_QRY .eq $ff13
tblB0JumpTableFF80_QRY .eq $ff80  {addr/80} ;jump table that branches to jmls to default cop handlers QRY?
LOWCALL__MM     .eq     $ff8c
LOWCALL__KB     .eq     $ffac             ;direct call to Keyboard routines QRY?
BANK0_HW_VECTORS .eq    $ffe0  {addr/32}
BANK0_HW_NMI816 .eq     $ffea  {addr/2}   ;Native mode IRQ HW vector
BANK0_HW_IRQ6502 .eq    $fffe  {addr/2}   ;hardware vector 6502 IRQ
BANK0_HW_NMI816_SHAD1M .eq $10ffea {addr/2}
BANK0_HW_IRQ6502_SHAD1M .eq $10fffe {addr/2} ;IRQ for 6502 mode in 1M shadow bank QRY? see reset
HW_ECONET       .eq     $410000
VIA_ORB         .eq     $420000 {addr/1}
VIA_ORA         .eq     $420001 {addr/1}
VIA_DDRB        .eq     $420002 {addr/1}
VIA_DDRA        .eq     $420003 {addr/1}
VIA_T1C_L       .eq     $420004 {addr/1}
VIA_T1C_H       .eq     $420005 {addr/1}
VIA_T1L_L       .eq     $420006 {addr/1}
VIA_T1L_H       .eq     $420007 {addr/1}
VIA_ACR         .eq     $42000b {addr/1}
VIA_PCR         .eq     $42000c {addr/1}
VIA_IER         .eq     $42000e {addr/1}
HW_VIDEO_BASE   .eq     $450000 {addr/10000} ;Video ULA / Screen memory
sheila_ULA_IRQ_CTL .eq  $45fe00
sheila_ULA_CASSH .eq    $45fe04 {addr/1}
sheila_ULA_PAG_IRQCLR .eq $45fe05 {addr/1}
sheila_UKA_TONE .eq     $45fe06
shiela_ULA_MISC .eq     $45fe07 {addr/1}  ;ULA misc control
sheila_ULA_PAL  .eq     $45fe08 {addr/8}
HW_EXTIO        .eq     $800000 {addr/10000} ;External IO space
HW_TYPE_DETECT_QRY .eq  $f0fff8           ;QRY Seems to detect different motherboard types
SYSVAR_IRQCTL_COPY .eq  $fea55b {addr/1}

                .addrs  $feae00
                .rwid   shortm,shortx
LFEAE00         brl     ServiceEnter      ;Branch to Service Routine

                .dd3    $005065           ;Module length-2
                .dd2    $0100             ;version BCD
                .dd4    $00000002         ;FLAGS
                .dd2    $0000             ;RESV
                .zstr   “MOS/HELP/LOAD/SAVE/KEY/FX/EXEC/RESET/LCB/CLOSEALL/DELETE/RENAM” ;Command Table
                 +      “E/CAT/EX”
                .zstr   “//file [load_addr]/file [from_addr] [to_addr||+len] [exec_addr” ;Command help table
                 +      “] [load_addr]/key_num [string]/fx_num [x] [y]/[file]//num//fil”
                 +      “e/file1 file2/[fs:][dir]/[fs:][dir]”

; Service Call Handler
; 
; Dispatches to routine index in X
; 
; DP is hard coded to AC00
                .rwid   longm,longx
ServiceEnter    php
                rep     #$30
                cpx     #$000a
                bcs     @ServiceExitFail
                pea     DPSYS
                pld                       ;Set DP register tp AC00
                sep     #$30
                .rwid   shortm,shortx
                jsr     (tblServices,x)
                bcs     @ServiceExitFail
                plp
                .rwid   longm,longx
                clc
                rtl

                .rwid   shortm,shortx
@ServiceExitFail plp
                .rwid   longm,longx
                sec
                rtl

tblServices     .dd2    Serv0_starCommand & $ffff
                .dd2    Serv2_RESET & $ffff
                .dd2    Serv4_QRY & $ffff
                .dd2    Serv6_QRY & $ffff
                .dd2    Serv8_QRY & $ffff

                .rwid   shortm,shortx
Serv0_starCommand tyx
                ldy     #$00
                clc
                sep     #$30
                jsr     (tblStarCommandDispatch,x)
                rts

tblStarCommandDispatch .dd2 starMOS & $ffff
                .dd2    starMOS & $ffff
                .dd2    starLOAD & $ffff
                .dd2    starSAVE & $ffff
                .dd2    starKEY & $ffff
                .dd2    starFX & $ffff
                .dd2    starEXEC & $ffff
                .dd2    starRESET & $ffff
                .dd2    starLCB & $ffff
                .dd2    starCLOSEALL & $ffff
                .dd2    starDELETE & $ffff
                .dd2    starRENAME & $ffff
                .dd2    starCAT & $ffff
                .dd2    starEX & $ffff

starCLOSEALL    php
                rep     #$30
                .rwid   longm,longx
                phk
                jsr     LFEF7BA           ;long call
                plp
                .rwid   shortm,shortx
                rts

starMOS         cop     COP_01_OPWRS
                .zstr   “Communicator Operating System”,$0a,$0d,“Version 1.00 13/Nov/86”
                 +      “ (C)1986”,$0a,$0d
                rts

Serv4_QRY       pea     $0000
                plb
                .dbank  $00
                plb                       ;Data Bank to 0
                pha
                tay
                jsr     LFEE22E
                plx
                lda     #$00
                cpx     SYSVARS_6C_ESCCHAR
                bne     LFEAFA2
                ldx     SYSVARS_75_ESCACTION
                bne     LFEAFA2
                inc     A
LFEAFA2         rts

Serv6_QRY       pea     $0000
                plb
                plb
                eor     #$00
                beq     LFEAFBC
                sei
                lda     $d5
                cmp     #$81
                bcc     LFEAFBA
                cli
LFEAFB4         lda     $d5
                cmp     #$80
                bcs     LFEAFB4
LFEAFBA         lda     #$ff
LFEAFBC         sta     $d3
                rts

tblInitSysVars  .dd2    defaultUSERV & $ffff ;USERV
                .dd2    default_IVBRK & $ffff ;BRKV
                .dd2    $0000             ;IRQ1V
                .dd2    $0000             ;IRQ2V
                .dd2    defaultCLIV & $ffff ;CLIV
                .dd2    doDispatchOSBYTE & $ffff
                .dd2    enterOSWORD_BHA & $ffff
                .dd2    TFEDEFF & $ffff
                .dd2    int_OPRDC & $ffff
                .dd2    donothingRTS & $ffff
                .dd2    donothingRTS & $ffff
                .dd2    donothingRTS & $ffff
                .dd2    donothingRTS & $ffff
                .dd2    donothingRTS & $ffff
                .dd2    donothingRTS & $ffff
                .dd2    donothingRTS & $ffff
                .dd2    donothingRTS & $ffff
                .dd2    donothingRTS & $ffff
                .dd2    donothingRTS & $ffff
                .dd2    donothingRTS & $ffff
                .dd2    $0000             ;KEYV - QRY assume this gets set up by KEYBOARD module?
                .dd2    defaultINSV & $ffff ;ISNV
                .dd2    defaultREMV & $ffff ;REMV
                .dd2    defaultCNPV & $ffff ;CNPV
                .dd2    donothingRTS & $ffff ;IND1V
                .dd2    donothingRTS & $ffff ;IND2V
                .dd2    donothingRTS & $ffff ;IND3V
                .dd2    SYSVARS-112       ;&236 - address of OS vars (A6)
                .dd2    $0d9f             ;&238 - address of vector table QRY
                .dd2    $a5a0             ;&23A - address of ROM info table QRY
                .dd2    $0000             ;&23C - address of key translation table QRY
                .dd2    $0000             ;&23E - address of VDU variables QRY
                .dd1    $00
                .dd1    $00
                .dd1    $ff
                .dd1    $00
                .dd1    $00
                .dd1    $00
                .dd1    $00
                .dd1    $00
                .dd1    $00
                .dd1    $00
                .dd1    $00
                .dd1    $ff
                .dd1    $04
                .dd1    $04
                .dd1    $00
                .dd1    $ff
                .dd1    $00
                .dd1    $19
                .dd1    $19
                .dd1    $19
                .dd1    $32
                .dd1    $08
                .dd1    $00
                .dd1    $00
                .dd1    $00
                .dd1    $00
                .dd1    $00
                .dd1    $ff
                .dd1    $00
                .dd1    $00
                .dd1    $00
                .dd1    $00
                .dd1    $00
                .dd1    $50
                .dd1    $00
                .dd1    $03
                .dd1    $90
                .dd1    $64
                .dd1    $06
                .dd1    $81
                .dd1    $00
                .dd1    $00
                .dd1    $00
                .dd1    $00
                .dd1    $1b
                .dd1    $01
                .dd1    $d0
                .dd1    $e0
                .dd1    $f0
                .dd1    $01
                .dd1    $80
                .dd1    $90
                .dd1    $00
                .dd1    $00
                .dd1    $00
                .dd1    $ff
                .dd1    $ff
                .dd1    $ff
                .dd1    $00
                .dd1    $00
                .dd1    $00
                .dd1    $00
                .dd1    $00
                .dd1    $00
                .dd1    $00
                .dd1    $00
                .dd1    $00
                .dd1    $05
                .dd1    $ff
                .dd1    $00
                .dd1    $0a
                .dd1    $00
                .dd1    $00
                .dd1    $00
                .dd1    $00
                .dd1    $00
                .dd1    $ff
                .dd1    $ea
                .dd1    $4f
                .dd1    $b0

Serv2_RESET     sei
                clc
                xce                       ;Enter native mode
                ldal    $400000           ;Disable boot rom mapping QRY
                sei
                clc
                xce                       ;re-enter naitve mode WHY?
                rep     #$38              ;16 bits and clear decimal flag
                .rwid   longm,longx
                sep     #$20
                .rwid   shortm
                lda     #$10              ;Clear Screen interrupt if
                stal    shiela_ULA_MISC
                rep     #$20
                .rwid   longm
                lda     #$0ff0            ;palette to white on blue QRY?
                stal    sheila_ULA_PAL
                stal    sheila_ULA_PAL+2
                stal    sheila_ULA_PAL+4
                stal    sheila_ULA_PAL+6
                lda     #BANK0_MEM_IRQ6502
                stal    f:BANK0_HW_IRQ6502
                stal    BANK0_HW_IRQ6502_SHAD1M
                lda     #BANK0_HW_IRQ6502
                stal    f:BANK0_HW_NMI816
                stal    BANK0_HW_NMI816_SHAD1M
                lda     #STACKTOP_RESET   ;we need a temporary stack for the next instructions
                tcs
                phk
                .dbank  K (auto)
                plb
                bpl     @runninglow       ;if running from bank 0/low memory skip ahead, else vector through FFFFF0
; QRY - not sure what happens here, does the jml somehow do memory mapping or
; does the 440000 load?
                jml     $fffff0           ;Not sure what this will do looks to jump into padding at end of Calculator if rom1 is at top of address space!?! QRY

@runninglow     ldal    $440000           ;we're not sure why it does a read here QRY QRYMAME
                lda     #STACKTOP_SYS_QRY
                tcs                       ;set system stack
                lda     #DPLOC_SYS
                tcd                       ;set system DP
                lda     #$fe0e            ;; QRY no idea what these are yet
                stal    f:B0LST_MODULES_QRY
                lda     #$fdfe
                stal    f:$00fdfe
                lda     #$0000
                stal    f:$00fe12
                jsr     initialize_default_vectors_QRY
                sep     #$30
                .rwid   shortm,shortx
                jsr     LFECF59
                jsr     LFECDB5
                jsr     LFED2B8
                jsr     LFEB2FC
                jsr     LFEB3A7
                jsr     LFEFD7C
                phk
                jsr     LFEEE48
                rep     #$30
                .rwid   longm,longx
                jsr     LFEFE0A
                sep     #$30
                .rwid   shortm,shortx
                pea     $0000
                plb
                plb
                jsr     LFEB3EB
                jsr     LFEB400
                jsr     resIrqLastBreak
                jsr     LFEB4B8
                lda     #$80
                sta     $a58e
                stx     $a584
                phd
                pea     $ff00
                pld
                lda     #$70
                sta     DPCOP_K
                lda     #$e8
                sta     $0e
                phk
                pla
                sta     $0f
                pld
                pea     $0000
                plb
                .dbank  $00
                plb
                lda     #$f8
                sta     SYSVAR_OSBYTE_255_STARTUP
                ldx     #$90
                ldy     #$8d
                lda     #$01
                sta     SYSVARS_8d_lastbreak
                clv
                clc
                php
                jsr     initSYSVARS
                jsr     LFEB407
                ldx     #$02
                phk
                jsr     callModVDU
                lda     SYSVAR_OSBYTE_255_STARTUP
                ldx     #$36
                phk
                jsr     callModVDU
                ora     #$c4
                sta     SYSVARS_ULA_MISC_COPY
                stal    shiela_ULA_MISC
                stal    sheila_ULA_CASSH
                lda     #$0c              ;enable display end and RTC interrupts
                sta     SYSVAR_IRQCTL_COPY & $ffff
                stal    sheila_ULA_IRQ_CTL
                lda     #$88              ;rom page enable, NMI clear 6502 trumps NMI QRY
                stal    sheila_ULA_PAG_IRQCLR
                jsr     OSBYTE_74
                jsr     LFEB46F
                jsr     LFEB440
                jsr     OSBYTE_12
                cop     COP_26_OPBHA      ;Set BHA to start of following string and skip
                .zstr   “KEYBOARD”
                ldx     #$c7              ;offset in DP
                ldy     #$00              ;must be 0?
                cop     COP_29_OPRFR      ;Get reference to KEYBOARD module in dp at offset C7
                bcc     @keyboard_found
                cop     COP_0F_OPERR      ;throw an error
                .zstr   “Cannot find KEYBOARD module”
@keyboard_found ldx     #$02
                jsl     LOWCALL__KB
                lda     #$31
                ldx     #$18
                jsl     __KB
                phk
                .dbank  K (auto)
                plb
                lda     #$16              ;22 - VDU set mode
                cop     COP_00_OPWRC
                ldal    f:SYSVAR_OSBYTE_255_STARTUP
                cop     COP_00_OPWRC
                jsr     LFEEE46
                phb
                cop     COP_01_OPWRS      ;write immed
                .zstr   $0a,“Acorn Communicator ”
                ldy     #MM_HANDLE_1_SPECIAL_QRY
                ldx     #MMLEN
                jsl     LOWCALL__MM
                phb
                pla
                xba
                rep     #$30
                .rwid   longm,longx
                lsr     A
                lsr     A
                clc
                adc     #$0028
                pha
                pea     $4600
                plb
                plb
                lda     $2000
                eor     #$0080
                ldx     a:$0000
                sta     a:$0000
                eor     $2000
                stx     a:$0000
                beq     LFEB1F1
                lda     #$0018
LFEB1F1         adc     $01,S
                plx
                jsr     LFEB382
                sep     #$30
                .rwid   shortm,shortx
                cop     COP_01_OPWRS
                .zstr   “K”,$0d,$0a,$0a
                plb
                bra     LFEB203

LFEB203         phk
                .dbank  K (auto)
                plb
                ldx     #$00
                bra     @lpstart

@lp             txa
                adc     #$03
                tax
@lpstart        lda     LFEB2EA & $ffff,x
                beq     LFEB217
                jsr     LFEB2F3
                bcc     @lp
LFEB217         phx
                ldx     #$18
                jsl     __KB
                plx
                lda     LFEB2EB & $ffff,x
                beq     LFEB231
                phx
                ldx     #$02
                cop     COP_28_OPCMD
                .zstr   “ECONET”
                plx
LFEB231         lda     LFEB2EC & $ffff,x
                bne     LFEB25A
                cop     COP_26_OPBHA
                .zstr   “MENU”
                ldy     #$00
                rep     #$30
                .rwid   longm,longx
                phk
                jsr     brlFindModule
                sep     #$30
                .rwid   shortm,shortx
                bcs     @nomenu
                rep     #$30
                .rwid   longm,longx
                phk
                jsr     LFEEE51
                sep     #$30
                .rwid   shortm,shortx
                pea     $0000
                plb
                plb
                bcc     LFEB2B3
@nomenu         lda     #$01
LFEB25A         cmp     #$01
                beq     LFEB2A4
                lda     #$d3
                jsr     LFEB2F3
                bcc     LFEB2A4
                cop     COP_26_OPBHA
                .zstr   “RAMinitialise”,$0d
                cop     COP_0E_OPCOM
                cop     COP_01_OPWRS
                .zstr   “CMOS MEMORY INITIALISED - NOW REBOOT”,$0d,$0a,$0a
LFEB2A2         bra     LFEB2A2

LFEB2A4         cop     COP_26_OPBHA
                .zstr   “BASIC”
                ldx     #$00
                txy
                cop     COP_34_OPRMI
LFEB2B1         bcs     LFEB2B1
LFEB2B3         phb
                xba
                pha
                xba
                pha
                pea     $0200
                pld
                ldx     #$02
                jsl     __CO
                bcc     LFEB2DE
                brk     $00

                .zstr   “Cannot start BASIC/MENU”

LFEB2DE         pla
                xba
                pla
                xba
                plb
                ldx     #$02
                jsr     LFEDC35
LFEB2E8         bra     LFEB2E8

LFEB2EA         .dd1    $b1
LFEB2EB         .dd1    $ff
LFEB2EC         .dd1    $01
                .dd1    $e8
                .dd1    $ff
                .dd1    $02
                .dd1    $00
                .dd1    $ff
                .dd1    $00

LFEB2F3         phx
                ldx     #$10
                jsl     __KB
                plx
                rts

LFEB2FC         php
                phd
                phb
                rep     #$30
                .rwid   longm,longx
                lda     #$0100
                ldx     #$0018
                jsl     __MM
                bcc     LFEB32C
LFEB30D         cop     COP_0F_OPERR
                .zstr   “MOS couldn't allocate memory”
LFEB32C         pea     $ff00
                pld
                pha
                phb
                phb
                lda     #$00e0
                sta     $00
                phd
                ldx     #$0010
                jsl     __MM
                pld
                plx
                stx     DPCOP_X
                plx
                stx     DPCOP_Y+1
                sta     [DPCOP_Y+1]
                tay
                lda     #$0000
                dey
                dey
LFEB34F         sta     [DPCOP_Y+1],y
                dey
                dey
                bne     LFEB34F
                ldal    f:$00fe04
                ldy     #$0002
                sta     [DPCOP_Y+1],y
                ldx     #$0010
                ldy     #$0005
                jsl     __MM
                tcd
                ldx     #$000e
                ldy     #$0005
                jsl     __MM
                bcs     LFEB30D
                ldx     #$0004
                jsl     __MM
                bcs     LFEB30D
                plb
                pld
                plp
                rts

LFEB382         ldx     #$0064
                jsr     LFEB391
                ldx     #$000a
                jsr     LFEB391
                ldx     #$0001
LFEB391         phx
                ldx     #$ffff
LFEB395         inx
                sec
                sbc     $01,S
                bcs     LFEB395
                adc     $01,S
                pha
                txa
                ora     #$0030
                cop     COP_00_OPWRC
                pla
                plx
                rts

                .rwid   shortm,shortx
LFEB3A7         php
                phb
                phk
                .dbank  K (auto)
                plb
                phd
                tdc
                rep     #$30
                .rwid   longm,longx
                pld
                plb
                plp
                .rwid   shortm,shortx
                rts

                .rwid   longm,longx
LFEB3B3         phx
                pld                       ;set DP to X
                pha
                lda     #$0004
                jsr     LFECE01
                bcs     LFEB3E9
                lda     templateModCallBack2 & $ffff
                stal    f:$000000,x
                lda     0+(templateModCallBack2 & $ffff)+5
                stal    f:$000005,x
                lda     DPCOP_Y
                stal    f:$000002,x
                lda     DPCOP_Y+1
                stal    f:$000003,x
                stz     DPCOP_Y+1
                stx     DPCOP_Y
                pla
                stal    f:$000008,x
                rts

                .rwid   shortm,shortx
templateModCallBack2 phd
                jsl     $000000
                pld
                rtl

                .rwid   longm,longx
LFEB3E9         bra     LFEB3E9

                .rwid   shortm,shortx
LFEB3EB         lda     #$53
                stal    $400006
                stal    $400006
                lda     #$00
                stal    $400004
                stal    $400002
                rts

LFEB400         lda     #$03
                stal    $430000
                rts

LFEB407         lda     #$00
                ldx     #$cf
LFEB40B         sta     $00,x
                inx
                bne     LFEB40B
                rts

initSYSVARS     phb
                phk
                .dbank  K (auto)
                plb
                lda     #$00
@blanklp        cpx     #$c3
                bcc     @sk1
                lda     #$ff
@sk1            stal    f:SYSVARS,x
                inx
                bne     @blanklp
                tyx
@cpylp          lda     0+(tblInitSysVars & $ffff)-1,x
                stal    f:SYSVARS-1,x
                dex
                bne     @cpylp
                plb
                rts

resIrqLastBreak lda     #$00
                stal    sheila_ULA_IRQ_CTL
                sta     SYSVARS_8d_lastbreak
                lda     #$f8
                stal    sheila_ULA_PAG_IRQCLR
                rts

LFEB440         ldal    HW_TYPE_DETECT_QRY
                beq     LFEB46E
                ldal    VIA_ORB
                and     #$df
                stal    VIA_ORB
                ldal    $459fff
                and     #$0f
                sta     $cf
                ldal    $45bfff
                asl     A
                asl     A
                asl     A
                asl     A
                ora     $cf
                sta     $cf
                ldal    VIA_ORB
                ora     #$20
                stal    VIA_ORB
LFEB46E         rts

LFEB46F         lda     #$90
                stal    VIA_IER
                lda     #$00
                stal    VIA_ORA
                lda     #$ff
                stal    VIA_DDRA
                lda     #$6e
                stal    VIA_ORB
                ldal    HW_TYPE_DETECT_QRY
                bne     LFEB491
                lda     #$66
                bra     LFEB493

LFEB491         lda     #$f6
LFEB493         stal    VIA_DDRB
                lda     #$29
                stal    VIA_PCR
                lda     #$a1
                stal    VIA_T1C_L
                stal    VIA_T1L_L
                lda     #$01
                stal    VIA_T1C_H
                stal    VIA_T1L_H
                lda     #$40
                stal    VIA_ACR
                rts

LFEB4B8         phd
                phb
                cop     COP_26_OPBHA
                .zstr   “RAMstart”,$0d
                cop     COP_0E_OPCOM
                plb
                pld
                rts

; moves program bytes from this rom to bank 0
; 
; number of bytes must be even and contained in HA
                .rwid   longm,longx
movPrg2B0       phk
                .dbank  K (auto)
                plb
@lp             dec     A
                dec     A
                bmi     @ex
                pha
                lda     $0000,y
                stal    f:$000000,x
                pla
                inx
                inx
                iny
                iny
                bra     @lp

@ex             rts

initialize_default_vectors_QRY php
                sei
                rep     #$30
                ldy     #tblDefaultRoutines & $ffff
                ldx     #tblB0JumpTableFE80_QRY
                lda     #$0034
                jsr     movPrg2B0
                sep     #$20
; Resets all the jml bank addresses to point to current ROM
                .rwid   shortm
                phk
                pla
                ldx     #$0033
@lp0            stal    f:LFE80,x
                dex
                dex
                dex
                dex
                bpl     @lp0
                rep     #$20
                .rwid   longm
                ldy     #tblDefaultRoutines2Pre & $ffff
                ldx     #tblB0JumpTableFF80_QRY
                lda     #$0034
                jsr     movPrg2B0
                ldy     #tblDefaultHwJml & $ffff
                ldx     #tblB0JumpTableFEE0_QRY
                lda     #$0020
                jsr     movPrg2B0
                sep     #$20
; Resets all the jml bank addresses to point to current ROM
                .rwid   shortm
                phk
                pla                       ;this ROM's bank 
                ldx     #$001f
LFEB523         stal    f:LFEE0,x
                dex
                dex
                dex
                dex
                bpl     LFEB523
                rep     #$20
                .rwid   longm
                ldy     #tblHWVectors & $ffff
                ldx     #BANK0_HW_VECTORS
                lda     #$0020
                jsr     movPrg2B0
                plp
                rts

********************************************************************************
* ; Note: the following table is copied to bank 0 at fe80 and then all the     *
* bank addresses are tweaked to point back at this ROM                         *
*                                                                              *
* TODO: tidy the arithmetic below to & 0x00FFFF                                *
********************************************************************************
tblDefaultRoutines
                .addrs  $fe80
                .rwid   shortm,shortx
LFE80           jml     default__TB-$fe0000

LFE84           jml     default__LN-$fe0000

LFE88           jml     default__ST-$fe0000

LFE8C           jml     default__MM-$fe0000

LFE90           jml     default__CO-$fe0000

LFE94           jml     default__CCO-$fe0000

LFE98           jml     default__CWT-$fe0000

LFE9C           jml     default__CRS-$fe0000

LFEA0           jml     default__OSB-$fe0000

LFEA4           jml     default__OSW-$fe0000

LFEA8           jml     default__VDU-$fe0000

LFEAC           jml     default__KB-$fe0000

LFEB0           jml     default__EV-$fe0000
                .adrend ↑ $fe80

********************************************************************************
* BRL's to the jump table above for "well known" entry points                  *
*                                                                              *
* QRY not clear why this double indirection is needed?                         *
********************************************************************************
tblDefaultRoutines2Pre
                .addrs  *-$fdb5f1
__TB            brl     LFE80

                nop
__LN            brl     LFE84

                nop
__ST            brl     LFE88

                nop
__MM            brl     LFE8C

                nop
__CO            brl     LFE90

                nop
__CCO           brl     LFE94

                nop
__CWT           brl     LFE98

                nop
__CRS           brl     LFE9C

                nop
__OSB           brl     LFEA0

                nop
OSW             brl     LFEA4

                nop
__VDU           brl     LFEA8

                nop
__KB            brl     LFEAC

                nop
__EV            brl     LFEB0

                nop
                .adrend ↑ $ff80

; ZXXXXXXX
tblDefaultHwJml
                .addrs  $fee0
LFEE0           jml     tblDefaultHwJml-$fe0000

                jml     tblDefaultHwJml-$fdfffc ;TODO - fix this up to reference self &FFFF

hwjmpvecCOP     jml     default_IVCOP-$fe0000 ;COP

hwjmpvecBRK     jml     default_IVBRK-$fe0000 ;BRK

hwjmpvecABORT   jml     Serv2_RESET-$fe0000 ;ABORT - causes a RESET

hwjmpvecNMI     jml     default_IVNMI-$fe0000 ;NMI

hwjmpvecRESET   jml     Serv2_RESET-$fe0000 ;RESET

hwjmpvecIRQ     jml     default_IVIRQ-$fe0000 ;IRQ
                .adrend ↑ $fee0

default_IVNMI   rti

tblHWVectors    .dd2    $0000
                .dd2    $0000
                .dd2    hwjmpvecCOP
                .dd2    hwjmpvecBRK
                .dd2    hwjmpvecABORT
                .dd2    hwjmpvecNMI
                .dd2    hwjmpvecRESET
                .dd2    hwjmpvecIRQ
                .dd2    $0000
                .dd2    $0000
                .dd2    $0000
                .dd2    $0000
                .dd2    hwjmpvecABORT
                .dd2    hwjmpvecNMI
                .dd2    hwjmpvecRESET
                .dd2    $ff00
default__TB     cop     COP_0F_OPERR
                .zstr   “FC interface not supported”
default__VDU    rtl

********************************************************************************
* LN - ????                                                                    *
*                                                                              *
* QRY this is a "well known" entry point at 00/FF84                            *
*                                                                              *
* op 0 calls __ST/0 (get string pointer to "SYSTEM")                           *
* op 2 calls the CLI vector                                                    *
********************************************************************************
default__LN     php
                rep     #$30
                .rwid   longm,longx
                cpx     #$0004
                bcs     @retsec
                phd
                phb
                pea     DPSYS
                pld
                sep     #$30
                .rwid   shortm,shortx
                jsr     (tblLnFunctions,x)
                plb
                pld
                bcs     @retsec
                plp
                clc
                rtl

@retsec         plp
                sec
                rtl

tblLnFunctions  .dd2    __ST_0 & $ffff    ;0 - do __ST_0
                .dd2    defaultCLIV & $ffff ;2 - __LNCLI

********************************************************************************
* __ST operation 0                                                             *
*                                                                              *
* return long pointer BHA to string "SYSTEM"                                   *
********************************************************************************
__ST_0          rep     #$30
                .rwid   longm,longx
                phk
                .dbank  K (auto)
                plb
                lda     #strSYSTEM & $ffff
                rts

strSYSTEM       .zstr   “SYSTEM”

********************************************************************************
* Main BRK handler - saves the registers on the stack and passes control to    *
* the coroutine BRK handler                                                    *
********************************************************************************
                .rwid   shortm,shortx
default_IVBRK   cld
                rep     #$30
                .rwid   longm,longx
                phd
                phb
                pha
                phx
                phy
; stack/DP contains
; +D  K
; +B  PC
; +A  FLAGS
; +8  DP
; +7  B
; +5  HA
; +3  X
; +1  Y
                tsc
                tcd
                lda     $0c
                stal    f:EXSYS_0D_BRKADDR_SAVE+1 ;store 24 bit pointer to byte after the BRK instruction
                lda     $0b
                dec     A
                stal    f:EXSYS_0D_BRKADDR_SAVE
                ldx     #$003c            ;TODO: what VDU function?
                phk
                jsr     callModVDU
                jmp     coHandleBRK

********************************************************************************
* The COP handler                                                              *
********************************************************************************
                .rwid   shortm,shortx
default_IVCOP   plp
                php                       ;Not sure what this sequence is for, reestablish caller's SEI or SED flags - seems dodgy
                rep     #$38
                .rwid   longm,longx
                phd                       ;8
                phb                       ;7
                pha                       ;5
                phx                       ;3
                phy                       ;1
                tsc
; at this point D and S point to the stack
; 
; +13   PBR
; +11   PC
; +10   P
; +8    DP
; +7    B
; +5    A
; +3    X
; +1    Y
                tcd
                dec     DPCOP_PC          ;decrement 16 bit return pointer to point at the signature byte
                lda     [DPCOP_PC]        ;get signature byte
                asl     A                 ;multiply by 2 to get index
                and     #$00ff            ;mask off whatever we fetched in high byte
                cmp     #$00c4            ;compare to C4 - 2*$62
                bcs     @handlege62       ;jump forward for high COPs
@dispatch       tax                       ;transfer index to X
                lda     DPCOP_AH          ;restore A from stack
                phk
; The callee stack will now look like this:
; 
; +16   PBR
; +14   PC
; +13   P
; +11   DP
; +10   B
; +8    A
; +6    X
; +4    Y
; +1    FE/B673 - return address of COP dispatcher
; 
; The DP register will point at byte below Y
; 
; +13   PBR
; +11   PC
; +10   P
; +8    DP
; +7    B
; +5    A
; +3    X
; +1    Y
                jsr     (tblCOPDispatch,x) ;long jump to handler in dispatch table
@ret            rep     #$30
                ply                       ;restore all regs except plp
                plx
                pla
                plb
                pld
                bcs     @retSEC           ;check for CS and jump forward for return with CS
                plp
                .rwid   shortm,shortx
                clc
                rtl

                .rwid   longm,longx
@retSEC         plp
                .rwid   shortm,shortx
                sec
                rtl

                .rwid   longm,longx
@ret_unimplemented stz  DPCOP_X           ;clear saved X
                sec                       ;return error
                bra     @ret

@handlege62     cmp     #$00e0
                bcc     @ret_unimplemented ;less than E0 - i.e COP 31..6F
                lda     [DPCOP_PC]        ;get cop number as 16 bits (will be nn7x)
                inc     DPCOP_PC          ;step return address past it
                xba                       ;swap byte order will now be somethig like 7xnn
                asl     A                 ;now Exnn or Fxnn
                cmp     #$e000
                bcs     @ret_unimplemented ;QRY - this looks like a bug? they must all surely be >= e000?!?!
                sbc     #$df3b            ;subtract df3e to put in range 
                bra     @dispatch

tblCOPDispatch  .dd2    COP_00 & $ffff    ;OPWRC 00 = OSWRCH
                .dd2    COP_01 & $ffff    ;OPWRS 01 = Write String Immediate
                .dd2    COP_02 & $ffff    ;OPWRA 02 = Write string at BHA
                .dd2    COP_03 & $ffff    ;OPNLI 03 = OSNEWL - write CR/LF
                .dd2    COP_04 & $ffff    ;OPRDC 04 = read character
                .dd2    COP_05 & $ffff    ;OPCLI 05 = OSCLI = execute command
                .dd2    COP_06 & $ffff    ;OPOSB 06 - OSBYTE
                .dd2    COP_07 & $ffff    ;OPOSW 07 - OSWORD
                .dd2    copBadCOP & $ffff
                .dd2    copBadCOP & $ffff
                .dd2    COP_0A & $ffff    ;OPBGT 0A - BGET
                .dd2    COP_0B & $ffff    ;OPBPT 0B - BPUT
                .dd2    copBadCOP & $ffff
                .dd2    COP_0D & $ffff    ;???? 0D - Throws a not implemented error
                .dd2    COP_OE & $ffff    ;OPCOM 0E - OSCLI with string in BHA
                .dd2    COP_0F & $ffff    ;OPERR 0E - Raise an error
                .dd2    COP_10 & $ffff    ;OPADP 10 - Allocate direct page
                .dd2    COP_10 & $ffff    ;OPADF 11 - Allocate direct page - supposed to be fast but isnt...or is it?
                .dd2    COP_12 & $ffff    ;OPFD  12 - QRY not in docco
                .dd2    COP_13 & $ffff    ;OPAST 13 - Allocate Stack
                .dd2    COP_14 & $ffff    ;OPFST 14 - Free Stack
                .dd2    COP_15 & $ffff    ;OPASC 15 - Write ASCII convert <CR> to <CR><LF>
                .dd2    COP_16 & $ffff    ;OPAEV 16 - Acknowledge Event
                .dd2    COP_17 & $ffff    ;OPBYX 17 - Convert BYXD to BHA
                .dd2    COP_18 & $ffff    ;OPRLH 18 - Read hex number
                .dd2    COP_19 & $ffff    ;OPRLS 19 - read literal string QRY not documented
                .dd2    COP_1A & $ffff    ;OPFZB 1A - free bank 0 memory
                .dd2    COP_1B & $ffff    ;OPARM 1B - call Arithmetic module
                .dd2    COP_1C & $ffff    ;OPSCX 1C - Save Context 
                .dd2    COP_1D & $ffff    ;OPRCX 1D - Restore Context
                .dd2    COP_1E & $ffff    ;OPSSC 1E - Save the screen
                .dd2    COP_1F & $ffff    ;OPRSC 1F - Restore the screen
                .dd2    COP_20 & $ffff    ;OPSEV 20 - QRY set even
                .dd2    COP_21 & $ffff    ;OPPRE 21 - Allow preemption
                .dd2    COP_22 & $ffff    ;OPRLN 22 - Read a line to buffer
                .dd2    COP_23 & $ffff    ;OPCVS 23 - Convert stack index
                .dd2    COP_24 & $ffff    ;OPCVD 24 - convert direct page index
                .dd2    COP_25 & $ffff    ;OPCRC 25 - superceded use OPSUM
                .dd2    COP_26 & $ffff    ;OPBHA 26 - Get BHA address of immediate string
                .dd2    COP_27 & $ffff    ;OPREF 27 - ?
                .dd2    COP_28 & $ffff    ;OPCMD 28 - call a module
                .dd2    COP_29 & $ffff    ;OPRFR 29 - reference a module
                .dd2    COP_2A & $ffff    ;OPURF 2A - Unreference a module
                .dd2    COP_2B & $ffff    ;OPDIS 2B - ?
                .dd2    COP_2C & $ffff    ;OPFMA 2C - find module by address
                .dd2    COP_2D & $ffff    ;OPWRM 2D - write module name
                .dd2    COP_2E & $ffff    ;OPFPO 2E - find pool owner
                .dd2    COP_2F & $ffff    ;OPIIQ 2F - intercept interrupt
                .dd2    COP_30 & $ffff    ;OPRIQ 30 - release interrupt
                .dd2    COP_31 & $ffff    ;OPMIQ 31 - modify interrupt
                .dd2    COP_32 & $ffff    ;OPSUM 32 - compute end around carry checksum
                .dd2    COP_33 & $ffff    ;OPSLM 33 - scan list of modules
                .dd2    COP_34 & $ffff    ;OPRMI 34 - read module info
                .dd2    COP_35 & $ffff    ;OPAM 35 - Add module
                .dd2    COP_36 & $ffff    ;OPNLU 36 - name lookup
                .dd2    copBadCOP & $ffff ;37
                .dd2    COP_38 & $ffff    ;OPAH 38 - allocate a 16 bit handle
                .dd2    COP_39 & $ffff    ;OPFH 39 - free handle
                .dd2    COP_3A & $ffff    ;OPCUH 3A - call device driver using handle
                .dd2    copBadCOP & $ffff ;3B
                .dd2    COP_3C & $ffff    ;OPDTD 3C - ???
                .dd2    COP_3D & $ffff    ;OPGSR 3D
                .dd2    COP_3E & $ffff    ;OPADY 3E - Add Y to BHA
                .dd2    COP_3F & $ffff    ;OPATR 3F - ???
                .dd2    COP_40 & $ffff    ;OPFTR 40 - ???
                .dd2    COP_41 & $ffff    ;OPECO 41 - call low-level Econet routines
                .dd2    COP_42 & $ffff    ;OPRHL 42 - ???
                .dd2    COP_43 & $ffff    ;OPXKC 43 - Examine keyboard character
                .dd2    COP_44 & $ffff    ;OPOPN 44 - open device driver
                .dd2    COP_45 & $ffff    ;OPCLS 45 - close device driver
                .dd2    COP_46 & $ffff    ;OPEND 46 - test for EOF
                .dd2    COP_47 & $ffff    ;OPMM 47 - call memory management module
                .dd2    COP_48 & $ffff    ;OPVER 48 - return OS version number
                .dd2    COP_49 & $ffff    ;OPFSC 49 - free screen
                .dd2    COP_4A & $ffff    ;OPNET 4A - high level Econet routines
                .dd2    COP_4B & $ffff    ;OPVH 4B - validate handle
                .dd2    COP_4C & $ffff    ;OPBGB 4C - get a block of bytes from a file
                .dd2    COP_4D & $ffff    ;OPBPB 4D - put a block of bytes to a file
                .dd2    COP_4E & $ffff    ;OPLOD 4E - load file
                .dd2    COP_4F & $ffff    ;OPSAV 4F - save a file
                .dd2    COP_50 & $ffff    ;OPRLE 50 - read file load/exec/length
                .dd2    COP_51 & $ffff    ;OPWLE 51 - write file load/exec
                .dd2    COP_52 & $ffff    ;OPRAT 52 - read attributes
                .dd2    COP_53 & $ffff    ;OPWAT 53 - write file attributes
                .dd2    COP_54 & $ffff    ;OPRSP 54 - read sequential pointer
                .dd2    COP_55 & $ffff    ;OPWSP 55 - write sequential pointer
                .dd2    COP_56 & $ffff    ;OPRPL 56 - read physical length
                .dd2    COP_57 & $ffff    ;OPRLL 57 - read logical length
                .dd2    COP_58 & $ffff    ;OPWLL 58 - write logical length
                .dd2    COP_59 & $ffff    ;OPRCH 59 - read catalogue header information
                .dd2    COP_5A & $ffff    ;OPRFN 5A - read object file names from directory
                .dd2    COP_5B & $ffff    ;OPDEL 5B - delete a named object
                .dd2    COP_5C & $ffff    ;OPREN 5C - rename object
                .dd2    COP_5D & $ffff    ;OPSTAR 5D - execute star command and print error
                .dd2    COP_5E & $ffff    ;OPFCX 5E - free vdu context including fonts
                .dd2    COP_5F & $ffff    ;OPOSX 5F - call OSWORD with pointer in X QRY
                .dd2    COP_60 & $ffff    ;OPDFR 60 - ???
                .dd2    COP_61 & $ffff    ;OPERC 61 - ???? error something ???

copBadCOP       cop     COP_0F_OPERR
                .zstr   “Bad COP - use new version”
********************************************************************************
* COP 48 - OPVER - return version number                                       *
*                                                                              *
* Action: Puts the operating system version in A                               *
*                                                                              *
* On Entry: No requirements                                                    *
* On Exit:  A = version number                                                 *
*           DBXY preserved                                                     *
*                                                                              *
* returns 1 in A                                                               *
********************************************************************************
COP_48          lda     #$0001
                sta     DPCOP_AH          ;this is the saved A register
                rtl

********************************************************************************
* COP 15 - OPASC - BBC OPASCI                                                  *
*                                                                              *
* Action: Send the byte in A to the VDU drivers. If the byte is &0D (carriage  *
* return) then send &0A, &0D to the VDU drivers (line feed+ carriage return).  *
*                                                                              *
* On entry: A = character code.                                                *
* On exit:  DBAXY preserved                                                    *
********************************************************************************
COP_15          and     #$00ff
                cmp     #$000d
                bne     COP_00
********************************************************************************
* COP 03 - OSNLI - BBC OSNEWL                                                  *
*                                                                              *
* Action: Send LF CR to the VDU drivers. Line feed is ASCII 10 (decimal),      *
* carriage return is ASCII 13 (decimal).                                       *
*                                                                              *
* On entry: No requirement                                                     *
* On exit:  DBAXY preserved                                                    *
********************************************************************************
COP_03          lda     #$000a
                phk
                jsr     COP_00
                lda     #$000d
********************************************************************************
* COP 00 - OPWRC - Write Char in A                                             *
*                                                                              *
* Action: Send the byte in A to the VDU drivers.                               *
*                                                                              *
* On entry: A = character code                                                 *
* On exit:  DBAXY preserved                                                    *
*                                                                              *
********************************************************************************
COP_00          ldx     #$0004
                phk
                jsr     callModVDU
                rtl

********************************************************************************
* COP 1B - call the ARITHMETIC module                                          *
*                                                                              *
* On Entry: Reason code in X, arithmetic stack pointer in BHA                  *
*                                                                              *
* On Exit:  BHA updated                                                        *
********************************************************************************
COP_1B          ldx     DPCOP_X
                phd
                cop     COP_28_OPCMD
                .zstr   “ARITHMETIC”
                pld
                stx     DPCOP_X
                sta     DPCOP_AH
                sep     #$20
                .rwid   shortm
                phb
                pla
                sta     DPCOP_B
                rtl

********************************************************************************
* COP 26 - OPBHA                                                               *
*                                                                              *
* returns the immediate string following the COP call as BHA                   *
********************************************************************************
                .rwid   longm
COP_26          lda     DPCOP_PC+1
                sta     DPCOP_AH+1
                lda     DPCOP_PC
                inc     A
                sta     DPCOP_AH
; This skips over any string following the cop call
@copExitImmedStr inc    DPCOP_PC
                lda     [DPCOP_PC]
                and     #$00ff
                bne     @copExitImmedStr
                rtl

LFEB7CC         lda     #$0006
                ldx     #$004e
                ldy     #$0000
                phk
                jsr     callModVDU
                lda     #$000c
                ldx     #$004e
                ldy     #$0000
                phk
                jsr     callModVDU
                lda     #$000a
                ldx     #$004e
                ldy     #$0000
                phk
                jsr     callModVDU
                rts

********************************************************************************
* COP 2B - OPDIS                                                               *
*                                                                              *
* QRY                                                                          *
********************************************************************************
COP_2B          jsr     LFEB7CC
LFEB7F7         inc     DPCOP_PC
                lda     [DPCOP_PC]
                and     #$00ff
                beq     LFEB80C
                ldx     #$004e
                ldy     #$0000
                phk
                jsr     callModVDU
                bra     LFEB7F7

LFEB80C         rtl

********************************************************************************
* COP 01 - OPWRS - write string immediate                                      *
*                                                                              *
* read characters from bytes following cop, check for 0 and pass on to write   *
* character routine                                                            *
********************************************************************************
COP_01          inc     DPCOP_PC
                lda     [DPCOP_PC]
                and     #$00ff
                beq     @ret
                phk
                jsr     COP_00
                bra     COP_01

@ret            rtl

********************************************************************************
* COP 02 - OPWRA - write string at BHA                                         *
*                                                                              *
* TODO: DOCO: NOTE: This seems to imply that X is set to 0 for 0 terminated, 1 *
* for control terminated string - not in systems manual                        *
*                                                                              *
********************************************************************************
COP_02          lda     DPCOP_X           ;get passed X and check is < 2 and use to determine type of terminator
                lsr     A
                cmp     #$0002
                bcc     @skok
                brk     $00

                .zstr   “COP `OPWRA: invalid termination option”

@skok           tax
                ldy     #$0000
@lp             lda     [DPCOP_AH],y      ;use BHA at 05 as pointer
                and     #$00ff
                beq     @ret              ;check for 0 terminator
                cpx     #$0001
                bne     @sknocc           ;if X<>1 skip forwards
                cmp     #$0020
                bcc     @ret              ;else exit on control character
@sknocc         phx
                phy
                phk
                jsr     COP_00
                ply
                plx
                iny
                bra     @lp

@ret            rtl

********************************************************************************
* COP 04 - OPRDC - read a character from input                                 *
*                                                                              *
* No conditions                                                                *
*                                                                              *
* On exit:                                                                     *
* if C = 0 then A contains the ASCII value of the character.                   *
* if C = 1 then                                                                *
*   if HA = $1B (@SCESC) then the ESCAPE key was pressed                       *
*   if HA = $00 (@SCPRE) then the current task was pre-empted.                 *
*                                                                              *
* DBXY preserved                                                               *
********************************************************************************
COP_04          phd
                pea     $ac00
                pld                       ;set DP = AC00
                sep     #$30
                .rwid   shortm,shortx
                jsr     int_OPRDC
                pld
                sta     DPCOP_AH          ;return in A, clear B
                stz     DPCOP_AH+1
                rtl

********************************************************************************
* COP 5D - OPSTAR - execute command in BHA                                     *
*                                                                              *
* Action: QRY looks to call OPCOM and if there's an error prints the error     *
********************************************************************************
                .rwid   longm,longx
COP_5D          jsr     doOPSTAR
                rtl

********************************************************************************
* COP 05 - OPCLI - execute command line                                        *
*                                                                              *
* Action: This call sends the address of a command line string to the          *
* operating system's command line interpreter. The string must be terminated   *
* by CR (ASCII &0D).                                                           *
* On entry: either: BYX contains the absolute address of the start of the      *
* command line                                                                 *
* OR: Y is 0 and X contains an offset from the direct page register D. The     *
* start of the command line is in the direct page at address D+X.              *
* On exit: No registers preserved                                              *
********************************************************************************
COP_05          jsr     makeBXYptr
********************************************************************************
* COP 0E OPCOM - execute command at BHA                                        *
*                                                                              *
* Action: This call sends the address of a command line string to the          *
* operating system's command line interpreter. The string must be terminated   *
* by CR (ASCII &0D).                                                           *
* On entry: BHA points to the start of the command                             *
* On exit: No registers preserved                                              *
********************************************************************************
COP_OE          phd
                pea     DPLOC_SYS
                pld
                jsr     defaultCLIV
                pld                       ;back to COP DP that points at user stack
                rep     #$30              ;and update saved registers with results of OSCLI
                sta     DPCOP_AH
                stx     DPCOP_X
                sty     DPCOP_Y
                sep     #$30
                .rwid   shortm,shortx
                phb
                pla
                sta     DPCOP_B
                rtl

********************************************************************************
* COP 06 - OPOSB = OSBYTE                                                      *
*                                                                              *
* This call caries out various operations, the specific operation depending on *
* the contents of A on entry. Other data can be passed in X and Y. If results  *
* are generated, these are returned in X and Y. Only a very small subset of    *
* BBC OSBYTE calls is supported.                                               *
* On entry: A contains the reason code. The reason code determines the         *
* function of the call.                                                        *
*                                                                              *
* On exit: X and Y will contain results if the call produces them.             *
*                                                                              *
* D preserved                                                                  *
********************************************************************************
                .rwid   longm,longx
COP_06          phd
                ldx     DPCOP_X
                sep     #$30
                .rwid   shortm,shortx
                jsr     doDispatchOSBYTE
                pld
                sep     #$30
                stx     DPCOP_X
                stz     DPCOP_X+1
copret8bitY     sep     #$30
                sty     DPCOP_Y
                stz     DPCOP_Y+1
                rtl

********************************************************************************
* COP 5F - OPOSX - QRY                                                         *
*                                                                              *
* looks to call OSWORD but with a different pointer arrangement BYY?           *
********************************************************************************
                .rwid   longm,longx
COP_5F          phd
                pei     (DPCOP_Y)
                bra     LFEB8C1

********************************************************************************
* COP 07 - OPOSW = OSWORD                                                      *
*                                                                              *
* Action: This call caries out various operations, the specific operation      *
* depending on the contents of A on entry. BYX points to a control block in    *
* memory, and this block contains data for the call, and will contain results  *
* from the call.                                                               *
* On entry:                                                                    *
* EITHER: BYX points to a control block in memory                              *
* OR: Y = 0 and X contains an offset from the direct page register D. The      *
* start of the control block is in the direct page at address D+X.             *
* A contains the reason code. The reason code determines the function of the   *
* call.                                                                        *
* On exit: D preserved                                                         *
*                                                                              *
* For OPOSW with A = 0 (read line from input)                                  *
* Y = line length (including CR if applicable).                                *
* If C = 0 then CR termimated input.                                           *
* If C = 1 then ESCAPE terminated input                                        *
********************************************************************************
COP_07          phd
                ldx     DPCOP_X
                jsr     makeBXYptr
; The DP register will point at byte below Y BHA will have been rearranged if
; Y=0 so that BHA = 0/DP+X
; 
; +13   PBR
; +11   PC
; +10   P
; +8    DP
; +7    B
; +5    A
; +3    X
; +1    Y
                pei     (DPCOP_AH)        ;caller A
LFEB8C1         pei     (DPCOP_B-1)       ;caller H,B
                pei     (DPCOP_DP)        ;caller DP
                pea     DPSYS
                pld
                plx
                stx     <DPSYS_D6_OSW_DPSAV
                sep     #$30
                .rwid   shortm,shortx
                plx
                plx
                stx     DPSYS_D8_B_SAV    ;caller's Bank
                rep     #$30
                .rwid   longm,longx
                plx                       ;caller's A (OSWORD number)
                sep     #$30
                .rwid   shortm,shortx
                jsr     enterOSWORD_BHA
                rep     #$30
                .rwid   longm,longx
                pld
                bra     copret8bitY

********************************************************************************
* COP 47 - OPMM - call the memory management routine                           *
*                                                                              *
* Action: This calls the memory management routine. The reason code is passed  *
* in X, and the pool handle is passed in Y. All handles arc 16-bit. so calls   *
* to OPMM must be made in 16-bit XY mode.                                      *
*                                                                              *
* On entry: X = reason code.                                                   *
*           Y = pool handle.                                                   *
* On exit:  If C = 0 then the call succeeded.                                  *
*           If C = I then the call failed. X = error code. BHA points to       *
*           zero-terminated error message.                                     *
*           D preserved                                                        *
********************************************************************************
COP_47          phd
                pei     (DPCOP_X)
                pei     (DPCOP_DP)
                pld
                plx
                jsl     __MM
                pld
                bcs     LFEB8FC
                sta     DPCOP_AH
                stx     DPCOP_X
                sty     DPCOP_Y
                sep     #$20
                .rwid   shortm
                phb
                pla
                sta     DPCOP_B
                rep     #$20
                .rwid   longm
                rtl

LFEB8FC         cop     COP_26_OPBHA
                .zstr   “Memory call failed”
                ldx     #$0001
                sec
                rtl

********************************************************************************
* COP 0D - ERR not implemented                                                 *
*                                                                              *
* Not implemented - throws an error                                            *
********************************************************************************
COP_0D          cop     COP_0F_OPERR
                .zstr   “OPFND used - interface not longer valid”
********************************************************************************
* COP 17 - OPBYX                                                               *
*                                                                              *
* Converts a BBC-type BYX pointer to a Communicator-type BHA pointer, ir Y is  *
* non-zero then YX Ls simply copied to HA. If Y is zero then X is taken as an  *
* ofTset from the direct page register D. BHA is calculated as the absolute    *
* value of this direct page address.                                           *
*                                                                              *
* Entry:                                                                       *
*     BYX points to an address, or Y = 0 and XD points to a direct page        *
* address.                                                                     *
* Exit:                                                                        *
*     BHA points to equivalent address.                                        *
*                                                                              *
*     D preserved                                                              *
********************************************************************************
COP_17          jsr     makeBXYptr
                sta     DPCOP_AH          ;store HA on stack frame at 05
                sep     #$30
                .rwid   shortm,shortx
                phb
                pla
                sta     DPCOP_B           ;store caller's B at 07
                rtl

********************************************************************************
* either: BYX contains the absolute address                                    *
* OR: Y(16) = 0 and X contains an offset from the direct page register D. The  *
* pointer is D+X.                                                              *
*                                                                              *
* This assumes a COP entry frame in DP                                         *
*                                                                              *
********************************************************************************
                .rwid   longm,longx
makeBXYptr      php
                sep     #$30
                .rwid   shortm,shortx
                tya                       ;A(8)=Y(8)
                xba                       ;put Y in H
                lda     DPCOP_X           ;get X in A
                rep     #$30
                .rwid   longm,longx
                ldy     DPCOP_Y           ;check for 0 in Y
                bne     @ret
                clc                       ;if Y is zero
                lda     DPCOP_X           ;add original X to DP and set B=0
                adc     DPCOP_DP
                .dbank  $00
                pea     $0000
                plb
                plb
@ret            plp
                rts

********************************************************************************
* COP 21 - OPPRE - allow preemption                                            *
*                                                                              *
* Action: This call is used lo allow pre-emption of the current task at a      *
* convenient point. The call allows the MOS to check whether the user has      *
* selected another task. If another task has been requested then the call      *
* returns with the carry set, and the event must be acknowledged using OPAEV.  *
*                                                                              *
* On entry: No requirements.                                                   *
*                                                                              *
* On exit:  If C = 0 then the module was not pre-empted.                       *
*           If C = 1 then the module was pre-empted.                           *
*           DBHAXY preserved                                                   *
********************************************************************************
COP_21          pea     $ac00
                pld
                phk
                .dbank  K (auto)
                plb
                sep     #$30
                .rwid   shortm,shortx
                ldal    f:SYSVAR_41_input_stream
                tax
                jsr     OSBYTE_98
                bcs     @noparent
                cmp     #$f0
                bcc     @noparent
                jsr     getCurCorParent
                bcs     @noparent
                xba
                lda     #$00
                xba
                ldx     #$08
                jsl     __CWT
                lda     #>__EVPRE
                xba
                lda     #__EVPRE
                cop     COP_20_OPSEV
                sec
                rtl

@noparent       clc
                rtl

********************************************************************************
* COP 24 - OPCVD - convert DP index                                            *
*                                                                              *
* Action: This call takes a direct page relative address and converts it to an *
* absolute BHA address.                                                        *
*                                                                              *
* On entry: HA contains a 16 bit offset from the direct page register.         *
* On exit:  If C = 0 then BHA contains the absolute address (D+HA).            *
*           If C = 1 then the direct page offset is invalid.                   *
*           DXY preserved                                                      *
********************************************************************************
                .rwid   longm,longx
COP_24          clc
                adc     DPCOP_DP
                bcs     @ret
                sta     DPCOP_AH
                sep     #$20
                .rwid   shortm
                stz     DPCOP_B
@ret            rtl

********************************************************************************
* COP 23 - OPCVS - convert stack index                                         *
*                                                                              *
* Action: This call takes a stack pointer relative address and converts it to  *
* an absolute BHA address.                                                     *
*                                                                              *
* On entry: HA contains a 16 bit offset from the stack pointer.                *
* On exit:  If C = 0 then BHA contains the absolute address (S+HA).            *
*           If C = 1 then the stack offset is invalid.                         *
********************************************************************************
                .rwid   longm
COP_23          phd
                clc
                adc     $01,S
                adc     #$000d
                pld
                bcs     @ret
                sta     DPCOP_AH
                sep     #$20
                .rwid   shortm
                stz     DPCOP_B
@ret            rtl

********************************************************************************
* COP 22 - OPRLN - Read a line to buffer                                       *
*                                                                              *
* Action: This call will read a line of characters from the keyboard. The call *
* uses a control block which gives the address at which the characters are to  *
* be put, the length of this buffer, and the number of characters to be sent   *
* to the VDU drivers. Ihis number can be zero in which case no characters are  *
* printed.                                                                     *
*                                                                              *
* During this call the current task may be pre-empted, in which case the carry *
* flag will indicate as much. If either ESCAPE is pressed or a preempt occurs  *
* then the next cal1 must be to OPAEV to acknowledge the event.                *
*                                                                              *
* On entry:  BHA points to a control block somewhere in memory.                *
*            The format of the control block is as follows.                    *
*   +0 4 byte pointer to the keyboard buffer.                                  *
*        The least significant byte first (0) and the most significant byte    *
*        last (3). The most significant byte mu.stbe zero (&00}.               *
*   +4 2 byte buffer size. The buffer can be any size up to 6SS3S characters.  *
*   +6 2 byte prefix length. This is the number of characters in the buffer    *
*        which will be sent to the VDU drivers. Therefore it must not be       *
*        greater than the buffer size. If the prefix length is zero then no    *
*        characters are sent to the VDU drivers                                *
*   +8 4 byte 0 word for future expansion                                      *
*                                                                              *
* On exit:   If C = 0 then the lirte has been read and the characters are in   *
*            the buffer.                                                       *
*            A contains the terminator of the input siring (CR ASCII 13        *
* decimal).                                                                    *
*            The length of the string in the buffer is given by the 2 bytes at *
*            offset +6 in the control block.                                   *
*            If C = 1 then                                                     *
*            if HA = @SCESC% (£SCESC in MASM) then the ESCAPE key was pressed  *
* or                                                                           *
*            if HA = @SCPRE% (£SCPRE in MASM) then the current task was pre-   *
*            empted.                                                           *
*            DBXY preserved                                                    *
*            Offsets 0 to 5 remain the same.                                   *
********************************************************************************
                .rwid   longm
COP_22          ldy     #$0002
                lda     [DPCOP_AH],y
                xba
                pha
                plb
                plb
                lda     [DPCOP_AH]
                pha
                ldy     #$0004
                lda     [DPCOP_AH],y
                pha
                ldy     #$0006
                lda     [DPCOP_AH],y
                pha
                tax
                beq     LFEB9DD
                cmp     $03,S
                beq     LFEB9DD
                bcc     LFEB9D6
                brl     LFEBA54

LFEB9D6         lda     $03,S
                bne     LFEB9DD
                brl     LFEBA54

LFEB9DD         jsr     LFEEA7B
                cli
                lda     $01,S
                tay
                bra     LFEB9ED

LFEB9E6         lda     #$0007
                dey
LFEB9EA         iny
LFEB9EB         cop     COP_00_OPWRC
LFEB9ED         phx
                lda     #$0000
                xba
                lda     #$0003
                ldx     #$0002
                jsl     __EV
                plx
                bcs     LFEBA6C
                cop     COP_04_OPRDC
                bcs     LFEBA6C
                cmp     #$007f
                bne     LFEBA10
                cpy     #$0000
                beq     LFEB9ED
                dey
                bra     LFEB9EB

LFEBA10         cmp     #$0018
                beq     LFEBA1A
                cmp     #$0015
                bne     LFEBA27
LFEBA1A         tya
                beq     LFEB9ED
                lda     #$007f
LFEBA20         cop     COP_00_OPWRC
                dey
                bne     LFEBA20
                bra     LFEB9ED

LFEBA27         cmp     #$000e
                beq     LFEB9EB
                cmp     #$000f
                beq     LFEB9EB
                cmp     #$000d
                beq     LFEBA3B
                cmp     #$0020
                bcc     LFEB9E6
LFEBA3B         sep     #$20
                .rwid   shortm
                sta     ($05,S),y
                rep     #$20
                .rwid   longm
                cmp     #$000d
                beq     LFEBA5A
                pha
                tya
                cmp     $05,S
                pla
                bcs     LFEB9E6
                cmp     #$0020
                bcc     LFEB9ED
                bra     LFEB9EA

LFEBA54         ldx     #$ffff
                sec
                bra     LFEBA76

LFEBA5A         cop     COP_03_OPNLI
                pha
                lda     #$0000
                xba
                lda     #$0001
                ldx     #$0002
                jsl     __EV
                pla
LFEBA6C         and     #$00ff
                tax
                tya
                ldy     #$0006
                sta     [DPCOP_AH],y
LFEBA76         stx     DPCOP_AH
                ply
                ply
                ply
                rtl

                phk
                jsr     CheckEOF
                bcs     LFEBA97
                lsr     A
                bcc     LFEBA97
                cop     COP_26_OPBHA
                .zstr   “End of file”
                ldx     #$0001
                sec
LFEBA97         rtl

********************************************************************************
* COP 0A - OPBGT - BGET                                                        *
*                                                                              *
* Action: Read one byte from an open device or file. The channel must          *
* previously have been opened using OPOPN.                                     *
*                                                                              *
* On entry: Y contains the handle from OPOPN.                                  *
* On exit:  A contains the byte read from the file.                            *
*           if C = I then an enor has occurred, and A is invalid.              *
*           No registers preserved                                             *
********************************************************************************
COP_0A          phk
                jsr     doBGET
                sta     DPCOP_AH
                bcs     retCopXBHA
                rtl

********************************************************************************
* COP 0B - OPBPT - BPUT                                                        *
*                                                                              *
* Action: Write one byte to an open file or device. The channel must           *
* previously have been opened using OPOPN.                                     *
*                                                                              *
* On entry: Y contains the file handle from OPOPN.                             *
*           A contains the byte to be written.                                 *
* On exit:  No registers preserved                                             *
********************************************************************************
COP_0B          phk
                jsr     doBPUT
                bcs     retCopXBHA
                rtl

********************************************************************************
* COP 44 - OPOPN - open device driver                                          *
* Action: This call opens a device driver.                                     *
* On entry: BHA points to the name (with colon). terminated by CR(&0D).        *
*           Y = &40 for input                                                  *
*           Y = &80 Toroutput                                                  *
*           Y = &C0 for update                                                 *
* On exit:  C = 0 means that the device driver is open and Y = handle.         *
*           If C= I then the device failed to open, the error code is in X     *
*           and BHA points to a zeroterminated error message.                  *
*           D preserved                                                        *
********************************************************************************
COP_44          phk
                jsr     @sk2
                bcs     retCopXBHA
                sty     DPCOP_Y
                rtl

retCopXBHA      stx     DPCOP_X
                sta     DPCOP_AH
                sep     #$20
                .rwid   shortm
                phb
                pla
                sta     DPCOP_B
                rep     #$20
                .rwid   longm
                rtl

********************************************************************************
* COP 45 - OPCLS - close device driver                                         *
* Action: This call closes a device driver which has been opened using OPOPN.  *
*                                                                              *
* On entry: Y = handle allocated by OPOPN.                                     *
* On exit:  If C = 0 then driver is closed.                                    *
*           If C = 1 then the driver close failed, X = error code and BHA      *
*           points to a zero-terminated error message.                         *
*           D preserved                                                        *
********************************************************************************
COP_45          phk
                jsr     closeDevice
                bcs     retCopXBHA
                rtl

********************************************************************************
* COP 46 - OPEND - test for end of file                                        *
* Action: This call will test an open file to see if the end of file has been  *
* reached.                                                                     *
*                                                                              *
* On entry: Y contains the file handle returned by OPOPN.                      *
* On exit:  If C = 0 then                                                      *
*             If lsb A = 0 the end of file has not been reached,               *
*             If lsb A = 1 then the end of file has been reached.              *
*           Note: only the least significant bit of A (or HA) need be tested.  *
*           If C = 1 then the call failed.                                     *
*           X = error code (X = 0 means "Not implemented on this driver").     *
*           BHA points to a zero-terminated error message                      *
*           DAXY preserved                                                     *
********************************************************************************
COP_46          phk
                jsr     CheckEOF
                bcs     retCopXBHA
                sta     DPCOP_AH
                rtl

********************************************************************************
* COP 4B - OPVH - validate handle                                              *
*                                                                              *
* Action: Checks whether a handle is conect for the given device name.         *
* On entry: BHA points to the zero-terminated device name.                     *
*           Y = handle                                                         *
* On exit:  If C = 0 then handle valid.                                        *
*           If C = 1 then handle not valid.                                    *
*           DY preserved                                                       *
********************************************************************************
COP_4B          cpy     #$0100
                bcc     @retNotAHandle
                tyx
                ldal    f:$00000b,x
                and     #$00ff
                eor     #$0010
                cmp     #$0001
                bcs     @retNotAHandle
                ldal    f:DPCOP_X,x
                pha
                lda     DPCOP_AH
                phk
                jsr     LFEF828
                pla
                bcs     @retBadModule
                bvs     @retBadModule
                pha
                txa
                eor     $01,S
                cmp     #$0001
                pla
                bcs     @retBadModule
                rtl

@retNotAHandle  cop     COP_26_OPBHA
                .zstr   “Not a handle”
                bra     @retsecX1

@retBadModule   cop     COP_26_OPBHA
                .zstr   “Bad module”
@retsecX1       ldx     #$0001
                sec
                brl     retCopXBHA

********************************************************************************
* COP 38 - OPAH - allocate 16 bit handle                                       *
* Action: This call allocates a 16 bit handle lo the device whose name is      *
* pointed to by BHA. The handle is returned in Y.                              *
*                                                                              *
* On entry: BHA points to the device name. Device drivers are called with a    *
*           colon appended to the module name to distinguish them from files.  *
*           For example, to allocate a handle for the driver module MODEM,     *
*           BHA must point to "MODEM:"                                         *
*           Y = 0.                                                             *
*                                                                              *
* On exit: If C = 0 then handle was allocated and Y s handle.                  *
*          If C = 1 then the call failed lo allocate a handle.                 *
*          No registers preserved                                              *
********************************************************************************
COP_38          phk
                jsr     LFEF828
                bcs     @retsec
                bvs     @retsec
                phx
                ldy     #$fdfe
                lda     #$0010
                jsr     LFEF8E4
                pla
                bcs     @retsec
                stal    f:$000003,x
                stx     DPCOP_Y
                rtl

@retsec         stz     DPCOP_X
                sec
                rtl

********************************************************************************
* COP 39 - OPFH - free handle                                                  *
*                                                                              *
* Action: This call frees the handle allocated by OPAH.                        *
*                                                                              *
* On entry: Y = handle.                                                        *
* On exit:  If C = 0 then the handle is freed.                                 *
*           If C = 1 then the call failed to free the handle.                  *
*           No registers preserved                                             *
********************************************************************************
COP_39          ldx     DPCOP_Y
                ldy     #$fdfe
                jsr     LFEF92C
                rtl

********************************************************************************
* COP 3A - OPCUH - call device driver using handle                             *
*                                                                              *
* Action: Calls the device driver whose handle was allocated by OPAH.          *
*                                                                              *
* On entry: Y = handle.                                                        *
*           Other registers and/br data as required by device driver.          *
* On exit:  HAXYB registers as returned from device driver.                    *
*           If C = 0 then the codes returned from driver are valid.            *
*           If C = 1 then either the handle was invalid, or the codes returned *
*                                                                              *
*           by the driver are invalid.                                         *
*           D preserved                                                        *
*                                                                              *
* QRY - caller's X is used but not documented?                                 *
********************************************************************************
COP_3A          ldx     DPCOP_X
                phk
                jsr     callDevHandle
                rep     #$30
                sta     DPCOP_AH
                stx     DPCOP_X
                sty     DPCOP_Y
                sep     #$20
                .rwid   shortm
                phb
                pla
                sta     DPCOP_B
                rtl

********************************************************************************
* COP 36 - OPNLU - name lookup                                                 *
*                                                                              *
* Action: This call checks a list of names to see if a qiecific name is        *
* present. If it is then the offset of the name from the start of the list is  *
* given in Y.                                                                  *
*                                                                              *
* On entry: The 4 byte address at D,0 points to the start of the name list.    *
*           The 4 byte address at D,4 points to the name to be located.        *
*           If Y = 0 then the slash "/" character is used as a delimiter.      *
*           If Y <> 0 then the character whose ASCII code is in Y is used as   *
*           a delimiter.                                                       *
* On exit:  If C = 0 then the name is in the list at offset Y from the start   *
*           If C = 1 then the name is not in the list                          *
*           No registers preserved                                             *
*                                                                              *
* TODO: Documentation correction the actual input addresses are D,X and D,X+4  *
********************************************************************************
                .rwid   longm
COP_36          phd
                lda     DPCOP_DP
                clc
                adc     DPCOP_X
                tcd
                phk
                jsr     doNameSearch
                pld
                sty     DPCOP_Y
                rtl

********************************************************************************
* Action: Adds a module to the list of modules held by the MOS.                *
*                                                                              *
* On entry: Y holds the handle of the memory pool in which the module has been *
*           loaded.                                                            *
* On exit:  C = 0 means that the module was added to the list.                 *
*           C = 1 means that the module was not added to the list.             *
*           No registers preserved                                             *
*                                                                              *
* TODO: DOCO: Further to above when C = 1, X = 1 BHA contains a reason string  *
********************************************************************************
COP_35          ldx     #$000e
                jsl     __MM
                bcs     LFEBB9F
                phd
                phb
                phb
                pha
                per     LFEF0EA
                phk
                .dbank  K (auto)
                plb
                tsc
                tcd
                jsr     LFEEF2D
                bcs     LFEBB94
                plx
                phx
                jsr     LFEEF9D
                pla
                pla
                pla
                pld
                clc
                rtl

LFEBB94         pla
                pla
                pla
                pld
                jsr     cop26BadModuleX1
                sec
                brl     retCopXBHA

LFEBB9F         jsr     cop26BadHandleX1
                sec
                brl     retCopXBHA

********************************************************************************
* COP 34 - OPRMI - read module Info                                            *
* Action: Read information about the module whose name is pointed to by BHA.   *
* The entry address can be read, or the flag and code type bytes.              *
*                                                                              *
* On entry: BHA points to module name                                          *
*           X = hint (returned by OPSLM) or 0.                                 *
*           Y = 0 to read entry address (address of BRL).                      *
*           Y = 2 to read the code type bytes.                                 *
*           Y = 4 to read module version.                                      *
*           Note: this COP must be called in 16-bit XY mode to read the        *
*           module-type flags.                                                 *
* On exit:  C = 0 means that the module was found and module information read. *
*           C = 1 means that the module was not found.                         *
*           If C = 0 and Y = 0 then BHA contains the entry address of the      *
*           module, this being the address of the BRL, the first byte of       *
*           the module header.                                                 *
*           If C = 0 and Y = 2 then HA contains code type bytes 0 and 1, X     *
*           contains code type bytes 2 and 3.                                  *
*           If C = 0 and Y = 4 then HA = version.                              *
*           D preserved                                                        *
*                                                                              *
********************************************************************************
COP_34          ldx     #$0000
                ldy     #$0000
                phk
                jsr     LFEF231
                bcs     LFEBBE8
                pei     (DPCOP_Y)
                tdc
                clc
                adc     #$0005
                tcd
                phk
                jsr     LFEF2B7
                plx
                beq     LFEBBD8
                tdc
                dec     A
                dec     A
                tcd
                cpx     #$0002
                bne     LFEBBDA
                ldy     #$000a
                lda     [DPCOP_Y+1],y
                tax
                dey
                dey
                lda     [DPCOP_Y+1],y
                stx     $00
                sta     DPCOP_Y+1
LFEBBD8         clc
                rtl

LFEBBDA         cpx     #$0004
                bne     LFEBBE8
                ldy     #$0006
                lda     [DPCOP_Y+1],y
                sta     DPCOP_Y+1
                clc
                rtl

LFEBBE8         sec
                rtl

********************************************************************************
* COP 33 - OPSLM - scan list of modules                                        *
* Action: This call returns with BHA pointing to a location containing the     *
* name of the next module in the list X and Y return hints used by the         *
* operating system to find this module quickly.                                *
*                                                                              *
* On entry: BHA either points to the name of the previous module, or to a free *
*                                                                              *
*           area of memory containing a number of spaces terminated by zero    *
* (&00).                                                                       *
*           In the latter case, BHA is preserved, and the name of the first    *
*           module in the list is written to the location pointed to by BHA.   *
*           The first name in the list is either truncated or padded with      *
*           spaces to fit the number of spaces allocated on entry.             *
*           X = hint (retunted by previous OPSLM), or 0.                       *
*           Y = hint (returned by previous OPSLM), or 0.                       *
*                                                                              *
* On exit:  BHA points to the name of the next module.                         *
*           X = hint (number used by the operating system).                    *
*           Y = hint (number used by the opeiatmg system).                     *
*           No registers preserved                                             *
*                                                                              *
* To call:                                                                     *
* Example:                                                                     *
* COP                                                                          *
* EQUB@OPSLU% from BASIC                                                       *
********************************************************************************
COP_33          phb
                pha
                phb
                pha
                tsc
                inc     A
                tcd
                ldy     #$0000
                lda     [DPCOP_X],y
                jsr     checkValidModnameChar
                ldal    f:B0LST_MODULES_QRY
                bcs     LFEBC11
                lda     DPCOP_X
                ldx     #$0000
                ldy     #$0000
                phk
                jsr     LFEF231
                bcs     LFEBC74
                ldal    f:$000000,x
LFEBC11         cmp     #$fe0e
                beq     LFEBC74
                tax
                phk
                jsr     LFEF2B7
                ldy     #$000e
                jsr     LFEF343
                ldy     #$ffff
LFEBC24         iny
                bmi     LFEBC74
                lda     [$00],y
                and     #$00ff
                cmp     #$002f
                beq     LFEBC36
                cmp     #$0020
                bcs     LFEBC24
LFEBC36         tyx
LFEBC37         dey
                bmi     LFEBC44
                lda     [DPCOP_X],y
                and     #$00ff
                cmp     #$0020
                bcs     LFEBC37
LFEBC44         ldy     #$0000
LFEBC47         tya
                phx
                cmp     $01,S
                plx
                bcs     LFEBC59
                sep     #$20
                .rwid   shortm
                lda     [$00],y
                sta     [DPCOP_X],y
                rep     #$20
                .rwid   longm
                iny
                bra     LFEBC47

LFEBC59         lda     [DPCOP_X],y
                and     #$00ff
                cmp     #$0020
                bcc     LFEBC6E
                sep     #$20
                .rwid   shortm
                lda     #$20
                sta     [DPCOP_X],y
                rep     #$20
                .rwid   longm
                iny
                bra     LFEBC59

LFEBC6E         clc
LFEBC6F         pla
                plb
                pla
                plb
                rtl

LFEBC74         sec
                bra     LFEBC6F

********************************************************************************
* COP 22 - OPCMD call a module                                                 *
*                                                                              *
* Action:   Call the module whose name, tenninated by zero,follows             *
* cmmediately.                                                                 *
*                                                                              *
* On entry: Any values required by the module to be passed in the registers.   *
*                                                                              *
* Inline string which is the module name terminated by zero (&00).             *
*                                                                              *
* On exit: Carry bit is setand X = 0 if the module was not found.              *
********************************************************************************
COP_28          lda     DPCOP_PC          ;get caller PC
                inc     A                 ;increment to point at the module name
                pei     (DPCOP_PC+1)      ;get caller's program bank into B
                plb
                plb
                ldy     #$0000
                phk
                jsr     brlFindModule     ;look for the module
                bcs     modNotFoundRetZ
                phk
                jsr     LFEEE51
                bcs     modNotFoundRetZ
; make an rti frame that will return to an rti
                phd                       ;an rti frame that will return to an rti
                phk
                per     LFEBCA8
                pea     $0000             ;place 0000 on the stack
                plb                       ;discard stacked byte
                pha                       ;push A (module B0 jump block)
                pea     $0000
                plb                       ;another single 0
                pei     (DPCOP_DP)
                pei     (DPCOP_AH+1)
                plb
                lda     DPCOP_AH
                ldx     DPCOP_X
                ldy     DPCOP_Y
                plb
                pld
; BHAXY are now as per caller
; 
; stack contains
; 
; +7  @rti long address for module to return to which will do another RTI - QRY
; why?
; +6  00 - bank 0
; +4  jump block entry in bank 0
; +3  00 - dummy flags
; +1  caller DP
LFEBCA8         rti

********************************************************************************
* QRY - possible dead code?                                                    *
********************************************************************************
                .rwid   shortm,shortx
                rep     #$30
                .rwid   longm,longx
                pha
                phd
                lda     $05,S
                tcd
                pla
                sta     DPCOP_DP
                pla
                sta     DPCOP_AH
                pld
                stx     DPCOP_X
                sty     DPCOP_Y
                sep     #$20
                .rwid   shortm
                phb
                pla
                sta     DPCOP_B
                rep     #$20
                .rwid   longm
                brl     @copExitImmedStr

modNotFoundRetZ stz     DPCOP_X
                brl     @copExitImmedStr

********************************************************************************
* COP 2A - OPURF - unreference module                                          *
* Action: Let the operating system know you no longer require access to a      *
* module.                                                                      *
* On entry: X points to the start of the 8 byte block in direct page which was *
* initialised when the module was referenced.                                  *
* On exit:  C = 0 means that the module was found and unreferenced.            *
*           C = 1 means that the value in X was invalid.                       *
*           DBHA preserved                                                     *
********************************************************************************
COP_2A          lda     DPCOP_DP
                clc
                adc     DPCOP_X
                tax
                ldal    f:$000002,x
                and     #$00ff
                cmp     #$0001
                ldal    f:$000001,x
                bcs     @skq
                ldal    f:$000000,x
                inc     A
@skq            tcd
                lda     $0b
                and     #$00ff
                cmp     #$0006
                bne     @retSEC
                sep     #$20
                .rwid   shortm
                lda     $07
                beq     @retSEC
                dec     $07
                rep     #$20
                .rwid   longm
                phx
                pld
                stz     $00
                stz     $02
                bcs     @retCLC
                stz     $04
@retCLC         clc
                rtl

                .rwid   shortm
@retSEC         sec
                rtl

********************************************************************************
* COP 29 - OPRFR - reference module                                            *
* Action: Set up entry and return addresses in an 8 byte block in direct page  *
* for the module whose name is pointed to by BHA.                              *
* On entry: BHA points to the module name which is terminated by zero (&00).   *
*           X points to the start of the 8 byte block in direct page which     *
* will                                                                         *
*           be initialised by the OPRFR routine.                               *
*           Y = 0                                                              *
* On exit:  C = 0 means that the module was found and the block initialised.   *
*           C = 1 means that the module was not found.                         *
*           DB preserved.                                                      *
********************************************************************************
                .rwid   longm
COP_29          phk
                jsr     COP_27
                bcs     @ret
                ldal    f:$000001,x       ;adjust the address at offset 01 to be an RTL addres
                dec     A                 ;i.e. subtract 1
                stal    f:$000000,x       ;store at offset 0
                lda     #$0000            ;zero offset 2,3 - QRY bank address address at 01 will always be 0
                stal    f:$000002,x
                lda     #(LFEFE64_anRTL & $ffff)-1 ;make an RTLable address to an RTL
                stal    f:$000003,x
                sep     #$20
                .rwid   shortm
                phk
                pla
                stal    f:$000005,x
                rep     #$20
                .rwid   longm
@ret            rtl

********************************************************************************
* COP 27 - OPREF - OPRFR with different return structure                       *
*                                                                              *
* On Entry: X is a DP offset to an 8 byte block to receive a module pointer    *
*           BHA points to zero terminated module name                          *
*                                                                              *
* On Exit:  C = 0, offset 1,2 in block contain a pointer to code to call the   *
*           module                                                             *
*           C = 1 for not found                                                *
*                                                                              *
* QRY                                                                          *
*                                                                              *
* This looks to be called by OPRFR but OPRFR rearranges the returned block     *
* order                                                                        *
*                                                                              *
* This find the module, and place a                                            *
*                                                                              *
*   phd                                                                        *
*   jsl <module service entry>                                                 *
*   pld                                                                        *
*   rtl                                                                        *
*                                                                              *
* somewhere in bank 0 and place a 16 bit pointer to this at offset 1, the rest *
* of the block in zeroed                                                       *
********************************************************************************
COP_27          lda     DPCOP_DP
                clc
                adc     DPCOP_X           ;HA = DPX
                adc     #$0004
                bcs     @ret              ;Exit with SEC if DPX+4 is outside bank 0
                sbc     #$0003            ;knock back to HA = DPX
                tax                       ;transfer to X
                lda     #$0000            ;clear DPX+0..DPX+7
                stal    f:$000000,x
                stal    f:$000002,x
                stal    f:$000004,x
                stal    f:$000006,x
                phx
                lda     DPCOP_AH          ;get back BHA (module name)
                phk
                jsr     brlGetModCallRef  ;long call actual module find
                plx                       ;get back DPX pointer
                bcs     @ret
                stal    f:$000001,x       ;store pointer at offset 1
@ret            rtl

********************************************************************************
* COP 0F - OPERR - system error                                                *
*                                                                              *
* Action: This is used as a debugging aid. When the call is executed, a fatal  *
* error is generated. A zero-terminated string immediately following the COP   *
* signature is printed, followed by a listing of the contents of the 6SSC8l6's *
* registers. The register string is printed as:                                *
*                                                                              *
*     address of COP OPERR signature byte (3 bytes)                            *
*     status (I byte)                                                          *
*     D (2 bytes)                                                              *
*     BHA (3 bytes)                                                            *
*     X (2 bytes)                                                              *
*     Y (2 bytes)                                                              *
* The bytes are printed as pairs of hexadecimaldigits separated by spaces.     *
*                                                                              *
* On entry: Inline error string.                                               *
* On exit:  No exit the machine "hangs".                                       *
********************************************************************************
COP_0F          cop     COP_01_OPWRS      ;Write a newline TODO: Use OPNLI
                .zstr   $0d,$0a
                phk
                jsr     COP_01            ;QRY - this prints the message after the original caller's COP
                cop     COP_01_OPWRS
                .zstr   $0d,$0a,“*** Fatal System Error:”
                ldx     #$000d
                jsr     @dumpregs
                cop     COP_01_OPWRS
                .zstr   “ ***”,$0d,$0a,$0a
@here           bra     @here             ;hang up the machine

@dumpregs       lda     #$0020            ;dump registers
                cop     COP_00_OPWRC
                lda     $00,x
                jsr     printHexA
                dex
                bne     @dumpregs
                rts

printHexA       pha
                lsr     A
                lsr     A
                lsr     A
                lsr     A
                jsr     printHexNyb
                pla
printHexNyb     pha
                php
                sep     #$20
                .rwid   shortm
                and     #$0f
                ora     #$30
                cmp     #$3a
                bcc     @sk
                adc     #$06
@sk             cop     COP_00_OPWRC
                plp
                .rwid   longm
                pla
                rts

********************************************************************************
* COP 10 - OPADP - Allocate direct page                                        *
*                                                                              *
* Action: This call is used to request a direct page of a certain size, the    *
* size being a 2 byte number which follows the call. The call returns with HA  *
* pointing to an address in bank zero which can be used as the base of the     *
* direct page.                                                                 *
*                                                                              *
* On entry: Inline 2 byte size (in bytes) of direct page requested.            *
* On exit:  C = 0 means that the direct page has been allocated, and HA        *
*           contains the address of the base.                                  *
*           C = 1 means that the call failed to allocate a direct page.        *
*           XY preserved                                                       *
*           Note: D is not preserved.                                          *
*                                                                              *
* TODO: Check against original docuimentation (above) OPADF returns in D not   *
* in HA! check but it looks like DP and HA are set to the new value.           *
*                                                                              *
* QRY - OPADF and OPADP are the SAME - this must surely be a mistake? Or are   *
* they all fast?!                                                              *
********************************************************************************
COP_10          ldy     #$0001
                lda     [DPCOP_PC],y      ;get 16 bit parameter into A
                inc     DPCOP_PC
                inc     DPCOP_PC          ;step return address past it
                ldx     #__MMAZB          ;allocate ZP page pool
                jsl     __MM
                bcs     @fail
                sta     DPCOP_AH
                sta     DPCOP_DP
                eor     #$0000            ;check for 0
                bne     allocOK
                phk
                jsr     COP_12            ;try and free it - TODO why would it return 0, why try and free?
@fail           sec
                rtl

allocOK         phx
                pei     (DPCOP_PC+1)
                plb
                plb                       ;get return bank
                lda     DPCOP_PC          ;get return address
                cop     COP_2C_OPFMA      ;find the module that called us
                bcc     LFEBDFF
                ldx     #__MMFND          ;find memory pool just returned
                jsl     __MM
                lda     #$0000            ;TODO this looks all wrong or am I missing something
                bcs     LFEBE00
                ldal    f:$000008,x       ;TODO this looks all wrong or am I missing something
                tax
LFEBDFF         txa
LFEBE00         plx
                stal    f:DPCOP_DP,x
                clc
                rtl

********************************************************************************
* COP 12 - OPFD - Free direct page                                             *
*                                                                              *
* On Entry:  DP to free in D                                                   *
* On Exit:   C = 0 freed ok                                                    *
*                                                                              *
* QRY no docco                                                                 *
********************************************************************************
COP_12          lda     DPCOP_DP
                sta     DPCOP_AH
********************************************************************************
* COP 1A - OPFZB - free bank 0 memory                                          *
*                                                                              *
* Action: Tells the operating system that space allocated in bank zero is      *
* finished with. This should be done every time space is no longer requited so *
* that bank zero is not exhausted.                                             *
* On entry: HA contains the address of the bank zero pool base.                *
* On exit:  If C = 0 then the pool has been freed.                             *
*           If C = 1 then the routine could not free the pool.                 *
*           No registers preserved                                             *
********************************************************************************
COP_1A          pea     $0000
                plb
                .dbank  $00
                plb
                ldy     #$0001
                ldx     #__MMFND
                jsl     __MM
                bcs     @retsec
                ldx     #__MMBAS
                jsl     __MM
                cmp     DPCOP_AH
                bne     @retsec
                ldx     #__MMFP
                jsl     __MM
                bcs     @retsec
                clc
                rtl

@retsec         sec
                rtl

********************************************************************************
* COP 13 - OPAST - Allocate Stack                                              *
*                                                                              *
* Action: This call is used to request a stack of a certain size, the size     *
* being a 2 byte number which follows the call. The call returns with HA       *
* containing an address which can be transferred to the stack pointer.         *
*                                                                              *
* On entry: Inline 2 byte size (in bytes) of stack requested.                  *
* On exit:  C = 0 means that the stack has been allocated, and HA contains     *
*           the address to be transferred to the stack pointer.                *
*           C = 1 means that the call failed to allocate a stack.              *
*           DBXY preserved                                                     *
********************************************************************************
COP_13          ldy     #$0001
                lda     [DPCOP_PC],y
                inc     DPCOP_PC
                inc     DPCOP_PC
                ldx     #__MMAZB
                jsl     __MM
                bcs     @ret
                ldx     #__MMTOP
                jsl     __MM
                tax
                dex
                dex
                lda     #$dead            ;Store "DEAD" above stack - checked in OPFST (free)
                stal    f:$000000,x
                dex
                stx     DPCOP_AH
                brl     allocOK

@ret            rtl

********************************************************************************
* COP 14 - OPFST - Free a stack                                                *
*                                                                              *
* Action: Tells the operating system that space allocated to a stack is        *
* finished with. This should be done every time a stack is no longer required. *
* Only space allocated by OPAST can be freed by this call.                     *
*                                                                              *
* On entry: HA contains an address within the stack. (This means that the      *
*           current value of the stack pointer can usually be used to free the *
*           stack.)                                                            *
*                                                                              *
* On exit:  If C = 0 then the stack has been freed.                            *
*           If C = I then the routine could not free the stack.                *
*           DBAXY preserved                                                    *
********************************************************************************
COP_14          pea     $0000
                plb
                plb
                ldx     #__MMFND
                jsl     __MM
                bcs     @retsec
                ldx     #__MMTOP
                jsl     __MM
                tax
                dex
                dex
                ldal    f:$000000,x
                cmp     #$dead            ;check for "DEAD" at the top of stack and panic if not there
                bne     @retsec
                ldx     #__MMFP           ;Free it
                jsl     __MM
                rtl

@retsec         sec
                rtl

********************************************************************************
* COP 16 - OPAEV - Acknowledge Event                                           *
*                                                                              *
* Action: This call acknowledges the occurrence of an event                    *
*                                                                              *
* On entry: HA contains the event mask which specifies the events to be        *
*           acknowledged. Possible event masks arc __EVESC to acknowledge the  *
*           ESCAPE event and __EVPRE to acknowledge the pre-emptevent          *
* On exit:  If C = 0 then the specified event is acknowledged.                 *
*           If C = 1 then an attempt was made to clear an event which had not  *
*           previously been set                                                *
*           DBAXY preserved                                                    *
********************************************************************************
COP_16          pha
                ldal    f:SYS_ESCAPE_FLAG_QRY
                tax
                and     $01,S
                eor     $01,S
                cmp     #$0001
                txa
                ora     $01,S
                eor     $01,S
                stal    f:SYS_ESCAPE_FLAG_QRY
                pla
                rtl

********************************************************************************
* COP 20 - OPSEV - Set an event                                                *
*                                                                              *
* QRY                                                                          *
*                                                                              *
* On Entry: HA contains even flags mask that are to be set                     *
********************************************************************************
COP_20          oral    f:SYS_ESCAPE_FLAG_QRY
                stal    f:SYS_ESCAPE_FLAG_QRY
                clc
                rtl

                php
                rep     #$30
                phd
                phb
                pha
                phx
                phy
                cop     COP_01_OPWRS
                .zstr   “  regs:”
                .dd1    $3b
                tcd
                ldx     #$000a
                jsr     @dumpregs
                cop     COP_03_OPNLI
                ply
                plx
                pla
                plb
                pld
                plp
                rts

********************************************************************************
* OPERC 61 - ???? error something ???                                          *
*                                                                              *
* QRY -                                                                        *
*                                                                              *
* looks if X & 1 = 0 then "Error (no message)"                                 *
* the string pointed to BHA is < 4 ASCII chars "Error (terse message)"         *
* if it contains unprintable chars then "Error (bad message)"                  *
* else pass thru BHA                                                           *
********************************************************************************
COP_61          lda     DPCOP_X
                lsr     A
                bcc     bhaErrorNoMessage
                pei     (DPCOP_AH+1)
                plb
                plb
                ldx     DPCOP_AH
                ldy     #$0000
LFEBEDC         phx
                lda     ($01,S),y
                plx
                and     #$00ff
                beq     LFEBEF2
                cmp     #$0020
                bcc     bhaErrorBadErrorMEssage
                cmp     #$007f
                bcs     bhaErrorBadErrorMEssage
                iny
                bra     LFEBEDC

LFEBEF2         cpy     #$0004
                bcc     bhaErrorTerse
                clc
                rtl

bhaErrorNoMessage cop   COP_26_OPBHA
                .zstr   “Error (no message)”
                bra     LFEBF40

bhaErrorBadErrorMEssage cop COP_26_OPBHA
                .zstr   “Error (bad message)”
                bra     LFEBF40

bhaErrorTerse   cop     COP_26_OPBHA
                .zstr   “Error (terse message)”
LFEBF40         .dd1    $48
                lda     DPCOP_X
                ora     #$0001
                tax
                pla
                sec
                brl     retCopXBHA

********************************************************************************
* COP 60 - OPDFR - ????                                                        *
********************************************************************************
COP_60          lda     #$0012
                jsr     LFECE01
                bcs     @reterrNoRoom
                lda     #$0000
                stal    f:$000000,x
                lda     DPCOP_Y
                stal    f:DPCOP_X+1,x
                lda     DPCOP_X
                stal    f:DPCOP_AH+1,x
                lda     DPCOP_DP
                stal    f:DPCOP_Y+1,x
                lda     DPCOP_AH+1
                stal    f:DPCOP_DP+1,x
                lda     DPCOP_AH
                stal    f:DPCOP_DP,x
                phx
                lda     #$fe12
LFEBF7D         tax
                ldal    f:$000000,x
                bne     LFEBF7D
                pla
                stal    f:$000000,x
                clc
                rtl

@reterrNoRoom   cop     COP_26_OPBHA
                .zstr   “No room”
                ldx     #$0001
                brl     retCopXBHA

                .rwid   shortm,shortx
LFEBF9B         php
                phb
LFEBF9D         phd
                rep     #$30
                .rwid   longm,longx
                ldal    f:$00fe12
                beq     LFEBFC5
                tcd
                tax
                lda     $00
                stal    f:$00fe12
                phk
                per     LFEBF9D
                pei     (DPCOP_DP+1)
                pei     (DPCOP_B)
                plb
                pei     (DPCOP_Y+1)
                pei     (DPCOP_AH+1)
                pei     (DPCOP_X+1)
                jsr     LFECDDA
                ply
                plx
                pld
                php
                rti

LFEBFC5         pld
                plb
                plp
                clc
                rtl

********************************************************************************
* COP 43 - OPXKC - examine keyboard character                                  *
* Action: If keyboard buffer is not empty then A becomes the first character   *
* in the buffer. Note that the character is not removed from the keyboard      *
* buffer so repetition of this call will yield the same result. Consequently a *
* call to OPXKC cannot cause a pre-empt tooccur.                               *
*                                                                              *
* On entry: No requirements                                                    *
* On exit:  If C = 0 then A = first character in keyboard buffer.              *
*           If C = I then keyboard buffer is empty.                            *
*           DX preserved                                                       *
*                                                                              *
********************************************************************************
COP_43          phd
                pea     $ac00
                pld
                phk
                .dbank  K (auto)
                plb
                sep     #$30
                .rwid   shortm,shortx
                ldal    f:SYSVAR_41_input_stream
                tax
                jsr     OSBYTE_98
                pld
                sta     DPCOP_AH
                rtl

********************************************************************************
* COP 42 - OPRHL - ???                                                         *
*                                                                              *
* QRY - something Econet-ey                                                    *
********************************************************************************
                .rwid   longm,longx
COP_42          ldal    HW_TYPE_DETECT_QRY
                bne     LFEBFEB
                ldal    HW_ECONET
                bra     LFEBFEF

LFEBFEB         ldal    f:DPSYS+207
LFEBFEF         pha
                and     #$001f
                sta     DPCOP_AH
                pla
                stz     DPCOP_Y
                ror     A
                ror     A
                ror     A
                ror     A
                ror     A
                ror     A
                rol     DPCOP_Y
                ror     A
                rol     DPCOP_Y
                ror     A
                rol     DPCOP_Y
                rtl

********************************************************************************
* COP 41 - OPECO call low - level Econet routines                              *
* Action: This call performs data transfer to and from the Econet filing       *
* system. It performs several tasks depending upon the reason code in X.       *
* On entry: X = reason code.                                                   *
*           Other registers contain or point to arguments.                     *
* On exit:  C = 0 means that the call was successful.                          *
*           If C = 1 and X <> 0 then the call failed and the error code is in  *
* X.                                                                           *
*           If C = 1 and X = 0 then the Econet module is not present           *
*           D preserved                                                        *
********************************************************************************
COP_41          phd
                pha
                ldx     DPCOP_X
                lda     DPCOP_DP
                pea     DPSYS
                pld
                sta     <DPSYS_DPECO      ;caller DP
                lda     <DPSYS_MOD_ECO+4
                ora     <DPSYS_MOD_ECO+2
                ora     <DPSYS_MOD_ECO
                beq     @noeconet
                pla
                phk
                jsr     _callModEconet
                pld                       ;get back COP stack DP
                sta     DPCOP_AH
                stx     DPCOP_X
                sty     DPCOP_Y
                sep     #$20
                .rwid   shortm
                phb
                pla
                sta     DPCOP_B
                rep     #$20
                .rwid   longm
                rtl

@noeconet       pld
                pld
                pld
                stz     DPCOP_X
                sec
                rtl

********************************************************************************
* COP 4A - OPNET high-level Econet routines                                    *
* Action: This call performs several tasks depending upon the reason code in   *
* X.                                                                           *
* On entry: X = reason code.                                                   *
*           Other registers contain or point to arguments.                     *
* On exit:  C = 0 means that the call was successful.                          *
*           If C = 1 then the call failed and the error code is in X.          *
*           If C = 1 and X = 0 then the Econei module is not present.          *
*           If C = 1 and X = 1 then BHA points to an error message.            *
*           D preserved                                                        *
********************************************************************************
COP_4A          phd
                pha
                ldx     DPCOP_X
                pea     DPSYS
                pld
                lda     <DPSYS_MOD_NET+4
                ora     <DPSYS_MOD_NET+2
                ora     <DPSYS_MOD_NET
                beq     @retsec
                pla
                phk
                jsr     _callModNetwork
                pld
                sta     DPCOP_AH
                stx     DPCOP_X
                sty     DPCOP_Y
                sep     #$20
                .rwid   shortm
                phb
                pla
                sta     DPCOP_B
                rep     #$20
                .rwid   longm
                rtl

@retsec         pla
                pld
                stz     DPCOP_X
                sec
                rtl

********************************************************************************
* COP 3F - OPATR - ???                                                         *
********************************************************************************
COP_3F          ldx     #__MMBAS
                jsl     __MM
                bcs     @retSecX0
                tay
                lda     DPCOP_DP
                clc
                adc     DPCOP_X
                tax
                dey
                tya
                stal    f:$000000,x
                phb
                phb
                pla
                stal    f:$000002,x
                per     LFEFE63_anRTL
                pla
                stal    f:$000003,x
                phk
                phk
                pla
                stal    f:$000005,x
                lda     #$dead
                stal    f:$000006,x
                clc
                rtl

@retSecX0       stz     DPCOP_X
                rtl

********************************************************************************
* COP 40 - OPFTR - ??? free something see OPATR                                *
********************************************************************************
COP_40          lda     DPCOP_DP
                clc
                adc     DPCOP_X
                tax
                ldal    f:DPCOP_AH+1,x
                eor     #$dead
                cmp     #$0001
                rtl

********************************************************************************
* COP 3D - OPGSR - ???                                                         *
*                                                                              *
* Does an RTL                                                                  *
********************************************************************************
COP_3D          rtl

********************************************************************************
* COP 3E - OPADY - add Y to BHA                                                *
* Action: BHA becomes BHA+Y. Y is zeroed.                                      *
*                                                                              *
* On entry: No requirements                                                    *
* On exit:  BHA := BHA + Y                                                     *
*           Y = 0                                                              *
*           DBX preserved                                                      *
********************************************************************************
COP_3E          clc
                adc     DPCOP_Y
                sta     DPCOP_AH
                bcc     LFEC0B9
                sep     #$20
                .rwid   shortm
                inc     DPCOP_B
                rep     #$20
                .rwid   longm
LFEC0B9         stz     DPCOP_Y
                rtl

********************************************************************************
* COP 32 - OPSUM - compute end-around-carry sum                                *
*                                                                              *
* Action: Gives a sum of all the bits in a block whose start is pointed to by  *
* BHA and whose length in bytes is in Y.                                       *
*                                                                              *
* On entry: BHA points to thestartof the block to be summed.                   *
*           Y = length of block in bytes.                                      *
* On exit:  If C = 0 then thesum has been computed and theresult is in HA.     *
*           If C = 1 then either the length was zero (Y = 0) or all the bytes  *
*           in the block were zero (HA = 0).                                   *
*           DXY preserved                                                      *
********************************************************************************
COP_32          tyx                       ;byte count into X
                beq     @retzsec
                lda     #$0000            ;sum
                tay                       ;zero offset
                clc
@lp             dex
                bne     @nla              ;if zero here then 1 byte left
                pha
                lda     [DPCOP_AH],y
                iny
                and     #$00ff
                adc     $01,S             ;add to low part of stacked A
                sta     $01,S
                pla                       ;pop A
                bra     LFEC0DC           ;and return

@nla            adc     [DPCOP_AH],y
                iny
                iny
                dex
                bne     @lp
LFEC0DC         adc     #$0000            ;add last carry in
                beq     @retzsec
                tax
                eor     [DPCOP_AH],y      ;this looks to additionally check against any checksum after the block
                stx     DPCOP_AH
                cmp     #$0001            ;return Z for match QRY - check this
                rtl

@retzsec        stz     DPCOP_AH
                sec
                rtl

********************************************************************************
* COP 2E - OPFPO - find pool owner                                             *
*                                                                              *
* Action This call attempts to find the module which owns the memory pool      *
* pointed to by BHA.                                                           *
*                                                                              *
* On Entry: BHA points to the pool address.                                    *
*           Y = 0                                                              *
* On Exit:  If C = 0 then the pool owner has been found, and BHA ptnnts to an  *
*           address within the owner module.                                   *
*           If C = 1 then the owner was not found.                             *
*           No registers preserved                                             *
*                                                                              *
* TODO DOCO: Further to documented API if Y non-zero on entry then BHA is      *
* ignored instead Y is used as a pool handle                                   *
********************************************************************************
COP_2E          phd
                phy
                ply
                bne     LFEC0FC           ;if Y<>0 then skip MMFND and use passed Y
                ldx     #__MMFND
                jsl     __MM
                bcs     @retpld
LFEC0FC         jsr     LFECEDA
                bcs     @retpld
                ldal    f:$000008,x       ;QRY - TODO find out what __MMFND returns in X - undocumented!
                pha
                ldx     #B0LST_MODULES_QRY ;get head of modules list
LFEC109         ldal    f:$000000,x       ;get next module
                cmp     #B0LST_MODULES_QRY ;check for back round to start
                beq     @retpldpld        ;exit with C = 1
                tax                       ;transfer A to X
                cmp     $01,S
                bne     LFEC109
                tsc
                tcd
                phb
                phk
                jsr     LFEF22E
                pla
                plb
                pld
                sta     DPCOP_AH
                sep     #$20
                .rwid   shortm
                phb
                pla
                sta     DPCOP_B
                clc
                rtl

                .rwid   longm
@retpldpld      pld
@retpld         pld
                rtl

********************************************************************************
* COP 2D - OPWRM - write module name                                           *
*                                                                              *
* Action: Given an address in BHA. this call will send the name of the module  *
* which exists at that addressto the VDU drivers. If no module exists at that  *
* address then the call returns with the carry bit set.                        *
*                                                                              *
* On entry: BHA points to somewhere within a module.                           *
* On exit:  If C = 0 then the name of the module has been sent to the VDU      *
* drivers.                                                                     *
*           If C = 1 then the module was not found.                            *
*           D preserved                                                        *
********************************************************************************
COP_2D          cop     COP_2C_OPFMA      ;find the module
                bcs     @ret              ;branch if not found
                phb
                pha
                tsc
                tcd
                ldy     #$0000
@lp             lda     [$01],y           ;get chars from pointer on stack
                and     #$00ff
                beq     @done
                cmp     #‘/’
                beq     @done             ;module name terminator
                jsr     modNameToUpper
                xba
                cop     COP_00_OPWRC
                iny
                bne     @lp
@done           pla
                plb
                clc
@ret            rtl

********************************************************************************
* COP 2C - OPFMA - find module given address within module                     *
*                                                                              *
* Action: Given an address in BHA, this call will reutm in BHA the address of  *
* the name of the module tat exists at that address. If no module exists at    *
* that address then the call returns with the carry bit set.                   *
*                                                                              *
* On entry: BHA points to somewhere within a module.                           *
* On exit:  If C = 0 then BHA points to the module name.                       *
*           If C = 1 then the module was not found.                            *
*           D preserved                                                        *
********************************************************************************
COP_2C          phk
                jsr     brlFindModuleByAddress
                stx     DPCOP_X
                bcs     @ret
                sta     DPCOP_AH
                sep     #$20
                .rwid   shortm
                phb
                pla
                sta     DPCOP_B
                rep     #$20
                .rwid   longm
@ret            rtl

********************************************************************************
* COP 18 - OPRLH - Read hex number                                             *
*                                                                              *
* Action: BHA points to a line of hex in meniory. This call translates a       *
* certain number of hex digits into nibbles stored starting at the location    *
* pointed to by DX. The number of nibbles required is in Y.                    *
*                                                                              *
* On entry: BHA points to line of hexcharacters.                               *
*           DX points to location at which number is to be stored in direct    *
*           page.                                                              *
*           Y contains the number of nibbles required.                         *
* On exit:  BHA points to the rest of the line.                                *
*           If C = 0 then DX points to the Y nibbles in direct page.           *
*           If C = 1 then the call failed.                                     *
*           DXY preserved                                                      *
********************************************************************************
COP_18          lda     DPCOP_DP
                clc
                adc     DPCOP_X
                bcs     @secrts
                tax
                lda     DPCOP_Y
                inc     A
                beq     @secrts
                lsr     A
                beq     @secrts
                tay
                sep     #$20
                .rwid   shortm
                phx
                phy
                lda     #$00
@zlp            stal    f:$000000,x       ;zero the result
                inx
                dey
                bne     @zlp
                ply
                plx
                rep     #$20
                .rwid   longm
                jsr     scanHexBHA
                bcs     @secrts
LFEC18D         jsr     getCharBHAinc
                bcs     @clcret
                jsr     parseHexDigit
                bcs     @clcret
                jsr     LFEC201
                bcs     LFEC1A0
                bra     LFEC18D

@clcret         clc
                rtl

LFEC1A0         jsr     @lp2
@secrts         sec
                rtl

@lp2            jsr     getCharBHAinc
                bcs     @ret
                jsr     parseHexDigit
                bcc     @lp2
                jsr     decDPCOP_BHA
                clc
@ret            rts

getCharBHAinc   lda     [DPCOP_AH]
                and     #$00ff
                jsr     incDPCOP_BHA
                cmp     #‘ ’
                bcs     @retclc
                jsr     decDPCOP_BHA
                sec
                rts

@retclc         cmp     #‘:’
                bcc     @daft             ;TODO: beautiful - I think this can go?
@daft           clc
                rts

parseHexDigit   cmp     #‘0’
                bcc     @retsec
                cmp     #‘:’
                bcc     @sk09
                and     #$00df
                cmp     #‘A’
                bcc     @retsec
                cmp     #‘G’
                bcs     @retsec
                sec
                sbc     #$0037
                clc
                rts

@sk09           sec
                sbc     #‘0’
                clc
                rts

@retsec         sec
                rts

scanHexBHA      jsr     getCharBHAinc
                bcs     @retsec
                jsr     parseHexDigit
                bcs     scanHexBHA
                jsr     decDPCOP_BHA
                clc
@retsec         rts

LFEC201         asl     A
                asl     A
                asl     A
                asl     A
                asl     A
                asl     A
                asl     A
                asl     A
                asl     A
                asl     A
                asl     A
                asl     A
                asl     A
                jsr     LFEC243
                bcs     LFEC23F
                asl     A
                jsr     LFEC243
                bcs     LFEC23F
                asl     A
                jsr     LFEC243
                bcs     LFEC23F
                asl     A
                jsr     LFEC243
                bcs     LFEC23F
                lda     DPCOP_Y
                lsr     A
                bcc     LFEC241
                phx
                phy
                sep     #$20
                .rwid   shortm
LFEC22E         inx
                dey
                bne     LFEC22E
                dex
                lda     #$0f
                cmpl    f:$000000,x
                rep     #$20
                .rwid   longm
                ply
                plx
                bcs     LFEC241
LFEC23F         sec
                rts

LFEC241         clc
                rts

LFEC243         pha
                sep     #$20
                .rwid   shortm
                phx
                phy
LFEC248         ldal    f:$000000,x
                rol     A
                stal    f:$000000,x
                inx
                dey
                bne     LFEC248
                ply
                plx
                rep     #$20
                .rwid   longm
                pla
                rts

incDPCOP_BHA    inc     DPCOP_AH
                bne     @sk
                sep     #$20
                .rwid   shortm
                inc     DPCOP_B
                rep     #$20
                .rwid   longm
@sk             rts

decDPCOP_BHA    pha
                lda     DPCOP_AH
                cmp     #$0001
                dec     DPCOP_AH
                bcs     @ret
                sep     #$20
                .rwid   shortm
                dec     DPCOP_B
                rep     #$20
                .rwid   longm
@ret            pla
                rts

********************************************************************************
* COP 19 - OPRLS - ?                                                           *
*                                                                              *
* Appears to read a string surrounded by quotes into a buffer at DPX, length Y *
********************************************************************************
COP_19          lda     DPCOP_DP
                clc
                adc     DPCOP_X
                bcs     @retsec
                tax
@scanlp         jsr     getCharBHAinc     ;skip forward looking for quotes
                bcs     @retsec
                cmp     #‘"’
                bne     @scanlp
                ldy     #$0000
@lp             jsr     getCharBHAinc
                bcs     @retsec
                cmp     #‘"’
                bne     @noq
                jsr     getCharBHAinc     ;check for ""
                bcs     @zetend
                cmp     #‘"’
                bne     @decretok
@noq            jsr     @staDPY           ;store char
                iny
                beq     @retsec
                bra     @lp

@decretok       jsr     decDPCOP_BHA
@zetend         lda     #$0000
                jsr     @staDPY
                cpy     DPCOP_Y
                sty     DPCOP_Y
                rtl

@retsec         sec
                rtl

@staDPY         cpy     DPCOP_Y
                bcs     @ret
                phd
                phx
                pld
                sep     #$20
                .rwid   shortm
                sta     [$00],y
                rep     #$20
                .rwid   longm
                pld
@ret            rts

********************************************************************************
* COP 1C - OPSCX - Save context                                                *
*                                                                              *
* Action: Used by the menu program (and others) to save the context of the     *
* screen and the operating system variables when switching to a different      *
* task. It must be used only after an OPSSC call.                              *
*                                                                              *
* On entry: No Requirements.                                                   *
* On exit:  If C = 0 then the call succeeded and Y contains the context pool   *
*           handle.                                                            *
*           If C = 1 then the call failed.                                     *
*           D preserved                                                        *
********************************************************************************
COP_1C          ldx     #__VDU_4A
                phk
                jsr     callModVDU        ;Get VDU variables size QRY - VDU mod seems to return 000080
                ldx     #$000c
                jsr     BXXaddHA
                ldy     #$0002
                ldx     #__MMALA
                jsl     __MM
                bcs     LFEC2EE
                sty     DPCOP_Y
                jsr     saveCTX
                ldx     #__VDU_42
                phk
                jsr     callModVDU
                clc
LFEC2EE         rtl

********************************************************************************
* COP 1D - OPRCX - Restore context                                             *
*                                                                              *
* Action: Used by the menu program (and othets) to restore a context           *
* previously saved using OPSCX. It must be used only before an OPRSC call.     *
*                                                                              *
* On entry: Y = context pool handle allocated by OPSCX. Must be in 16bit       *
* XYmode.                                                                      *
* On exit:  If C = O then the context is restored and the pool freed.          *
*           If C = I then the call failed.                                     *
*           D preserved                                                        *
********************************************************************************
COP_1D          ldx     #__MMBAS
                jsl     __MM
                bcs     @ret
                jsr     restoreCTX
                ldx     #__VDU_46
                phk
                jsr     callModVDU
                ldy     DPCOP_Y
                ldx     #__MMFP
                jsl     __MM
@ret            rtl

********************************************************************************
* COP 1E - OPSSC - save the screen                                             *
*                                                                              *
* Action: Used by the menu program (and others) to save the contents of the    *
* screen display.                                                              *
*                                                                              *
* On entry: Must be in 16bit XY mode.                                          *
* On exit: If C = 0 then the call succeeded and Y contains the screenpool      *
* handle.                                                                      *
*          If C = 1 then the call failed.                                      *
*          D preserved                                                         *
********************************************************************************
COP_1E          ldx     #__VDU_40
                phk
                jsr     callModVDU
                ldy     #$0002
                ldx     #__MMASA
                jsl     __MM
                bcs     LFEC329
                sty     DPCOP_Y
                ldx     #__VDU_44
                phk
                jsr     callModVDU
                clc
LFEC329         rtl

********************************************************************************
* COP 1F - OPRSC - restore the screen                                          *
*                                                                              *
* Action: Used by the menu program (and others) to restore the contents of a   *
* screen previously saved using OPSSC.                                         *
*                                                                              *
* On entry: Y = screen pool handle allocated by OPSSC.                         *
* On exit:  If C = O then the screen is restored and the pool freed.           *
*           If C = 1 then the call failed.                                     *
*           D preserved                                                        *
********************************************************************************
COP_1F          ldx     #__MMBAS
                jsl     __MM              ;check the pool handle and get the base
                bcs     @ret
                ldx     #__VDU_48
                phk
                jsr     callModVDU        ;copy screen back
********************************************************************************
* COP 49 - OPFSC - free screen                                                 *
*                                                                              *
* Action: Frees a saved screen which is no longer required.                    *
*                                                                              *
* On entry: Y = screen pool handle allocated by OPSSC.                         *
* On exit:  If C = O then the screen is freed and the pool handle freed.       *
*           If C = 1 then the call failed.                                     *
*           D preserved                                                        *
********************************************************************************
COP_49          ldy     DPCOP_Y
                ldx     #__MMFP
                jsl     __MM              ;free the pool
@ret            rtl

********************************************************************************
* COP 5E - OPFCX free context of VDU and MOS (including fonts)                 *
*                                                                              *
* Action: Frees a saved context that is no longer required.                    *
*                                                                              *
* On entry: Y = context pool handle allocated by OPSCX.                        *
* On exit:  If C = 0 then the context is freed and the pool handle freed.      *
*           If C = 1 then the call failed to free the context                  *
*           D preserved                                                        *
********************************************************************************
COP_5E          ldx     #__MMBAS
                jsl     __MM
                bcs     @retsec
                phy
                ldx     #$000c
                jsr     BXXaddHA
                ldx     #$0052
                phk
                jsr     callModVDU
                ply
                bra     COP_49

@retsec         sec
                rts

; This appears to be a set of B0 locations that are saved on a context switch
tblVarsToSaveCtx .dd2   $ff13
                .dd2    $ff14
                .dd2    $a552
                .dd2    $a553
                .dd2    $a551
                .dd2    $a571
                .dd2    $a572
                .dd2    $a573
                .dd2    $a574
                .dd2    $a576
                .dd2    $a57d
                .dd2    $a53c
                .dd2    $0000
restoreCTX      clc
                bra     LFEC37E

saveCTX         sec
LFEC37E         phd
                phb
                pha
                tsc
                tcd
                phk
                .dbank  K (auto)
                plb
                ldx     #$0000
                txy
@ctxReStLp      phx
                lda     tblVarsToSaveCtx & $ffff,x
                beq     @done
                tax
                sep     #$20
                .rwid   shortm
                bcc     @dores
                ldal    f:$000000,x
                sta     [DPCOP_Y],y
                bra     @sk

@dores          lda     [DPCOP_Y],y
                stal    f:$000000,x
@sk             rep     #$20
                .rwid   longm
                iny
                plx
                inx
                inx
                bra     @ctxReStLp

@done           plx
                bcc     @skres
                lda     #$0000
                stal    f:SYS_ESCAPE_FLAG_QRY
@skres          pla
                plb
                pld
                ldx     #$000c
BXXaddHA        php
                phx
                clc
                adc     $01,S
                plx
                bcc     @sk
                sep     #$20
                .rwid   shortm
                phb
                pla
                inc     A
                pha
                plb
@sk             plp
                .rwid   longm
                rts

********************************************************************************
* COP 25 - OPCRC - superceded use COP_32 OPSUM                                 *
********************************************************************************
COP_25          cop     COP_0F_OPERR
                .zstr   “Bad call - OPCRC has been superceded by OPSUM”
********************************************************************************
* COP 4C - OPBGB get block                                                     *
* Action: Reads the number of bytes specified in the control block from the    *
* currently open file whose handle is in Y, to the address in memory specified *
* in the control block. The bytes are read from the file starting at the       *
* position given by the sequential pointer. The sequential pointer can be      *
* altered using OPWSP.                                                         *
*                                                                              *
* On Entry: Y = handle returned by OPOPN.                                      *
*           BHA points to a control block of the following form.               *
*           Offset                                                             *
*           +0      Start address of memory (low byte first)                   *
*           +4      Length of memory to be transferred (low byte first)        *
* On Exit:  If C = 0 then X = O means transfer successful.                     *
*                         X = 2 means that fewer bytes were transferred than   *
*                               specified in the control block, and the        *
* control                                                                      *
*                               block is updated to show the number of bytes   *
*                               that were transferred.                         *
*           If C = 1 then the transfer was unsuccessful. X = error code. BHA   *
*           points to a zero terminated error message                          *
********************************************************************************
COP_4C          php
                phd
                rep     #$30
                ldx     #$0020
                phx
                bra     LFEC40D

********************************************************************************
* COP 4D - OPBPB put block                                                     *
* Action: Writes the number of bytes specified in the control block. from the  *
* address in memory specified in the control block, to the file whose handle   *
* is in Y. The bytes are written to the file starting at the position given by *
* the sequential pointer. The sequential pointer can be altered using OPWSP.   *
* On entry: Y = handle returned by OPOPN.                                      *
*           BHA points to a control block ot the following form.               *
*           Offset                                                             *
*           +0 Start address of memory (low byte first)                        *
*           +4 Length of memory to be transferred (low byte first)             *
* On exit:  If C = 0 then transfer was successful.                             *
*           If C = 1 then the transfer was unsuccessful. X = error code. BHA   *
*           points to a zero terminated error message.                         *
*           Y preserved                                                        *
********************************************************************************
COP_4D          php
                phd
                rep     #$30
                ldx     #$0022
                phx
LFEC40D         phy
                phk
                jsr     callDevHandle
                bcs     LFEC41C
LFEC414         ply
                ply
                ply
                php
                ply
                brl     retCopXBHA

LFEC41C         txy
                bne     LFEC414
                ldy     #$0006
                jsr     LFEC6AA
                lda     DPCOP_B
                ora     DPCOP_DP+1
                beq     LFEC445
                lda     #$ffff
                dec     DPCOP_B
                cmp     DPCOP_B
                bne     LFEC436
                dec     DPCOP_DP+1
LFEC436         ldx     DPCOP_K
                cpx     #$0020
                bne     LFEC442
                jsr     LFEC44C
                bra     LFEC445

LFEC442         jsr     LFEC496
LFEC445         stx     DPCOP_K
                plx
                txs
                jmp     LFEC6BD

LFEC44C         ldy     DPCOP_PC
                cop     COP_0A_OPBGT
                sep     #$30
                .rwid   shortm,shortx
                sta     [DPCOP_X]
                rep     #$30
                .rwid   longm,longx
                bcs     LFEC473
                lda     #$ffff
                dec     DPCOP_B
                cmp     DPCOP_B
                bne     LFEC467
                dec     DPCOP_DP+1
                cmp     DPCOP_DP+1
                beq     LFEC46F
LFEC467         inc     DPCOP_X
                bne     LFEC44C
                inc     DPCOP_AH
                bra     LFEC44C

LFEC46F         ldx     #$0000
                rts

LFEC473         phd
                lda     $0f
                tcd
                ldy     #$0000
                sec
                lda     $07,S
                sbc     [DPCOP_AH],y
                ldy     #$0004
                sta     [DPCOP_AH],y
                ldy     #$0002
                lda     $09,S
                sbc     [DPCOP_AH],y
                ldy     #$0006
                sta     [DPCOP_AH],y
                ldx     #$0002
                clc
                pld
                rts

LFEC496         ldy     DPCOP_PC
                lda     [DPCOP_X]
                cop     COP_0B_OPBPT
                bcs     LFEC4B6
                lda     #$ffff
                dec     DPCOP_B
                cmp     DPCOP_B
                bne     LFEC4AD
                dec     DPCOP_DP+1
                cmp     DPCOP_DP+1
                beq     LFEC4B5
LFEC4AD         inc     DPCOP_X
                bne     LFEC496
                inc     DPCOP_AH
                bra     LFEC496

LFEC4B5         clc
LFEC4B6         rts

********************************************************************************
* COP 4E - OPLOD - load file                                                   *
*                                                                              *
* Action: Loads a file into memwy from the specified filing system.            *
*                                                                              *
* On entry: BHA points to a control block of the following form.               *
*           Offset                                                             *
*           +0     Pointer to name of file (low byte first)                    *
*           +4     File LOAD address (low byte first)                          *
*           +8     File EXEC address (low byte first)                          *
*           +12    Initial memory location (low byte first)                    *
*           +16    Length of memory area (low byte first)                      *
*                                                                              *
*           A zero length parameter will cause anylength of file to be loaded. *
*                                                                              *
*           The length is updated upon exit to show the number of bytes        *
* actually                                                                     *
*           loaded.                                                            *
*           The load address and execution address are not parameters they are *
*                                                                              *
*           set on exit to the file's values.                                  *
* On exit:  If C = 0 and X = O then the file was loaded successfully and the   *
*           load and execution addresses are valid.                            *
*           If C = 0 and X = 2 then the file was loaded successfully but the   *
*           load and execution addressess are invalid.                         *
*           If C = 1 then the load was unsuccessful, X = error code. BHA       *
* points                                                                       *
*           to a zero-terminated error message.                                *
*           Y preserved                                                        *
********************************************************************************
COP_4E          php
                phd
                rep     #$30
                ldx     #$0024
                phx
                bra     LFEC4C9

********************************************************************************
* COP 4F - OPSAV - save file                                                   *
*                                                                              *
* Action: Saves an area of memory to the specified filing system.              *
*                                                                              *
* On entry: BHA points to a control block of the following form.               *
*           Offset                                                             *
*           +0   Pointer to name of file (low byte first)                      *
*           +4   File LOAD address (low byte first)                            *
*           +8   File EXEC address (low byte first)                            *
*           +12  Initial memory location (low byte first)                      *
*           +16  Length ot memory area (low byte first)                        *
* On exit:  If C = 0 and X = 0 then the file was saved successfully and the    *
*           load and execution addresses were successfully updated.            *
*           If C = 0 and X = 2 then the file was saved successfully but the    *
*           load and execution addresses were not successfully updated.        *
*           If C = 1 then the save was unsuccessful. X = error code. BHA       *
* points                                                                       *
*           to zero-terminated error message.                                  *
*           Y preserved.                                                       *
********************************************************************************
COP_4F          php
                phd
                rep     #$30
                ldx     #$0026
                phx
LFEC4C9         phy
                jsr     LFEC7A1
                bcs     LFEC4D7
LFEC4CF         ply
                ply
                ply
                php
                ply
                brl     retCopXBHA

LFEC4D7         txy
                bne     LFEC4CF
                ldy     #$0012
                jsr     LFEC6AA
                lda     #$ffff
                dec     $13
                cmp     $13
                bne     LFEC4EB
                dec     $15
LFEC4EB         ldx     $19
                cpx     #$0024
                bne     LFEC4F7
                jsr     LFEC501
                bra     LFEC4FA

LFEC4F7         jsr     LFEC5B1
LFEC4FA         stx     $19
                plx
                txs
                jmp     LFEC6BD

LFEC501         lda     $13
                and     $15
                cmp     #$ffff
                bne     LFEC50F
                sec
                ldx     #$0000
                rts

LFEC50F         phd
                lda     $1b
                tcd
                sep     #$30
                .rwid   shortm,shortx
                lda     DPCOP_B
                pha
                plb
                rep     #$30
                .rwid   longm,longx
                lda     DPCOP_AH
                pld
                cop     COP_50_OPRLE
                bcs     LFEC528
                pea     $0000
                tay
                bra     LFEC543

LFEC528         pea     $0002
                lda     #$ffff
                sta     $19
                bra     LFEC543

                .dd1    $98
                .dd1    $18
                .dd1    $e5
                .dd1    $13
                .dd1    $8a
                .dd1    $e5
                .dd1    $15
                .dd1    $90
                .dd1    $08
                .dd1    $f0
                .dd1    $06

LFEC53D         plx
                ldx     #$8000
                sec
                rts

LFEC543         ldy     #$0040
                jsr     LFEC604
                bcc     LFEC54E
                brl     LFEC5AF

LFEC54E         sty     $17
LFEC550         cop     COP_0A_OPBGT
                bcs     LFEC573
                sep     #$30
                .rwid   shortm,shortx
                sta     [$0f]
                rep     #$30
                .rwid   longm,longx
                lda     #$ffff
                dec     $13
                cmp     $13
                bne     LFEC569
                dec     $15
                cmp     $15
                beq     LFEC53D
LFEC569         ldy     $17
                inc     $0f
                bne     LFEC550
                inc     $11
                bra     LFEC550

LFEC573         phy
                cop     COP_46_OPEND
                ply
                phx
                pha
                phb
                ldy     $17
                cop     COP_45_OPCLS
                plb
                pla
                plx
                bcs     LFEC5AF

                and     #$0001
                bne     LFEC58E
                sec
                ldx     #$9000
                bra     LFEC5AF

LFEC58E         phd
                lda     $1b
                tcd
                ldy     #$000c
                sec
                lda     $15,S
                sbc     [DPCOP_AH],y
                ldy     #$0010
                sta     [DPCOP_AH],y
                ldy     #$000e
                lda     $17,S
                sbc     [DPCOP_AH],y
                ldy     #$0012
                sta     [DPCOP_AH],y
                pld
                clc
                plx
                rts

LFEC5AF         ply
                rts

LFEC5B1         ldy     #$0080
                jsr     LFEC604
                bcc     LFEC5BC
                brl     LFEC5F4

LFEC5BC         lda     $13
                and     $15
                cmp     #$ffff
                beq     LFEC5E4
LFEC5C5         phy
                lda     [$0f]
                cop     COP_0B_OPBPT
                ply
                bcs     LFEC5FA
                lda     #$ffff
                dec     $13
                cmp     $13
                bne     LFEC5DC
                dec     $15
                cmp     $15
                beq     LFEC5E4
LFEC5DC         inc     $0f
                bne     LFEC5C5
                inc     $11
                bra     LFEC5C5

LFEC5E4         cop     COP_45_OPCLS
                bcs     LFEC5F4
                lda     #$0003
                cop     COP_24_OPCVD
                cop     COP_51_OPWLE
                bcs     LFEC5F5
                ldx     #$0000
LFEC5F4         rts

LFEC5F5         ldx     #$0002
                clc
                rts

LFEC5FA         phx
                phb
                pha
                cop     COP_45_OPCLS
                pla
                plb
                plx
                sec
                rts

LFEC604         lda     DPCOP_AH
                xba
                pha
                plb
                plb
                lda     DPCOP_X
                cop     COP_44_OPOPN
                rts

********************************************************************************
* COP 50 - OPRLE - read load address, execute address, and length of file      *
*                                                                              *
* Action: Reads the load address, execute address, and length of a file.       *
*                                                                              *
* On Entry: BHA points to a contnd block of the following form.                *
*           Offset                                                             *
*           +0   Pointer to name of file (low byte first)                      *
*           +4   File LOAD address (low byte first)                            *
*           +8   File EXEC address (low byte first)                            *
*                                                                              *
*           The load address and execution address are not paramcters they     *
*           are set on exit to the file's values.                              *
* On Exit:  If C = 0 then the control block has been updated to give the load  *
*           and execute addresses, and the length is in XHA (2 bytes in X,     *
*           4 bytes in total).                                                 *
*           If C = 1 then the call was unsuccessful, X = error code,           *
*           BHA points to a zero-terminated error message.                     *
*           Y preserved                                                        *
********************************************************************************
COP_50          ldx     #$0028
                jsr     LFEC7A1
                bcs     LFEC61A
LFEC617         brl     retCopXBHA

LFEC61A         txy
                bne     LFEC617
                ldy     #$0001
                lda     [DPCOP_AH],y
                pha
                plb
                plb
                lda     [DPCOP_AH]
                ldy     #$0040
                cop     COP_44_OPOPN
                bcc     LFEC631
                brl     retCopXBHA

LFEC631         phy
                lda     #$0000
                ldy     #$000a
LFEC638         sta     [DPCOP_AH],y
                dey
                dey
                cpy     #$0004
                bcs     LFEC638
                ply
                tsx
                pea     $0000
                pea     $0000
                tsc
                phx
                inc     A
                pea     $0000
                plb
                plb
                cop     COP_57_OPRLL
                bcc     LFEC662

                phk
                per     LFEC65C-1
                brl     retCopXBHA

                .rwid   shortm,shortx
LFEC65C         cop     COP_45_OPCLS
                plx
                txs
                sec
                rtl

                .rwid   longm,longx
LFEC662         cop     COP_45_OPCLS
                pla
                pla
                plx
                clc
                brl     retCopXBHA

********************************************************************************
* COP 51 - OPWLE - write load address and execute address of file              *
*                                                                              *
* Action: Writes new load and execute addresses to a file.                     *
*                                                                              *
* On entry: BHA points to a control block of the following fonn.               *
*           Offset                                                             *
*           +0   Pointer to name of file (low byte first)                      *
*           +4   File LOAD address (low byte first)                            *
*           +8   File EXEC address (low byte first)                            *
* On exit:  If C = 0 then the file has been updated.                           *
*           If C = 1 then the update was unsuccessful. X = error code,         *
*           BHA points to a zero terminated error message.                     *
*           Y preserved                                                        *
********************************************************************************
COP_51          ldx     #$002a
                bra     LFEC69D

********************************************************************************
* COP 52 - OPRAT - read attributes                                             *
*                                                                              *
* Action: Reads the 4-byte file attributes.                                    *
*                                                                              *
* On entry: BHA points to a control block of the following form.               *
*           Offset                                                             *
*           +0   Pointer to name of file (low byte first)                      *
*           +4   File attributes (low byte first)                              *
*                                                                              *
* The attributes have the following meanings:                                  *
* low byte   bit 0     0 not readable by owner                                 *
*                      1 readable by owner                                     *
*            bit 1     0 not writable by owner                                 *
*                      1 writable by owner                                     *
*            bit 2     undefined                                               *
*            bit 3     0 not locked                                            *
*                      1 locked                                                *
*            bit 4     0 not readable by public                                *
*                      1 readable by public                                    *
*            bit 5     0 not writable by public                                *
*                      1 writable by public                                    *
*            bit 6     undefined                                               *
*            bit 7     undefined                                               *
* low middle byte      days                                                    *
* high middle byte                                                             *
*            bits 0..3 months                                                  *
*            bits 4..7 years since 1981                                        *
* high byte            undefined                                               *
* On exit:   If C = 0 and X = l then a file was found and the attributes were  *
*            read successfully.                                                *
*            If C = 0 and X = 2 then a directory was found and the attributes  *
*            were read successfully.                                           *
*            If C = 1 then the call was unsuccessful, X = enor code, BHA       *
* points                                                                       *
*            to a zero-terminated error message.                               *
*            Y preserved                                                       *
********************************************************************************
COP_52          ldx     #$002c
                bra     LFEC69D

********************************************************************************
* COP 53 - OPWAT - write file attributes                                       *
*                                                                              *
* Action: Writes the 4-byte file attributes                                    *
*                                                                              *
* For parameters see OPRAT above                                               *
********************************************************************************
COP_53          ldx     #$002e
                bra     LFEC69D

********************************************************************************
* COP 54 - OPRSP - read sequential pointer                                     *
*                                                                              *
* Action: Reads the sequential pointer the position within a file at which the *
* next read/write operation will occur.                                        *
*                                                                              *
* On entry: Y = handle                                                         *
*           BHA points to a control block of the following form.               *
*           Offset                                                             *
*           +0   Sequence number or logical length (low byte first)            *
*                                                                              *
* On exit:  If C = 0 then the sequential pointer was read successfully into    *
*           the control block.                                                 *
*           If C = 1 then the call was unsuccessful, X = error code, BHA       *
* points                                                                       *
*           to a zero-terminated error message.                                *
*           Y preserved                                                        *
********************************************************************************
COP_54          ldx     #$0030
                bra     LFEC6A3

********************************************************************************
* COP 55 - write sequential pointer                                            *
*                                                                              *
* Action: Writes a new value to the sequential pointer - the position within a *
* file at which the next read/write operation will occur.                      *
*                                                                              *
* Parameters are as for COP 54 OPRSP                                           *
********************************************************************************
COP_55          ldx     #$0032
                bra     LFEC6A3

********************************************************************************
* COP 56 - OPRPL - read physical length                                        *
*                                                                              *
* Action: Reads the physical length of a file, ie the actual length stored on  *
* the media.                                                                   *
*                                                                              *
* On entry: BHA points to a contnd block of the following form.                *
*           Offset                                                             *
*           +0   Pointer to name of file (low byte first)                      *
*           +4   length (low byte first)                                       *
* On exit:  If C = 0 then the physical length was read successfully into the   *
*           control block.                                                     *
*           If C = 1 then the call was unsuccessful. X = error code, BHA       *
* points                                                                       *
*           to a zero-teiminaied error message.                                *
*           Y preserved                                                        *
********************************************************************************
COP_56          ldx     #$0034
                bra     LFEC6A3

********************************************************************************
* COP 57 - OPRLL - read logical length                                         *
* Action: Reads the logical length (extent) ot a file.                         *
* On entry: Y = handle                                                         *
*           BHA points to a control block of the following form.               *
*           Offset                                                             *
*           +0  Sequence number or length (low byte first)                     *
* On exit:  If C = 0 then the logical length was read successfully into the    *
*           control block.                                                     *
*           If C = 1 then the call was unsuccessful, X = error code, BHA       *
* points                                                                       *
*           to a zero-terminated error message.                                *
*           Y preserved                                                        *
********************************************************************************
COP_57          ldx     #$0036
                bra     LFEC6A3

********************************************************************************
* COP 58 - OPWLL - write logical length                                        *
*                                                                              *
* Action: Writes the logical length (extent) of a file.                        *
*                                                                              *
* On entry: Y = handle                                                         *
*           BHA points to a control block of the following form.               *
*           Offset                                                             *
*           +0   Sequence number or length (low byte first)                    *
* On exit: If C = 0 then the logical length was written successfully.          *
*          If C = 1 then the call was unsuccessful. X = error code, BHA points *
*                                                                              *
*          to a zero-tenninated error message.                                 *
*          Y preserved                                                         *
********************************************************************************
COP_58          ldx     #$0038
                bra     LFEC6A3

********************************************************************************
* COP 50 - OPRCH - read catalogue header and information                       *
*                                                                              *
* Action: Given the pathname, which may contain wildcards, this call will give *
* the full directory name and information about that directory.                *
*                                                                              *
* On entry: BHA points to a control block of the following form.               *
*           Offset                                                             *
*           +0   Pointer to name of directory (low byte first)                 *
*           +4   Pointer to 49 byte long buffer area (low byte first)          *
*                                                                              *
* On exit:  If C = 0, the 49 byte buffer area specified in the control block   *
*           returns with the following information.                            *
*           BHA undefined                                                      *
*           Buffer contents after call:                                        *
*           Offset                                                             *
*           +0      0 = owner. &FF = public                                    *
*           +1      Cycle number                                               *
*           +2      Boot option                                                *
*           +3..12  Directory name (without wildcards), left-justified padded  *
*                   with spaces                                                *
*           13..28  CSD disc name, same format (used to be last)               *
*           29..38  CSD name, same format                                      *
*           39..48  LIB name, same format                                      *
*                                                                              *
*           If C = 1 then directory not found, X = error code, BHA points to   *
*           zero-terminated error message.                                     *
*           Y preserved                                                        *
*                                                                              *
********************************************************************************
COP_59          ldx     #$003a
                bra     LFEC69D

********************************************************************************
* COP 5A - OPRFN - Read file (object) names from directory                     *
*                                                                              *
* Action: Given the pathname, which may contain wildcards, this call will read *
* the number and names of entries in the specified directory. The information  *
* is put in an area of memory whose start address is supplied. Each name is    *
* terminated by rero (&00).                                                    *
*                                                                              *
* On entry: BHA points to a control block of the following form.               *
*           Offset                                                             *
*           +0   Pointer to name of directory (low byte first)                 *
*           +4   Pointer to start of memory area (low byte first)              *
*           +8   Type of info wanted                                           *
*           +10  Number of names                                               *
*           +12  Filing system work space (16 bytes)                           *
*           (Initially the whole area should be zero)                          *
*                                                                              *
*           The type of info values are:                                       *
*           0 for name only (maximum 16 bytes per name) ,                      *
*           1 for short information (maximum 20 bytes per entry)               *
*           2 for full information (maximum 80 bytes per entry)                *
*                                                                              *
*           The actual content of these results is filing system dependent     *
*           The number of names is a parameter which can be set so the call    *
*           will read up to that number of entries. If there are any remaining *
*                                                                              *
*           then the call can be used again, without disturbing the control    *
*           block, to carry on from where it left off. For the first call      *
*           however, the workspace should be zeroed.                           *
* On exit:  If C = 0 then X = the number of names read, and the names and      *
*           info are in memory separated by zeros.                             *
*           If C = 1 then directory not found, X = error code, BHA points to   *
*           zero-terminated error message.                                     *
*           Y preserved                                                        *
********************************************************************************
COP_5A          ldx     #$003c
                bra     LFEC69D

LFEC69D         jsr     LFEC7A1
                brl     retCopXBHA

LFEC6A3         phk
                jsr     callDevHandle
                brl     retCopXBHA

LFEC6AA         pla
                sta     DPCOP_X
                tsx
LFEC6AE         lda     [DPCOP_AH],y
                pha
                dey
                dey
                bpl     LFEC6AE
                phx
                tsx
                lda     DPCOP_X
                pha
                txa
                tcd
                rts

LFEC6BD         ply
                plx
                pld
                stx     DPCOP_X
                sta     DPCOP_AH
                sep     #$30
                .rwid   shortm,shortx
                phb
                pla
                sta     DPCOP_B
                bcs     LFEC6CF
                plp
                clc
                rtl

LFEC6CF         plp
                sec
                rtl

********************************************************************************
* COP 5C - OPREN - rename an object                                            *
*                                                                              *
* Action: Will attempt to rename an object (file or directory).                *
*                                                                              *
* On entry: BHA points to a control block of the following form.               *
*           Offset                                                             *
*           +0   Pointer to old filename (low byte first)                      *
*           +4   Pointer to new filename (low byte first)                      *
* On exit:  If C = 0 then the object has been renamed.                         *
*           If C = I then object not found or not renamed. X = error code, BHA *
*                                                                              *
*           points to zero terminated error message.                           *
*           Y preserved                                                        *
********************************************************************************
                .rwid   longm,longx
COP_5C          phd
                phd
                phd
                phd
                phd
                tsx
                phx
                pld
                phk
                jsr     LFEF7D8
                phk
                jsr     LFEF828
                bcs     @badfilename
                pha
                tya
                and     #$0020
                beq     @plaerrBadFilename
                pla
                sta     DPCOP_Y
                phb
                phb
                ply
                sty     DPCOP_X
                stx     DPCOP_AH
                phk
                jsr     LFEF804
                phk
                jsr     LFEF828
                bcs     @badfilename
                bvc     LFEC703
                ldx     DPCOP_AH
LFEC703         pha
                tya
                and     #$0020
                beq     @plaerrBadFilename
                pla
                cpx     DPCOP_AH
                bne     @badfilename
                sta     DPCOP_AH
                phb
                phb
                pla
                sta     DPCOP_B
                lda     #$0001
                cop     COP_24_OPCVD
                txy
                ldx     #$0040
                phk
                jsr     LFEC80B
                bra     LFEC739

@plaerrBadFilename pla
@badfilename    cop     COP_26_OPBHA
                .zstr   “Bad filename”
                ldx     #$0001
                sec
LFEC739         pld
                pld
                pld
                pld
                pld
                brl     retCopXBHA

********************************************************************************
* COP 5B - OPDEL - delete anamed object                                        *
*                                                                              *
* Action: This call will attempt to delete a named object (ie a file or a      *
* directory) from a directory.                                                 *
*                                                                              *
* On entry: BHA points to the object name.                                     *
* On exit: If C = 0 then the object was deleted.                               *
*          If C = 1 then object not found or not deleted, X = error code.      *
*          BHA points to zero terminated error message.                        *
*          Y preserved                                                         *
********************************************************************************
COP_5B          phk
                jsr     LFEF7D8
                phk
                jsr     LFEF828
                bcs     LFEC75E
                pha
                tya
                and     #$0020
                beq     LFEC75D
                pla
                txy
                ldx     #$003e
                phk
                jsr     LFEC80B
                bra     LFEC761

LFEC75D         pla
LFEC75E         jsr     cop26BadNameX1
LFEC761         brl     retCopXBHA

LFEC764         phk
                jsr     LFEF7D8
                phk
                jsr     LFEF828
                bcc     LFEC780
                cop     COP_26_OPBHA
                .zstr   “Bad prefix”
                ldx     #$0001
                sec
                rts

LFEC780         txy
                ldx     #$0042
                phk
                jsr     LFEC80B
                bcc     LFEC7A0
                pha
                txa
                lsr     A
                pla
                bcs     LFEC7A0
                inx
                cop     COP_26_OPBHA
                .zstr   “Bad command”
                sec
LFEC7A0         rts

LFEC7A1         ldy     #$0001
                lda     [DPCOP_AH],y
                pha
                plb
                plb
                ldy     #$0000
                lda     [DPCOP_AH],y
                phb
                phb
                pha
                phx
                jsr     LFEC7E4
                txy
                plx
                bcs     LFEC7DF
                phy
                ldy     #$0000
                sta     [DPCOP_AH],y
                ldy     #$0002
                phb
                phb
                pla
                sta     [DPCOP_AH],y
                ply
                pei     (DPCOP_AH+1)
                plb
                plb
                lda     DPCOP_AH
                phk
                jsr     LFEC80B
                tay
                pla
                sta     [DPCOP_AH]
                pla
                phy
                ldy     #$0002
                sta     [DPCOP_AH],y
                pla
                rts

LFEC7DF         pla
                pla
                brl     cop26BadNameX1

LFEC7E4         phk
                jsr     LFEF828
                rts

callDevHandle   jsr     LFEC828
                bcs     LFEC80A
                phd
                phb
                phb
                pha
                phk
                per     LFEC806
                pea     $0000
                plb
                lda     $0003,y
                dec     A
                pha
                lda     $09,S
                pha
                plb
                plb
                lda     $07,S
LFEC806         rtl

                .dd1    $2b
                .dd1    $2b
                .dd1    $2b

LFEC80A         rtl

LFEC80B         phd
                phb
                phb
                pha
                phk
                per     LFEC823
                pea     $0000
                plb
                dey
                phy
                lda     $09,S
                pha
                plb
                plb
                lda     $07,S
                ldy     #$0000
LFEC823         rtl

                .dd1    $2b
                .dd1    $2b
                .dd1    $2b
                .dd1    $6b

LFEC828         pha
                phx
                cpy     #$0100
                bcc     LFEC842
                tyx
                ldal    f:DPCOP_PC,x
                and     #$00ff
                eor     #$0010
                cmp     #$0001
                bcs     LFEC842
                plx
                pla
                rts

LFEC842         plx
                plx
                cop     COP_26_OPBHA
                .zstr   “Not a handle”
                ldx     #$0001
                sec
                rts

                pha
                xba
                per     LFEC860-1
                brl     LFEC86A

LFEC860         lda     $01,S
                per     LFEC868-1
                brl     LFEC86A

LFEC868         pla
                rts

LFEC86A         and     #$00ff
                pha
                lsr     A
                lsr     A
                lsr     A
                lsr     A
                per     LFEC878-1
                brl     LFEC879

LFEC878         pla
LFEC879         and     #$000f
                sed
                cmp     #$000a
                adc     #$0030
                cld
                cop     COP_00_OPWRC
                rts

cop26BadNameX1  cop     COP_26_OPBHA
                .zstr   “Bad name”
                bra     retX1

cop26BadModuleX1 cop    COP_26_OPBHA
                .zstr   “Bad module”
                bra     retX1

cop26BadHandleX1 cop    COP_26_OPBHA
                .zstr   “Bad handle”
retX1           ldx     #$0001
                sec
                rts

********************************************************************************
* COP 3C - OPDTD - QRY                                                         *
********************************************************************************
COP_3C          ldx     DPCOP_X
                phd
                pei     (DPCOP_DP)
                pld
                per     LFEC8C1-1
                brl     LFEC8D1

LFEC8C1         pld
                sta     DPCOP_AH
                stx     DPCOP_X
                sty     DPCOP_Y
                sep     #$30
                .rwid   shortm,shortx
                phb
                pla
                sta     DPCOP_B
                rep     #$30
                .rwid   longm,longx
                rtl

LFEC8D1         php
                sep     #$30
                .rwid   shortm,shortx
                cpx     #$00
                bne     LFEC8E4
                sta     $88
                sec
                ror     DPCOP_Y
                stz     DPCOP_Y+1
                stz     $00
                brl     LFECACB

LFEC8E4         cpx     #$02
                beq     LFEC903
                cpx     #$04
                bne     LFEC8F7
                per     LFEC8EF+2
LFEC8EF         brl     LFECB72

                .dd1    $b0
                .dd1    $23
                .dd1    $82
                .dd1    $d4
                .dd1    $01

LFEC8F7         cpx     #$06
                bne     LFEC917
                per     LFEC8FE+2
LFEC8FE         brl     LFECB84

                .dd1    $80
                .dd1    $ef

LFEC903         sta     DPCOP_X
                xba
                sta     DPCOP_X+1
                phb
                pla
                sta     DPCOP_AH
                tya
                ldx     $00
                bpl     LFEC91A
LFEC911         cmp     #$20
                bcs     LFEC917
                stz     $00
LFEC917         plp
                .rwid   longm,longx
                sec
                rts

                .rwid   shortm,shortx
LFEC91A         sta     $10,x
                cpx     #$01
                bcc     LFEC975
                bne     LFEC959
                rep     #$10
                .rwid   longx
                ldy     #$0000
LFEC927         sep     #$20
                lda     [DPCOP_X],y
                beq     LFEC983
                cmp     $10
                beq     LFEC93B
                rep     #$30
                .rwid   longm
                tya
                clc
                adc     #$000a
                tay
                bra     LFEC927

                .rwid   shortm
LFEC93B         ldx     #$0000
LFEC93E         iny
                lda     [DPCOP_X],y
                sta     DPCOP_B,x
                inx
                cpx     #$0009
                bcc     LFEC93E
                sep     #$30
                .rwid   shortx
                lda     $88
                beq     LFEC959
                lda     DPCOP_B
                cmp     #$86
                beq     LFEC959
                cmp     #$87
                bne     LFEC983
LFEC959         ldx     $00
                lda     $10,x
                bit     DPCOP_B
                bmi     LFEC975
                cmp     #$3f
                beq     LFEC98A
                cmp     #$25
                beq     LFEC98A
                cmp     #$21
                beq     LFEC98A
                cmp     #$5b
                bcs     LFEC975
                cmp     #$40
                bcs     LFEC98A
LFEC975         cmp     #$20
                bcc     LFEC98C
                inc     $00
                lda     $00
                cmp     #$20
                lda     $10,x
                bcc     LFEC9E6
LFEC983         sep     #$30
                sec
                ror     $00
                bra     LFEC911

LFEC98A         sta     $10
LFEC98C         lda     #$00
                adc     #$00
                sta     $00
                stz     $10,x
                txa
                beq     LFEC9E6
                stz     DPCOP_Y+1
                lda     DPCOP_B
                cmp     #$00
                bne     LFEC9A2
                brl     LFECAC7

LFEC9A2         cmp     #$01
                bne     LFEC9A9
                brl     LFECA77

LFEC9A9         cmp     #$02
                beq     LFECA11
                cmp     #$83
                beq     LFEC9E9
                cmp     #$90
                bne     LFEC9B8
                brl     LFECACE

LFEC9B8         cmp     #$85
                bne     LFEC9BF
                brl     LFECA63

LFEC9BF         cmp     #$86
                bne     LFEC9C6
                brl     LFECB2E

LFEC9C6         cmp     #$87
                bne     LFEC9CD
                brl     LFECB32

LFEC9CD         cop     COP_0F_OPERR
                .zstr   “Bad DTD parameter type”
LFEC9E6         brl     LFEC917

LFEC9E9         rep     #$30
                .rwid   longm,longx
                per     LFEC9F1-1
                brl     LFECAF0

LFEC9F1         ldx     #$0080
                ldy     #$0006
                cop     COP_18_OPRLH
                bcs     LFEC9E6
                ldx     $0e
                beq     LFECA07
                lda     $81
                sta     DPCOP_Y,x
                lda     $80
                sta     $00,x
LFECA07         lda     $81
                pha
                plb
                plb
                lda     $80
                brl     LFECAC7

                .rwid   shortm,shortx
LFECA11         rep     #$30
                .rwid   longm,longx
                stz     $80
                ldx     #$0001
                stx     $82
LFECA1A         lda     $10,x
                and     #$00ff
                inx
                cmp     #$0020
                beq     LFECA1A
                dex
LFECA26         lda     $10,x
                and     #$00ff
                beq     LFECA55
                sec
                sbc     #$0030
                cmp     #$000a
                bcs     LFEC9E6
                ldy     $80
                cpy     #$1999
                bcc     LFECA44
                bne     LFEC9E6
                cmp     #$0006
                bcs     LFEC9E6
LFECA44         pha
                tya
                asl     A
                asl     A
                adc     $80
                asl     A
                adc     $01,S
                sta     $80
                pla
                inx
                stz     $82
                bra     LFECA26

LFECA55         lda     $82
                bne     LFEC9E6
                lda     $80
                ldx     $0e
                beq     LFECA61
                sta     $00,x
LFECA61         bra     LFECAC7

                .rwid   shortm,shortx
LFECA63         rep     #$30
                .rwid   longm,longx
                clv
                per     LFECA6C-1
                brl     LFECAFC

                .rwid   shortm,shortx
LFECA6C         bcs     LFECA77
                per     LFECA74-1
                brl     LFECB93

LFECA74         brl     LFEC917

LFECA77         sep     #$30
                clc
                lda     DPCOP_X
                adc     DPCOP_P
                sta     $80
                lda     DPCOP_X+1
                adc     DPCOP_PC
                sta     $81
                lda     DPCOP_AH
                sta     $82
                lda     [$80]
                tay
                inc     $80
                bne     LFECA97
                inc     $81
                bne     LFECA97
                inc     $82
LFECA97         phd
                clc
                pla
                adc     #$11
                sta     $84
                pla
                adc     #$00
                sta     $85
                stz     $86
                ldx     #$80
                cop     COP_36_OPNLU
                bcc     LFECAAE
                brl     LFEC9E6

LFECAAE         lda     DPCOP_B
                cmp     #$85
                bne     LFECABC
                lda     $11
                per     LFECABC-1
                brl     LFECB84

LFECABC         tya
                rep     #$10
                .rwid   longx
                ldx     $0e
                beq     LFECAC5
                sta     $00,x
LFECAC5         sep     #$10
                .rwid   shortx
LFECAC7         rep     #$30
                .rwid   longm,longx
                ldx     DPCOP_DP
                .rwid   shortm,shortx
LFECACB         plp
                clc
                rts

LFECACE         sep     #$30
                rep     #$10
                .rwid   longx
                ldy     $0e
                beq     LFECAE6
                ldx     #$0001
LFECAD9         lda     $10,x
                phx
                tyx
                sta     $00,x
                plx
                inx
                iny
                cmp     #$00
                bne     LFECAD9
LFECAE6         rep     #$30
                .rwid   longm
                per     LFECAEB+2
LFECAEB         brl     LFECAF0

                .dd1    $80
                .dd1    $d7

LFECAF0         pea     $0000
                plb
                plb
                phd
                pla
                clc
                adc     #$0011
                rts

LFECAFC         sep     #$30
                .rwid   shortm,shortx
                ldy     #$00
LFECB00         lda     [DPCOP_X],y
                sec
                beq     LFECB20
                phy
                cmp     $11
                bne     LFECB23
                bvs     LFECB19
                php
                tya
                clc
                adc     #$08
                tay
                plp
                rep     #$30
                .rwid   longm,longx
                lda     [DPCOP_X],y
                beq     LFECB23
                .rwid   shortm,shortx
LFECB19         sep     #$10
                ply
                rep     #$30
                .rwid   longm,longx
                tax
                clc
                .rwid   shortm,shortx
LFECB20         rep     #$30
                .rwid   longm,longx
                rts

                .rwid   shortm,shortx
LFECB23         sep     #$30
                pla
                php
                clc
                adc     #$0a
                plp
                tay
                bra     LFECB00

LFECB2E         lda     #$06
                bra     LFECB34

LFECB32         lda     #$04
LFECB34         sta     DPCOP_AH+1
                sep     #$40
                rep     #$30
                .rwid   longm,longx
                per     LFECB40-1
                brl     LFECAFC

                .rwid   shortm,shortx
LFECB40         sep     #$30
                bcs     LFECB6F
                lda     [DPCOP_X],y
                per     LFECB4C-1
                brl     LFECB84

LFECB4C         tya
                clc
                adc     DPCOP_AH+1
                tay
                rep     #$30
                .rwid   longm,longx
                lda     [DPCOP_X],y
                clc
                adc     DPCOP_X
                sta     $80
                sep     #$30
                .rwid   shortm,shortx
                lda     DPCOP_AH
                sta     $82
                ldy     #$00
LFECB62         lda     [$80],y
                beq     LFECB6F
                per     LFECB6C-1
                brl     LFECB84

LFECB6C         iny
                bra     LFECB62

LFECB6F         brl     LFEC917

LFECB72         lda     #$00
                ldx     DPCOP_Y
                sec
                bmi     LFECB83
                inc     DPCOP_Y
                lda     $30,x
                bne     LFECB82
                sec
                ror     DPCOP_Y
LFECB82         clc
LFECB83         rts

LFECB84         stz     DPCOP_Y
                ldx     DPCOP_Y+1
                cpx     #$4f
                bcs     LFECB92
                sta     $30,x
                stz     $31,x
                inc     DPCOP_Y+1
LFECB92         rts

LFECB93         sep     #$20
                lda     [DPCOP_X],y
                sta     $30
                rep     #$30
                .rwid   longm,longx
                phy
                tya
                clc
                adc     #$0001
                tay
                sep     #$20
                .rwid   shortm
                lda     [DPCOP_X],y
                rep     #$30
                .rwid   longm
                ply
                cmp     #$0001
                beq     LFECBC4
                cmp     #$0002
                beq     LFECC07
                cmp     #$0083
                bne     LFECBBB
                brl     LFECC4A

LFECBBB         cmp     #$0090
                bne     LFECBC3
                brl     LFECC98

LFECBC3         rts

LFECBC4         sep     #$20
                .rwid   shortm
                lda     DPCOP_AH
                sta     $82
                rep     #$30
                .rwid   longm
                tya
                clc
                adc     #$0004
                tay
                lda     [DPCOP_X],y
                clc
                adc     DPCOP_X
                sta     $80
                ldy     #$0000
                sep     #$20
                .rwid   shortm
                lda     $00,x
                sep     #$30
                .rwid   shortx
                tax
LFECBE3         lda     [$80],y
                beq     LFECBF0
                iny
                cmp     [$80]
                bne     LFECBE3
                dex
                dex
                bpl     LFECBE3
LFECBF0         ldx     #$01
LFECBF2         lda     [$80],y
                sta     $30,x
                beq     LFECC00
                cmp     [$80]
                beq     LFECC00
                inx
                iny
                bra     LFECBF2

LFECC00         stz     $30,x
                stz     DPCOP_Y
                rep     #$30
                .rwid   longm,longx
                rts

LFECC07         sep     #$20
                .rwid   shortm
                lda     #$01
                sta     DPCOP_Y
                rep     #$30
                .rwid   longm
                lda     $00,x
                per     LFECCAF
                phk
                .dbank  K (auto)
                plb
                ldy     #$0008
LFECC19         ldx     #$00ff
                sec
LFECC1D         inx
                sbc     ($01,S),y
                bcs     LFECC1D
                adc     ($01,S),y
                pha
                sep     #$30
                .rwid   shortm,shortx
                txa
                ldx     DPCOP_Y
                cmp     #$00
                bne     LFECC36
                cpx     #$01
                bne     LFECC36
                cpy     #$00
                bne     LFECC3C
LFECC36         ora     #$30
                sta     $30,x
                inc     DPCOP_Y
LFECC3C         rep     #$30
                .rwid   longm,longx
                pla
                dey
                dey
                bpl     LFECC19
                pla
                sep     #$30
                .rwid   shortm,shortx
                ldx     DPCOP_Y
                bra     LFECC00

                .rwid   longm,longx
LFECC4A         sep     #$30
                .rwid   shortm,shortx
                lda     #$01
                sta     DPCOP_Y
                lda     DPCOP_Y+1,x
                per     LFECC58-1
                brl     LFECC75

LFECC58         lda     DPCOP_Y,x
                per     LFECC60-1
                brl     LFECC75

LFECC60         lda     $00,x
                per     LFECC68-1
                brl     LFECC75

LFECC68         ldx     DPCOP_Y
                cpx     #$01
                bne     LFECC73
                lda     #$30
                sta     $30,x
                inx
LFECC73         bra     LFECC00

LFECC75         pha
                lsr     A
                lsr     A
                lsr     A
                lsr     A
                per     LFECC80-1
                brl     LFECC81

LFECC80         pla
LFECC81         phx
                ldx     DPCOP_Y
                and     #$0f
                bne     LFECC8C
                cpx     #$01
                beq     LFECC96
LFECC8C         sed
                cmp     #$0a
                adc     #$30
                cld
                sta     $30,x
                inc     DPCOP_Y
LFECC96         plx
                rts

                .rwid   longm,longx
LFECC98         sep     #$20
                .rwid   shortm
                ldy     #$0001
LFECC9D         lda     $00,x
                phx
                tyx
                sta     $30,x
                plx
                inx
                iny
                cmp     #$00
                bne     LFECC9D
                stz     DPCOP_Y
                rep     #$30
                .rwid   longm
                rts

LFECCAF         .dd1    $01
                .dd1    $00
                .dd1    $0a
                .dd1    $00
                .dd1    $64
                .dd1    $00
                .dd1    $e8
                .dd1    $03
                .dd1    $10
                .dd1    $27
                .dd1    $6b
                .dd1    $f4
                .dd1    $00
                .dd1    $00
                .dd1    $ab
                .dd1    $ab
                .dd1    $8f
                .dd1    $0d
                .dd1    $00
                .dd1    $42
                .dd1    $a0
                .dd1    $f3
                .dd1    $20
                .dd1    $2e
                .dd1    $e2
                .dd1    $18
                .dd1    $6b
                .dd1    $f4
                .dd1    $00
                .dd1    $00
                .dd1    $ab
                .dd1    $ab
                .dd1    $a2
                .dd1    $12
                .dd1    $4b
                .dd1    $20
                .dd1    $38
                .dd1    $fe
                .dd1    $ad
                .dd1    $51
                .dd1    $a5
                .dd1    $f0
                .dd1    $1f
                .dd1    $ce
                .dd1    $51
                .dd1    $a5
                .dd1    $d0
                .dd1    $1a
                .dd1    $ae
                .dd1    $52
                .dd1    $a5
                .dd1    $ad
                .dd1    $48
                .dd1    $a5
                .dd1    $f0
                .dd1    $03
                .dd1    $ae
                .dd1    $53
                .dd1    $a5
                .dd1    $49
                .dd1    $07
                .dd1    $8d
                .dd1    $48
                .dd1    $a5
                .dd1    $8e
                .dd1    $51
                .dd1    $a5
                .dd1    $a8
                .dd1    $a2
                .dd1    $14
                .dd1    $4b
                .dd1    $20
                .dd1    $38
                .dd1    $fe
                .dd1    $ce
                .dd1    $40
                .dd1    $a5
                .dd1    $a9
                .dd1    $10
                .dd1    $80
                .dd1    $07
                .dd1    $f4
                .dd1    $00
                .dd1    $00
                .dd1    $ab
                .dd1    $ab
                .dd1    $a9
                .dd1    $20
                .dd1    $8f
                .dd1    $05
                .dd1    $fe
                .dd1    $45
                .dd1    $ad
                .dd1    $83
                .dd1    $a5
                .dd1    $aa
                .dd1    $49
                .dd1    $0f
                .dd1    $48
                .dd1    $a8
                .dd1    $38
                .dd1    $bd
                .dd1    $90
                .dd1    $a5
                .dd1    $69
                .dd1    $00
                .dd1    $99
                .dd1    $90
                .dd1    $a5
                .dd1    $ca
                .dd1    $f0
                .dd1    $03
                .dd1    $88
                .dd1    $d0
                .dd1    $f2
                .dd1    $68
                .dd1    $8d
                .dd1    $83
                .dd1    $a5
                .dd1    $a2
                .dd1    $05
                .dd1    $fe
                .dd1    $9a
                .dd1    $a5
                .dd1    $d0
                .dd1    $08
                .dd1    $ca
                .dd1    $d0
                .dd1    $f8
                .dd1    $a0
                .dd1    $05
                .dd1    $20
                .dd1    $73
                .dd1    $e5
                .dd1    $ad
                .dd1    $b0
                .dd1    $a5
                .dd1    $d0
                .dd1    $08
                .dd1    $ad
                .dd1    $b1
                .dd1    $a5
                .dd1    $f0
                .dd1    $06
                .dd1    $ce
                .dd1    $b1
                .dd1    $a5
                .dd1    $ce
                .dd1    $b0
                .dd1    $a5
                .dd1    $2c
                .dd1    $78
                .dd1    $a5
                .dd1    $10
                .dd1    $0b
                .dd1    $ee
                .dd1    $78
                .dd1    $a5
                .dd1    $58
                .dd1    $20
                .dd1    $49
                .dd1    $eb
                .dd1    $78
                .dd1    $ce
                .dd1    $78
                .dd1    $a5
                .dd1    $24
                .dd1    $d3
                .dd1    $30
                .dd1    $08
                .dd1    $a5
                .dd1    $d5
                .dd1    $e6
                .dd1    $d5
                .dd1    $c9
                .dd1    $80
                .dd1    $b0
                .dd1    $1b
                .dd1    $ad
                .dd1    $42
                .dd1    $a5
                .dd1    $f0
                .dd1    $0c
                .dd1    $ee
                .dd1    $42
                .dd1    $a5
                .dd1    $a2
                .dd1    $0c
                .dd1    $22
                .dd1    $ac
                .dd1    $ff
                .dd1    $00
                .dd1    $ce
                .dd1    $42
                .dd1    $a5
                .dd1    $2c
                .dd1    $c6
                .dd1    $a5
                .dd1    $30
                .dd1    $03
                .dd1    $4c
                .dd1    $12
                .dd1    $df
                .dd1    $18
                .dd1    $6b
                .dd1    $a5
                .dd1    $d5
                .dd1    $c9
                .dd1    $82
                .dd1    $f0
                .dd1    $06
                .dd1    $c9
                .dd1    $83
                .dd1    $f0
                .dd1    $0e
                .dd1    $80
                .dd1    $ea
                .dd1    $af
                .dd1    $00
                .dd1    $00
                .dd1    $42
                .dd1    $29
                .dd1    $df
                .dd1    $8f
                .dd1    $00
                .dd1    $00
                .dd1    $42
                .dd1    $80
                .dd1    $f2
                .dd1    $64
                .dd1    $d4
                .dd1    $64
                .dd1    $d5
                .dd1    $af
                .dd1    $0d
                .dd1    $00
                .dd1    $42
                .dd1    $29
                .dd1    $08
                .dd1    $d0
                .dd1    $02
                .dd1    $c6
                .dd1    $d4
                .dd1    $af
                .dd1    $00
                .dd1    $00
                .dd1    $42
                .dd1    $09
                .dd1    $20
                .dd1    $8f
                .dd1    $00
                .dd1    $00
                .dd1    $42
                .dd1    $a9
                .dd1    $08
                .dd1    $8f
                .dd1    $0d
                .dd1    $00
                .dd1    $42
                .dd1    $82
                .dd1    $ac
                .dd1    $ff

                .rwid   shortm,shortx
LFECDB5         php
                rep     #$30
                .rwid   longm,longx
                lda     #$0000
                stal    f:$00fe00
                lda     #$fe00
                stal    f:$00fe02
                lda     #$e000
LFECDC9         pha
                tax
                jsr     LFECDDA
                pla
                clc
                adc     #$000c
                cmp     #$fcf5
                bcc     LFECDC9
                plp
                .rwid   shortm,shortx
                rts

                .rwid   longm,longx
LFECDDA         phy
                php
                sei
                rep     #$30
                txy
                lda     #$0000
                stal    f:$000000,x
                sep     #$20
                .rwid   shortm
                stal    f:$00000b,x
                rep     #$20
                .rwid   longm
                ldal    f:$00fe02
                tax
                tya
                stal    f:$000000,x
                stal    f:$00fe02
                plp
                ply
                clc
                rts

LFECE01         php
                sei
                rep     #$30
                tax
                ldal    f:$00fe00
                bne     @ok
                plp
                sec
                rts

@ok             phx
                tax
                cmpl    f:$00fe02
                bne     LFECE1E
                lda     #$fe00
                stal    f:$00fe02
LFECE1E         ldal    f:$000000,x
                stal    f:$00fe00
                lda     #$ffff
                stal    f:$00000a,x
                stal    f:$000008,x
                stal    f:$000006,x
                stal    f:$000004,x
                stal    f:$000002,x
                stal    f:$000000,x
                pla
                sep     #$20
                .rwid   shortm
                stal    f:$00000b,x
                rep     #$20
                .rwid   longm
                txa
                plp
                clc
                rts

LFECE4E         ldal    f:$00fe00
                beq     LFECE69
                ldy     #$0000
LFECE57         iny
                beq     memFreeListError
                tax
                ldal    f:$000000,x
                bne     LFECE57
                txa
                cmpl    f:$00fe02
                bne     memFreeListError
                rts

LFECE69         ldal    f:$00fe02
                cmp     #$fe00
                bne     memFreeListError
                rts

memFreeListError cop    COP_0F_OPERR
                .zstr   “Memory error: list of free blocks corrupted”
allocHandleQRY  phd
                pha
                pea     EXSYS
                pld
                ldy     #$0000
                lda     [<EXSYS_HANDLEBLOCK_LONGPTR],y ;getHandleBlockSize
                and     #$fffe
                beq     @retsec
                tay
@lp             dey
                dey
                beq     @retsec
                lda     [$02],y
                bne     @lp
                txa
                sta     [$02],y
                pla
                pld
                clc
                rts

@retsec         pla
                pld
                sec
                rts

LFECEC5         jsr     LFECEDA
                pha
                bcs     @sk
                ldal    f:$00000b,x
                and     #$00ff
                eor     #$0002
                cmp     #$0001
@sk             pla
                rts

LFECEDA         phd
                pha
                tya
                beq     @retsec
                bit     #$0001
                bne     @sk
                pea     MM_HANDLE_TAB
                pld
                lda     [DPCOP_Y+1],y
@lp             tax
                beq     @retsec
                cpx     #$ffff
                beq     @retsec
                bne     @retclc

@sk             tyx
                cpx     #$000a
                bcs     @retsec
                phb
                phk
                .dbank  K (auto)
                plb
                lda     0+(LFECF14 & $ffff)-1,x
                plb
                eor     #$0000
                beq     @retsec
                pha
                pld
                lda     $00
                bra     @lp

@retclc         pla
                pld
                clc
                rts

@retsec         pla
                pld
                sec
                rts

LFECF14         .dd1    $04
                .dd1    $fe
                .dd1    $00
                .dd1    $00
                .dd1    $08
                .dd1    $fe
                .dd1    $0a
                .dd1    $fe
                .dd1    $0c
                .dd1    $fe

LFECF1E         phx
                pea     $ff00
                pld
                ldy     #$0000
                lda     [DPCOP_Y+1],y
                tay
                dey
                dey
LFECF2B         lda     [DPCOP_Y+1],y
                cmp     $01,S
                beq     LFECF38
                dey
                dey
                bne     LFECF2B
                plx
                sec
                rts

LFECF38         lda     #$0000
                sta     [DPCOP_Y+1],y
                plx
                clc
                rts

coGetHandleByBlockAddr_QRY pea EXSYS
                pld
                ldy     #$0000
                lda     [$02],y
                tay
                dey
                dey
                txa
@retsec         cmp     [$02],y
                beq     @retclc
                dey
                dey
                bne     @retsec
                sec
                rts

@retclc         clc
                rts

                .rwid   shortm,shortx
LFECF59         php
                phb
                rep     #$30
                .rwid   longm,longx
                pea     $0000
                plb
                .dbank  $00
                plb
                lda     #$0000
                sta     EXSYS_CUR_COROUTINE+1
                sta     SYS_ESCAPE_FLAG_QRY
                lda     #$0010
                stal    f:$00fe20
                lda     #$fe20
                jsr     LFECF9D
                jsr     LFECF7F
                plb
                plp
                .rwid   shortm,shortx
                clc
                rts

                .rwid   longm,longx
LFECF7F         phb
                phd
                pea     $ff00
                pld
                lda     #$0008
                sta     DPCOP_AH
                pea     $0000
                plb
                .dbank  $00
                plb
                stz     DPCOP_X
                lda     #$ff05
                sta     DPCOP_Y+1
                jsr     LFECF9D
                pld
                plb
                clc
                rts

LFECF9D         php
                rep     #$30
                pha
                ldy     #$0000
                lda     ($01,S),y
                tay
                sep     #$20
                .rwid   shortm
                lda     #$00
LFECFAB         dey
                cpy     #$0002
                bcc     LFECFB5
                sta     ($01,S),y
                bra     LFECFAB

LFECFB5         rep     #$20
                .rwid   longm
                pla
                plp
                clc
                rts

********************************************************************************
* ST - SYSTEM?                                                                 *
*                                                                              *
* This well known entry is called as 00/FF88                                   *
********************************************************************************
                .rwid   shortm,shortx
default__ST     php
                rep     #$30
                .rwid   longm,longx
                cpx     #$0022
                bcs     @resec
                phd
                phb
                phk
                .dbank  K (auto)
                plb
                pea     DPSYS
                pld
                sep     #$30
                .rwid   shortm,shortx
                jsr     (tbl__ST_dispatch,x)
                plb
                pld
                bcs     @resec
                plp
                clc
                rtl

@resec          plp
                sec
                rtl

tbl__ST_dispatch .dd2   __ST_0 & $ffff    ;ST 0 - return string "SYSTEM"
                .dd2    __ST_2 & $ffff    ;ST 2 - return B0 FF80 table vector after re-indexing
                .dd2    __ST_4 & $ffff    ;ST 4 - update B0 FF80 table vector after re-indexing
                .dd2    __ST_6 & $ffff    ;ST 6 - return B0 FE80 table vector after re-indexing
                .dd2    __ST_8 & $ffff    ;ST 8 - update B0 FE80 table vector after re-indexing
                .dd2    __ST_A & $ffff    ;ST A - GSINIT with Carry clear - i.e. Space or CR terminates unquoted
                .dd2    __ST_C & $ffff    ;ST C - GSINIT with Carry set - i.e. only CR terminates unquoted
                .dd2    __ST_E & $ffff    ;ST E - gsread update flags from H
                .dd2    syserrUseCoroutines & $ffff ;ST 10 - bad call
                .dd2    syserrUseCoroutines2 & $ffff ;ST 12 - bad call
                .dd2    doSTSBK & $ffff   ;ST 14 - look something up in a table pointed to by 00FF0D,0
                .dd2    doSTTBK & $ffff   ;ST 16 - look something up in a table pointed to by 00FF0D,Y
                .dd2    __ST_18 & $ffff
                .dd2    TFED16D & $ffff
                .dd2    __ST_1C & $ffff
                .dd2    TFED119 & $ffff
                .dd2    TFED108 & $ffff

********************************************************************************
* ST A - GSINIT CC                                                             *
*                                                                              *
* Initialise a GSREAD string, space or CR will terminate an unquoted string    *
********************************************************************************
__ST_A          clc
                bra     _ST_AC_int

********************************************************************************
* ST C - GSINIT CC                                                             *
*                                                                              *
* Initialise a GSREAD string, space or CR will terminate an unquoted string    *
********************************************************************************
__ST_C          sec
_ST_AC_int      sta     <DPSYS_GSREAD_ptr
                xba
                sta     <DPSYS_GSREAD_ptr+1
                lda     $03,S
                sta     <DPSYS_GSREAD_ptr+2
                ror     <DPSYS_GSREAD_flags ;DD gets loaded with top bit set if entered via OP C
                jsr     __ST_skipSpaces
                iny
                cmp     #$22
                beq     @notq
                dey                       ;if first char is not " then back up one
                clc
@notq           ror     <DPSYS_GSREAD_flags
                pha
                lda     <DPSYS_GSREAD_flags
                xba
                pla
                cmp     #$0d
                beq     @ret
                clc
@ret            rts

@lp             iny
__ST_skipSpaces lda     [<DPSYS_GSREAD_ptr],y
                cmp     #$20
                beq     @lp
                cmp     #$0d
                rts

gsread_dec_digit lda    [$ed],y
                cmp     #‘:’
                bcs     gsread_clc_ret
                cmp     #$30
                bcc     gsread_clc_ret
                and     #$0f
                rts

gsread_clc_ret  clc
                rts

gsread_iny_hex_digit iny
gsread_hex_digit jsr    gsread_dec_digit
                bcs     @inyret
                and     #$df
                cmp     #‘G’
                bcs     gsread_clc_ret
                cmp     #‘A’
                bcc     gsread_clc_ret
                php
                sbc     #$37
                plp
@inyret         iny
                rts

********************************************************************************
* __ST E - do a GSREAD                                                         *
*                                                                              *
* QRY - looks to update the flags from passed in H                             *
********************************************************************************
__ST_E          xba
                and     #$fe
                sta     <DPSYS_GSREAD_flags
gsread_read     lda     [<DPSYS_GSREAD_ptr],y
                beq     LFED05E
                cmp     #$0d
                bne     LFED064
LFED05E         bit     <DPSYS_GSREAD_flags
                bmi     brkBadString
                bpl     LFED07F

LFED064         cmp     #$20
                bcc     brkBadString
                bne     LFED070
                bit     <DPSYS_GSREAD_flags
                bmi     LFED0E1
                bvc     LFED07F
LFED070         cmp     #$22
                bne     LFED095
                bit     <DPSYS_GSREAD_flags
                bpl     LFED0E1
                iny
                lda     [<DPSYS_GSREAD_ptr],y
                cmp     #$22
                beq     LFED0E1
LFED07F         jsr     __ST_skipSpaces
                sec
                xba
                lda     <DPSYS_GSREAD_ptr-16
                xba
                rts

brkBadString    brk     $fd

                .zstr   “Bad string”

LFED095         cmp     #‘|’
                bne     LFED0E1
                iny
                lda     [<DPSYS_GSREAD_ptr],y
                cmp     #‘|’
                beq     LFED0E1
                cmp     #‘"’
                beq     LFED0E1
                cmp     #‘&’
                bne     LFED0BE
                jsr     gsread_iny_hex_digit
                bcc     brkBadString
                asl     A
                asl     A
                asl     A
                asl     A
                pha
                jsr     gsread_hex_digit
                bcc     brkBadString
                ora     $01,S
                sta     $01,S
                pla
                bra     LFED0EA

LFED0BE         cmp     #‘!’
                bne     LFED0CB
                iny
                lda     <DPSYS_GSREAD_flags
                ora     #$01
                sta     <DPSYS_GSREAD_flags
                bra     gsread_read

LFED0CB         cmp     #‘ ’
                bcc     brkBadString
                cmp     #‘?’
                beq     LFED0DF
                phx
                ldx     #$14
                jsl     __KB
                plx
                sep     #$40
                bra     LFED0E2

LFED0DF         lda     #$7f
LFED0E1         clv
LFED0E2         iny
                rol     A
                pha
                lda     $dd
                ror     A
                pla
                ror     A
LFED0EA         xba
                lda     $dd
                xba
                clc
                rts

********************************************************************************
* __ST 1C - add Y to GSREAD pointer                                            *
*                                                                              *
* returns updated pointer in BHA but doesn't update stored pointer             *
********************************************************************************
__ST_1C         clc
                tya
                adc     <DPSYS_GSREAD_ptr
                xba
                ldy     <DPSYS_GSREAD_ptr+2
                ldx     <DPSYS_GSREAD_ptr+1
                bcc     @skinc
                inx
                bne     @skinc
                iny
@skinc          tya
                sta     $03,S
                txa
                xba
                clc
                ldy     #$00
                rts

TFED108         ldal    f:EXSYS_0D_BRKADDR_SAVE+2
                sta     $03,S
                ldal    f:EXSYS_0D_BRKADDR_SAVE+1
                xba
                ldal    f:EXSYS_0D_BRKADDR_SAVE
                clc
                rts

TFED119         ldx     #$20
                jsl     __ST
                cop     COP_2D_OPWRM
                bcc     LFED131
                ldy     #$00
                cop     COP_2E_OPFPO
                bcs     LFED12D

                cop     COP_2D_OPWRM
                bcc     LFED131
LFED12D         cop     COP_01_OPWRS
                .zstr   “?”
LFED131         cop     COP_01_OPWRS
                .zstr   “: ”
                rts

syserrUseCoroutines cop COP_0F_OPERR
                .zstr   “use coroutines not STSEN”
syserrUseCoroutines2 cop COP_0F_OPERR
                .zstr   “use coroutines not STREN”
TFED16D         pea     EXSYS
                pld
                rep     #$20
                .rwid   longm
                dec     <EXSYS_0D_BRKADDR_SAVE
                jml     [EXSYS_0D_BRKADDR_SAVE]

                .dd1    $38
                .dd1    $60

********************************************************************************
* STSBK Read the BRK signature                                                 *
*                                                                              *
* Action: This call returns the error number associated with the last BRK      *
* executed.                                                                    *
*                                                                              *
* On Entry:                                                                    *
*    X   STSBK                                                                 *
* Exit:                                                                        *
*    A   Error number of the last error                                        *
*    HY  State to be used in subsequent calls                                  *
*    BD  Preserved                                                             *
*                                                                              *
* Note that HY must be preserved between the STSBK call and subsequent calls   *
* to STTBK                                                                     *
********************************************************************************
                .rwid   shortm
doSTSBK         sep     #$10
                ldy     #$00
                jsr     doSTTBK
                ldy     #$01
                rts

********************************************************************************
* __ST 16 - STTBK - Read BRK message                                           *
*                                                                              *
* Action: This call reiurns the next character in the error message associated *
* with the last BRK executed.                                                  *
*                                                                              *
* Entry:                                                                       *
*    HY  State returned by lastSTSBK or STTBK                                  *
*    X   STTBK                                                                 *
* Exit:                                                                        *
*    B,D Preserved                                                             *
*    C=0 Then next byte was read                                               *
*    A   Next byte in BRK message text                                         *
*    HY  State for next STTBK                                                  *
* or C=1 Last character has been read                                          *
********************************************************************************
doSTTBK         sep     #$10
                pea     EXSYS
                pld
                lda     [<EXSYS_0D_BRKADDR_SAVE],y
                beq     @sec
                iny
                beq     @deysec
                clc
                rts

@deysec         dey
@sec            sec
                rts

********************************************************************************
* __ST op 2                                                                    *
*                                                                              *
* Looks up from 00FF01 table a value and returns in BHA (QRY)                  *
********************************************************************************
__ST_2          php
                sei
                cpy     #$eb
                bcc     __ST_plpretsec    ;if Y < EB then exit fail
                lda     0+(tbl__ST_2_indices & $ffff)-235,y
                beq     __ST_plpretsec
                tax
                pea     $0000
                .dbank  $00
                plb
                plb
                ldal    f:tblB0JumpTableFF80_QRY-127,x
                pha
                ldal    f:tblB0JumpTableFF80_QRY-126,x
                pha
                ldal    f:tblB0JumpTableFF80_QRY-125,x
                pha
__ST_retstackedBHA_clc pla
                sta     $06,S
                pla
                xba
                pla
                plp
                clc
                rts

********************************************************************************
* __ST op 4                                                                    *
*                                                                              *
* updates from BHA 00FF01 table value and returns old in BHA (QRY)             *
********************************************************************************
__ST_4          php
                sei
                cpy     #$eb
                bcc     __ST_plpretsec
                tax
                lda     0+(tbl__ST_2_indices & $ffff)-235,y
                beq     __ST_plpretsec
                pea     $0000
                plb
                plb
                txy
                tax
                ldal    f:tblB0JumpTableFF80_QRY-127,x
                pha
                ldal    f:tblB0JumpTableFF80_QRY-126,x
                pha
                ldal    f:tblB0JumpTableFF80_QRY-125,x
                pha
                tya
                stal    f:tblB0JumpTableFF80_QRY-127,x
                xba
                stal    f:tblB0JumpTableFF80_QRY-126,x
                lda     $07,S
                stal    f:tblB0JumpTableFF80_QRY-125,x
                bra     __ST_retstackedBHA_clc

__ST_plpretsec  plp
                sec
                rts

********************************************************************************
* __ST op 6                                                                    *
*                                                                              *
* Looks up from 00FE01 table a value and returns in BHA (QRY)                  *
********************************************************************************
__ST_6          php
                sei
                cpy     #$eb
                bcc     __ST_plpretsec
                lda     0+(tbl__ST_2_indices & $ffff)-235,y
                beq     __ST_plpretsec
                tax
                pea     $0000
                plb
                plb
                ldal    f:tblB0JumpTableFE80_QRY-127,x
                pha
                ldal    f:tblB0JumpTableFE80_QRY-126,x
                pha
                ldal    f:tblB0JumpTableFE80_QRY-125,x
                pha
bra__ST_retstackedBHA_clc bra __ST_retstackedBHA_clc

********************************************************************************
* __ST op 8                                                                    *
*                                                                              *
* updates from BHA 00FE01 table value and returns old in BHA (QRY)             *
********************************************************************************
__ST_8          php
                sep     #$30
                sei
                cpy     #$eb
                bcc     __ST_plpretsec
                tax
                lda     0+(tbl__ST_2_indices & $ffff)-235,y
                beq     __ST_plpretsec
                pea     $0000
                plb
                plb
                txy
                tax
                ldal    f:tblB0JumpTableFE80_QRY-127,x
                pha
                ldal    f:tblB0JumpTableFE80_QRY-126,x
                pha
                ldal    f:tblB0JumpTableFE80_QRY-125,x
                pha
                tya
                stal    f:tblB0JumpTableFE80_QRY-127,x
                xba
                stal    f:tblB0JumpTableFE80_QRY-126,x
                lda     $07,S
                stal    f:tblB0JumpTableFE80_QRY-125,x
                bra     bra__ST_retstackedBHA_clc

; This looks to point at a set of offsets into tables in the system area at
; 00FE00
tbl__ST_2_indices .dd1  $00
                .dd1    $b0
                .dd1    $ac
                .dd1    $a8
                .dd1    $a4
                .dd1    $a0
                .dd1    $9c
                .dd1    $98
                .dd1    $94
                .dd1    $e4
                .dd1    $e8
                .dd1    $ec
                .dd1    $f0
                .dd1    $f8
                .dd1    $f4
                .dd1    $fc
                .dd1    $90
                .dd1    $8c
                .dd1    $88
                .dd1    $84
                .dd1    $00
__ST_18         php
                sei
                rep     #$30
                .rwid   longm,longx
                cpy     #$00eb
                bcc     @retsec
                tax
                lda     0+(tbl__ST_2_indices & $ffff)-235,y
                and     #$00ff
                beq     @retsec
                clc
                adc     #$fe00
                tax
                lda     $05,S
                jsr     LFEB3B3
                plp
                .rwid   shortm,shortx
                clc
                rts

                .rwid   longm,longx
@retsec         plp
                .rwid   shortm,shortx
                sec
                rts

********************************************************************************
* MM - Memory management entry point                                           *
********************************************************************************
default__MM     php
                rep     #$30
                .rwid   longm,longx
                cpx     #$001c
                bcs     @resetc
                phd
                phb
                jsr     (tblMMdispatch,x)
                plb
                pld
                bcs     @resetc
                plp
                .rwid   shortm,shortx
                clc
                rtl

                .rwid   longm,longx
@resetc         plp
                .rwid   shortm,shortx
                sec
                rtl

tblMMdispatch   .dd2    __ST_0 & $ffff    ;0 - __MMNXT - return string "SYSTEM"?
                .dd2    doMMINIT & $ffff  ;2 - __MMINIT - initialise memory management routines
                .dd2    doMMBP & $ffff    ;4 - __MMBP - ???
                .dd2    doMMASD & $ffff   ;6 - __MMASD - allocate small descending area
                .dd2    doMMALD & $ffff   ;8 - __MMALD - allocate large descending
                .dd2    doMMASA & $ffff   ;A - __MMASA - allocate a small ascending
                .dd2    doMMALA & $ffff   ;C - __MMALA - allocate large asending
                .dd2    doMMBAS & $ffff   ;E - __MMBAS - get base of pool
                .dd2    doMMLEN & $ffff   ;10 - __MMLEN - return pool length
                .dd2    doMMTOP & $ffff   ;12 - __MMTOP - return top of pool
                .dd2    doMMFND & $ffff   ;14 - __MMFND - find a pool by address
                .dd2    doMMCHK & $ffff   ;16 - __MMCHK - check integrity of memory system
                .dd2    doMMAZB & $ffff   ;18 - __MMAZB - Allocate Bank 0
                .dd2    doMMMRG & $ffff   ;1A - __MMMRG - merge two pools

LFED2B8         php
                phd
                phb
                rep     #$30
                .rwid   longm,longx
                jsr     LFED2FF
                bcs     LFED2FA
                jsr     LFED324
                bcs     LFED2FA
                jsr     LFED336
                bcs     LFED2FA
                lda     #$2000
                ldx     #$0018
                jsl     __MM
                bcs     LFED2FA
                ldx     #$000e
                jsl     __MM
                lda     #$a500
                pea     $0900
                pld
                ldy     #$0001
                ldx     #$0004
                jsl     __MM
                bcs     LFED2FA
                jsr     LFECF7F
                plb
                pld
                plp
                .rwid   shortm,shortx
                clc
                rts

                .rwid   longm,longx
LFED2FA         plb
                pld
                plp
                .rwid   shortm,shortx
                sec
                rts

                .rwid   longm,longx
LFED2FF         lda     #$0002
                jsr     LFECE01
                bcs     LFED323
                tax
                jsr     LFED6D7
                txa
                jsr     LFED6D2
                lda     #$0000
                stal    f:DPCOP_X+1,x
                lda     #$ffff
                stal    f:DPCOP_AH+1,x
                txa
                stal    f:$00fe0a
                clc
LFED323         rts

LFED324         ldal    f:$00fe0a
                tax
                jsr     LFED374
                jsr     LFED5DE
                txa
                stal    f:$00fe04
                clc
                rts

LFED336         pea     $4600
                plb
                plb
                lda     #$0000
                pea     $8000
                pld
                ldy     #$0007
                ldx     #$0004
                jsl     __MM
                jsr     LFECEC5
                txa
                stal    f:$00fe08
                rts

********************************************************************************
* TODO: check - the following block looks like it may be dead code?            *
********************************************************************************
                pea     HW_VIDEO_BASE >> 8 ;TODO: shift!
                plb
                plb
                lda     #HW_VIDEO_BASE & $ffff
                pea     HW_EXTIO >> 8
                pld
                ldy     #HDMMW
                ldx     #__MMBP
                jsl     __MM
                jsr     LFECEC5
                txa
                stal    f:DP_HANDLE_VIDEO_QRY
                rts

LFED374         php
                phd
                sei
                phd
                phd
                phd
                tsc
                tcd
                inc     A
                sta     DPCOP_X
                lda     #$0009
                sta     DPCOP_AH
LFED384         dec     DPCOP_AH
                beq     LFED3AE
                jsr     LFED3B5
                bcc     LFED384
                lda     DPCOP_AH
                inc     A
                pha
LFED391         dec     DPCOP_AH
                beq     LFED39C
                jsr     LFED3B5
                bcs     LFED391
                dec     DPCOP_AH
LFED39C         inc     DPCOP_AH
                lda     DPCOP_AH
                xba
                tay
                pla
                sec
                sbc     DPCOP_AH
                xba
                pld
                pld
                pld
                pld
                plp
                clc
                rts

LFED3AE         pld
                pld
                pld
                pld
                plp
                sec
                rts

LFED3B5         lda     [DPCOP_X]
                pha
                eor     #$ffff
                sta     [DPCOP_X]
                eor     [DPCOP_X]
                bne     LFED3E8
                dec     DPCOP_AH
                lda     [DPCOP_X]
                pha
                eor     #$ffff
                sta     [DPCOP_X]
                eor     [DPCOP_X]
                php
                inc     DPCOP_AH
                plp
                bne     LFED3E7
                pla
                pha
                sta     [DPCOP_X]
                dec     DPCOP_AH
                eor     [DPCOP_X]
                cmp     #$ffff
                pla
                sta     [DPCOP_X]
                inc     DPCOP_AH
                pla
                sta     [DPCOP_X]
                rts

LFED3E7         pla
LFED3E8         pla
                clc
                rts

********************************************************************************
* __MM 8 - MMALD - allocate large descending                                   *
*                                                                              *
* This call allocates a region of memory from a specified pool. The region is  *
* taken from the upper region of the pool.                                     *
*                                                                              *
* Entry:                                                                       *
*    Y    Handle of memory pool                                                *
*    BHA  Number of bytes to allocate                                          *
*    X    MMALD                                                                *
* Exit:                                                                        *
*    C=0  Pool allocated successfully                                          *
*    Y    Handle of newly allocated pool                                       *
*    BHA  Base address of newly allocated pod                                  *
* or C=1 Failed to allocate new pool                                           *
*    B,D Preserved                                                             *
********************************************************************************
doMMALD         clv
                bra     mmAllocLarge

********************************************************************************
* __MM A - MMALA - allocate large ascending                                    *
*                                                                              *
* This call allocates a region of memory from a specified pool. The region is  *
* taken from the lower region of the pool.                                     *
*                                                                              *
* Entry:                                                                       *
*    Y    Handle of memory pool                                                *
*    BHA  Number of bytes to allocate                                          *
*    X    MMALA                                                                *
* Exit:                                                                        *
*    C=0  Pool allocated successfully                                          *
*    Y    Handle of newly allocated pool                                       *
*    BHA  Base address of newly allocated pod                                  *
* or C=1 Failed to allocate new pool                                           *
*    B,D Preserved                                                             *
********************************************************************************
doMMALA         sep     #$40
mmAllocLarge    php
                clc
                adc     #$00ff
                bcc     @bankinc
                pha
                sep     #$20
                .rwid   shortm
                tsc
                tcd
                inc     DPCOP_AH+1
                rep     #$20
                .rwid   longm
                pla
@bankinc        and     #$ff00            ;BHA now contains a size rounded up to pages
                plp
                pha
                ldal    f:$00fe04
                tax
                lda     $05,S
                and     #$00ff
                ora     $01,S
                xba
                pld
                bra     LFED45F

********************************************************************************
* __MM 4 - MMBP - ????                                                         *
********************************************************************************
doMMBP          jsr     LFECEC5
                bcs     LFED440
                and     #$ff00
                pha
                lda     $05,S
                and     #$00ff
                bne     LFED435
                phx
                ldal    f:$00fe04
                tax
                ldal    f:DPCOP_B,x
                dec     A
                and     #$00ff
                plx
LFED435         ora     $01,S
                xba
                sta     $01,S
                ply
                tdc
                clc
                adc     #$00ff
LFED440         bcs     LFED465
                and     #$ff00
                xba
                bra     LFED473

********************************************************************************
* __MM 6 - MMASD - Allocate small descending                                   *
*                                                                              *
* This call allocates a region of memory from a specified pool. The region is  *
* taken from the top of the pool, and must be less than 64K bytes long.        *
* Moreover, the routine will only succeed if the pool would not cross a bank   *
* boundary                                                                     *
*                                                                              *
* Entry:                                                                       *
*    Y    Handle of memory pool                                                *
*    HA   Number of bytes to allttcate                                         *
*    X    MMASD                                                                *
* Exit                                                                         *
*    C=0  Pool allocated successfully                                          *
*    Y    Handle of newly allocated pool                                       *
*    BHA  Base address of newly allocated pool                                 *
* or C=1  Failed to allocate new pool                                          *
*    B,D  Preserved                                                            *
********************************************************************************
doMMASD         clv
                bra     mmAllocSmall

********************************************************************************
* __MM A - MMASA - Allocate small                                              *
*                                                                              *
* This call allocates a region of memory from a specified pool. The region is  *
* taken from the lower area of the pool, and must be less than 64K bytes long. *
* Moreover, the routine will only succeed if the pool would not cross a bank   *
* boundary                                                                     *
*                                                                              *
* Entry:                                                                       *
*    Y    Handle of memory pool                                                *
*    HA   Number of bytes to allttcate                                         *
*    X    MMASA                                                                *
* Exit                                                                         *
*    C=0  Pool allocated successfully                                          *
*    Y    Handle of newly allocated pool                                       *
*    BHA  Base address of newly allocated pool                                 *
* or C=1  Failed to allocate new pool                                          *
*    B,D  Preserved                                                            *
********************************************************************************
doMMASA         sep     #$40
mmAllocSmall    php
                clc
                adc     #$00ff
                and     #$ff00
                plp
                bit     #$00ff
                bne     LFED4BA
                xba
                clc
                bra     LFED460

LFED45F         sec
LFED460         php
                jsr     LFECEC5
                plb
LFED465         bcs     LFED4BA
                pha
                phx
                jsr     LFED510
                bvc     LFED46F
                txy
LFED46F         plx
                pla
                bcs     LFED4BA
LFED473         jsr     LFED5DE
                bcs     LFED4BA
                jsr     LFED6E7
                jsr     allocHandleQRY
                bcs     LFED4B7
LFED480         phb
                pha
                phx
                sep     #$20
                .rwid   shortm
                lda     $0e,S
                pha
                plb
                rep     #$20
                .rwid   longm
                lda     $0c,S
                cop     COP_2C_OPFMA
                bcc     LFED4A4

                phy
                ldx     #__MMFND
                jsl     __MM
                ply
                lda     #$0000
                bcs     LFED4A5
                ldal    f:DPCOP_DP,x
                tax
LFED4A4         txa
LFED4A5         plx
                stal    f:DPCOP_DP,x
                pla
                plb
                clc
LFED4AD         tcd
                sep     #$20
                .rwid   shortm
                phb
                pla
                sta     $03,S
                tdc
                clc
                rts

                .rwid   longm
LFED4B7         jsr     LFED4D6
LFED4BA         sec
                rts

********************************************************************************
* __MM 2 - MMINIT - initialise MM routines                                     *
********************************************************************************
doMMINIT        jsr     LFECEC5
                bcs     LFED4D4
                phx
LFED4C2         plx
                jsr     LFED6C5
                bcs     LFED4D6
                phx
LFED4C9         tax
                jsr     LFED6C5
                bcc     LFED4C9
                jsr     LFED4D6
                bra     LFED4C2

LFED4D4         sec
                rts

LFED4D6         jsr     LFED6C5
                bcc     LFED50B
                jsr     LFECF1E
                phx
                jsr     LFED6B5
                pha
LFED4E3         jsr     LFED6B5
                tax
                bcc     LFED4E3
                tax
                jsr     LFED6C5
                cmp     $03,S
                bne     LFED4F7
                pla
                jsr     LFED6D7
                bra     LFED503

LFED4F7         tax
                jsr     LFED6B5
                cmp     $03,S
                bne     LFED4F7
                pla
                jsr     LFED6D2
LFED503         plx
                jsr     LFECDDA
                jsr     doMMCHK
                rts

LFED50B         sec
                jsr     doMMCHK
                rts

LFED510         php
                ldy     #$0000
                phy
                ldy     #$ffff
                phy
                phy
                pha
                phx
                ldal    f:DPCOP_X+1,x
                tay
                jsr     LFED6C5
                bcs     LFED53D
LFED526         tax
                ldal    f:DPCOP_X+1,x
                jsr     LFED593
                ldal    f:DPCOP_AH+1,x
                tay
                jsr     LFED6B5
                bcc     LFED526
                cmp     $01,S
                bne     syserrNextPoolXPollANotParD
                tax
LFED53D         plx
                phx
                ldal    f:DPCOP_AH+1,x
                jsr     LFED593
                lda     $09,S
                cmp     $03,S
                plx
                pla
                bne     LFED54F
                clc
LFED54F         ply
                plx
                pla
                bcs     LFED557
                plp
                sec
                rts

LFED557         plp
                clc
                rts

syserrNextPoolXPollANotParD pld           ;TODO: pointless ?
                cop     COP_0F_OPERR
                .zstr   “Memory SCAN error: NEXT POOL X IS POOL A NOT PARENT D”
LFED593         pha
                phy
                phb
                plp
                bcs     LFED5B4
LFED599         ply
                phy
                lda     $01,S
                eor     $03,S
                beq     LFED5B9
                and     #$ff00
                beq     LFED5B4
                pla
                clc
                adc     #$0100
                and     #$ff00
                pha
                jsr     LFED5BC
                bra     LFED599

LFED5B4         lda     $03,S
                jsr     LFED5BC
LFED5B9         pla
                pla
                rts

LFED5BC         sec
                phy
                sbc     $01,S
                ply
                cmp     $11,S
                bcc     LFED5C7
                sta     $11,S
LFED5C7         cmp     $0b,S
                bcc     LFED5DD
                clc
                phy
                adc     $01,S
                ply
                sec
                sbc     $0b,S
                sta     $0d,S
                lda     $0f,S
                inc     A
                bne     LFED5DD
                tya
                sta     $0f,S
LFED5DD         rts

LFED5DE         eor     #$0000
                bne     LFED5E6
                brl     LFED668

LFED5E6         pha
                phx
                phy
                ldal    f:DPCOP_X+1,x
                cmp     $01,S
                beq     LFED5F3
                bcs     LFED665
LFED5F3         pla
                pha
                clc
                adc     $05,S
                bcs     LFED665
                cmpl    f:DPCOP_AH+1,x
                beq     LFED602
                bcs     LFED665
LFED602         txy
                jsr     LFED6C5
                bcs     LFED639
                bra     LFED617

LFED60A         txy
                jsr     LFED6B5
                bcc     LFED617
                cmp     $03,S
                bne     sysErrorNextXisPoolANotParD
                tax
                bra     LFED62C

LFED617         tax
                ldal    f:DPCOP_X+1,x
                cmp     $01,S
                bcc     LFED60A
                sec
                sbc     $05,S
                cmp     $01,S
                bcc     LFED665
                tya
                cmp     $03,S
                beq     LFED639
LFED62C         phx
                tyx
                ldal    f:DPCOP_AH+1,x
                plx
                cmp     $01,S
                beq     LFED639
                bcs     LFED665
LFED639         phx
                phy
                lda     #$0002
                jsr     LFECE01
                ply
                pla
                bcs     LFED665
                jsr     LFED6D2
                pla
                pha
                stal    f:DPCOP_X+1,x
                clc
                adc     $05,S
                stal    f:DPCOP_AH+1,x
                txa
                jsr     LFED6D7
                tya
                cmp     $03,S
                beq     LFED6A7
                txa
                tyx
                jsr     LFED6D2
                bra     LFED6AC

LFED665         ply
                plx
                pla
LFED668         sec
                jsr     doMMCHK
                rts

sysErrorNextXisPoolANotParD pld           ;TODO: pointless before syserr
                cop     COP_0F_OPERR
                .zstr   “Memory ALLOC error: NEXT POOL X IS POOL A NOT PARENT D”
LFED6A7         txa
                tyx
                jsr     LFED6D7
LFED6AC         plx
                plx
                plx
                tax
                clc
                jsr     doMMCHK
                rts

LFED6B5         phd
                ldal    f:$000000,x
                pha
                pld
                ldal    f:DPCOP_X+1,x
                cmp     DPCOP_X+1
                tdc
                pld
                rts

LFED6C5         txa
                cmpl    f:DPCOP_Y+1,x
                beq     LFED6D1
                ldal    f:DPCOP_Y+1,x
                clc
LFED6D1         rts

LFED6D2         stal    f:$000000,x
                rts

LFED6D7         stal    f:DPCOP_Y+1,x
                rts

********************************************************************************
* __MM E - MMBAS - Return pool base                                            *
* This call returns the base address of a given memory pool.                   *
* Entry: Y Handle of memory pool X MMBAS                                       *
* Exit:                                                                        *
*    D,Y Preserved                                                             *
*    C=0 Success                                                               *
*    BHA Base address of memory pool                                           *
* or C=1 The handle was not a valid one                                        *
********************************************************************************
doMMBAS         jsr     LFECEC5
                bcs     LFED6F2
                jsr     LFED6E7
                brl     LFED4AD

LFED6E7         ldal    f:DPCOP_X+1,x
                pha
                plb
                plb
                xba
                and     #$ff00
LFED6F2         rts

********************************************************************************
* __MM 10 - MMLEN - Return pool length                                         *
*                                                                              *
* This call returns the longth in bytes of a given memory pool.                *
*                                                                              *
* Entry:                                                                       *
*    Y    Handle of memory pool                                                *
*    X    MMLEN                                                                *
* Exit:                                                                        *
*    D,Y  Preserved                                                            *
*    C=0  Success                                                              *
*    BHA  Length of memory pool                                                *
* or C=1  The handle was not a valid one                                       *
********************************************************************************
doMMLEN         jsr     LFECEC5
                bcs     LFED71A
                jsr     LFED6FE
                brl     LFED4AD

LFED6FE         jsr     LFED6E7
                bcs     LFED71A
                phb
                pha
                jsr     LFED726
                sec
                sbc     $01,S
                sta     $01,S
                sep     #$20
                .rwid   shortm
                phb
                pla
                sbc     $03,S
                sta     $03,S
                rep     #$20
                .rwid   longm
                pla
                plb
                clc
LFED71A         rts

********************************************************************************
* __MM 12 - MMTOP - Return pool top                                            *
*                                                                              *
* This routine returns the address of the byte after the last byte of the pool *
* whose handle is given in Y. That is, if the last available byte in a pool is *
* at address &0231FF, the address returned in BHA will be &023200.             *
*                                                                              *
* Entry:                                                                       *
*    Y    Handle of memory pool                                                *
*    X    MMTOP                                                                *
* Exit:                                                                        *
*    D,Y  Preserved                                                            *
*    C=0  Success                                                              *
*    BHA  Top address of pool                                                  *
* or C=1  The handle was not a valid one.                                      *
********************************************************************************
doMMTOP         jsr     LFECEC5
                bcs     LFED731
                jsr     LFED726
                brl     LFED4AD

LFED726         ldal    f:DPCOP_AH+1,x
                pha
                plb
                plb
                xba
                and     #$ff00
LFED731         rts

********************************************************************************
* __MM 14 - MMFND - Find a memory pool by address                              *
*                                                                              *
* This routine takes an address and returns the handle of a pool containing    *
* that address if possible. Note that if the address is within a large pool,   *
* the handle will only be returned if that pool contains no sub-pools.         *
*                                                                              *
* Entry:                                                                       *
*    BHA  Memory address within pool                                           *
*    X    MMFND                                                                *
*    Y    HDMMT (2), the task pool handle                                      *
* Exit:                                                                        *
*    D    Preserved                                                            *
*    C=0  A pool containing the address exists                                 *
*    Y    Handle of pool                                                       *
* or C=1  No pool found                                                        *
*                                                                              *
* TODO: does something else in Y search sub-pools?                             *
********************************************************************************
doMMFND         jsr     doMMCHK
                phb
                pha
                phb
                plb
                bne     LFED74C
                ldal    f:$00fe04
                tax
                ldal    f:DPCOP_AH+1,x
                sec
                sbc     #$0100
                ora     $02,S
                sta     $02,S
LFED74C         plb
                ldy     #$0007
                jsr     LFECEC5
                bcs     LFED768
                jsr     LFED6C5
LFED758         tax
                ldal    f:DPCOP_AH+1,x
                cmp     $01,S
                beq     LFED763
                bcs     LFED76B
LFED763         jsr     LFED6B5
                bcc     LFED758
LFED768         pla
                sec
                rts

LFED76B         ldal    f:DPCOP_X+1,x
                cmp     $01,S
                beq     LFED775
                bcs     LFED768
LFED775         jsr     LFED6C5
                bcc     LFED758
                pla
                jmp     coGetHandleByBlockAddr_QRY

********************************************************************************
* __MM 16 - MMCHK - Check the integrity of the MM system                       *
*                                                                              *
* This call is a system-level routine to check that the data structures        *
* maintained by the memory managment software is self-consistent. If the       *
* system is OK, the routine returns, otherwise an OPERR is executed.           *
*                                                                              *
* Entry:                                                                       *
*    X     MMCHK                                                               *
* Exit:                                                                        *
*    D,B   Preserved                                                           *
*    A,X,Y Preserved                                                           *
********************************************************************************
doMMCHK         php
                phd
                phb
                pha
                phx
                phy
                jsr     LFECE4E
                pea     $0000
                plb
                plb
                ldal    f:$00fe0a
                tcd
                tax
                jsr     LFED6C5
                bcs     syserrNoSubPools
                jsr     LFED7D4
                ply
                plx
                pla
                plb
                pld
                plp
                rts

syserrNoSubPools cop    COP_0F_OPERR
                .zstr   “Memory error: WHOLE MACHINE POOL HAS NO SUBPOOLS”
LFED7D4         jsr     LFED872
                jsr     LFED6C5
                bcs     LFED7E6
                phd
                phx
                phx
                pld
                tax
                jsr     LFED7D4
                plx
                pld
LFED7E6         txy
                jsr     LFED6B5
                bcs     LFED7FD
                tax
                ldal    f:DPCOP_X+1,x
                pea     $0000
                plb
                plb
                cmp     DPCOP_AH+1,y
                bcc     syserrBasePoolLtEndPrev
                bra     LFED7D4

LFED7FD         phd
                eor     $01,S
                cmp     #$0001
                eor     $01,S
                pld
                bcs     syserrNextPoolXisANotParD
                rts

syserrBasePoolLtEndPrev cop COP_0F_OPERR
                .zstr   “Memory error: BASE POOL X < END OF PRECEDING POOL Y”
syserrNextPoolXisANotParD cop $0f
                .zstr   “Memory error: NEXT POOL X IS POOL A NOT PARENT D”
LFED872         ldal    f:DPCOP_X+1,x
                cmpl    f:DPCOP_AH+1,x
                beq     syserrPoolBaseGtEnd
                bcs     syserrPoolBaseGtEnd
                lda     DPCOP_X+1
                cmpl    f:DPCOP_X+1,x
                beq     LFED888
                bcs     syserrMemBaseLtParent
LFED888         ldal    f:DPCOP_AH+1,x
                cmp     DPCOP_AH+1
                beq     LFED892
                bcs     syserrPoolEndgtEndParent
LFED892         rts

syserrMemBaseLtParent cop COP_0F_OPERR
                .zstr   “Memory error: BASE POOL X < BASE PARENT D”
syserrPoolEndgtEndParent cop COP_0F_OPERR
                .zstr   “Memory error: END POOL X > END PARENT D”
syserrPoolBaseGtEnd cop COP_0F_OPERR
                .zstr   “Memory error: BASE POOL X > END POOL X”
********************************************************************************
* __MM 18 - MMAZB - Allocate a bank zero area                                  *
*                                                                              *
* This call allocates memory from bank zero, in a way similar to MMASD. Note   *
* that this call should be used only when it is essential that the memory      *
* allocated is in bank zero, eg to store an interrupt routine.                 *
*                                                                              *
* Bank zero is a relatively precious resource on the 65816 and should not be   *
* over used if many tasks are to be supported.                                 *
* Entry:                                                                       *
*    HA   Number of bytes to allocate                                          *
*    X    MMAZB                                                                *
* Exit:                                                                        *
*    C=0  Pool allocated successfully                                          *
*    BHA  Base address of newly allocated pool                                 *
*    Y    Handle of new direct page pool                                       *
* or C=1  Failed to allocate new pool                                          *
*    B,D  Preserved                                                            *
*                                                                              *
* QRY HDMMM - is this a special bank 0 pool that we can allocate from?         *
********************************************************************************
doMMAZB         ldy     #HDMMM
                ldx     #__MMASD
                jsl     __MM
                bcs     @retsec
                phx
                pha
                phb
; stack
; 
; +4 X  - not documented whether MMASD corrupts this
; +2 HA - alloc'd B0 pointer
; +1 B  - alloc'd bank
                ldal    f:$00fe04
                tax
                sep     #$20
                .rwid   shortm
                ldal    f:$000007,x
                dec     A
                eor     $01,S
                cmp     #$01
                rep     #$20
                .rwid   longm
                plb
                pla
                plx
                bcs     @fpretsec
                brl     LFED480

@fpretsec       ldx     #__MMFP           ;free the handle
                jsl     __MM
@retsec         sec
                rts

********************************************************************************
* __MM 1A - MMMRG - merge two pools                                            *
*                                                                              *
* MMMRG - Merge two memory pools into one                                      *
*                                                                              *
* This call combines two existing contiguous pools of memory into a single,    *
* larger one. The pools must not overlap, ie the call may not be used to merge *
* a pool with one of its sub-pools.                                            *
*                                                                              *
* Entry:                                                                       *
*    Y    Handle of pool 1                                                     *
*    HA   Handle of pool 2                                                     *
*    X    MMMRG                                                                *
* Exit:                                                                        *
*    C=0  The pools were merged successfully                                   *
*    Y    Handle of composite pool                                             *
* or C=1  The pools could not be merged                                        *
*    B,D  Preserved                                                            *
*                                                                              *
* Note that the handle of the composite pool may be different from both of the *
* source handles                                                               *
********************************************************************************
doMMMRG         pha
                phy
                pha
                jsr     LFECEC5
                bcc     LFED94F
                brl     LFED9E3

LFED94F         ply
                phx
                jsr     LFECEC5
                bcc     LFED959
                brl     LFED9E3

LFED959         pld
                lda     DPCOP_X+1
                cmpl    f:DPCOP_X+1,x
                bcs     LFED966
                phd
                txa
                tcd
                plx
LFED966         jsr     LFED6B5
                bcs     LFED9E4
                phd
                eor     $01,S
                cmp     #$0001
                pld
                bcs     LFED9E4
                ldal    f:DPCOP_AH+1,x
                cmp     DPCOP_X+1
                bne     LFED9E4
                lda     DPCOP_AH+1
                stal    f:DPCOP_AH+1,x
                txy
                tdc
                tax
                jsr     LFED6B5
                tyx
                jsr     LFED6D2
                tdc
                tax
                jsr     LFED6C5
                bcs     LFED9B4
                pha
LFED994         tax
                jsr     LFED6B5
                bcc     LFED994
                tya
                jsr     LFED6D2
                tyx
                jsr     LFED6C5
                bcs     LFED9B0
LFED9A4         tax
                jsr     LFED6B5
                bcc     LFED9A4
                pla
                jsr     LFED6D2
                bra     LFED9B4

LFED9B0         pla
                jsr     LFED6D7
LFED9B4         ply
                jsr     LFECEC5
                bcs     syserrUnexpectedMMRG
                txa
                phd
                eor     $01,S
                cmp     #$0001
                pld
                bcs     LFED9CA
                jsr     LFED9E8
                ply
                bra     LFED9D1

LFED9CA         tya
                ply
                pha
                jsr     LFED9E8
                ply
LFED9D1         jsr     LFECEC5
                bcs     syserrUnexpectedMMRG
                jsr     LFECF1E
                bcs     syserrUnexpectedMMRG
                jsr     allocHandleQRY
                bcs     syserrUnexpectedMMRG
                brl     LFED480

LFED9E3         pla
LFED9E4         ply
                pla
                sec
                rts

LFED9E8         jsr     LFECEC5
                bcs     syserrUnexpectedMMRG
                jsr     LFECF1E
                bcs     syserrUnexpectedMMRG
                jsr     LFECDDA
                bcs     syserrUnexpectedMMRG
                rts

syserrUnexpectedMMRG cop COP_0F_OPERR
                .zstr   “Unexpected error: MMMRG”
********************************************************************************
* CO - CoRoutine entry point                                                   *
********************************************************************************
                .rwid   shortm,shortx
default__CO     php
                rep     #$30
                .rwid   longm,longx
                cpx     #$001e
                bcs     LFEDA26
                phd
                phb
                jsr     (tblCoServDispatch,x)
                plb
                pld
                bcs     LFEDA26
                plp
                .rwid   shortm,shortx
                clc
                rtl

                .rwid   longm,longx
LFEDA26         plp
                .rwid   shortm,shortx
                sec
                rtl

tblCoServDispatch .dd2  __ST_0 & $ffff
                .dd2    doCOCRE & $ffff   ;COPAR - 2 - initialize QRY
                .dd2    doCOENV & $ffff   ;COENV - 4 - set coroutine environment
                .dd2    doCODEL & $ffff   ;CODEL - 6 - delete coroutine
                .dd2    doCODES & $ffff   ;CODES - 8 - destroy coroutine
                .dd2    doCOREN & $ffff   ;COREN - A - restore current coroutine's environment
                .dd2    doCOBRK & $ffff   ;COBRK - C  - Set coroutine BRK handler
                .dd2    doCOCBH & $ffff   ;COCBH - E - cancel break handler
                .dd2    doCORTB & $ffff   ;CORTB - 10 - ???
                .dd2    doCOIAM & $ffff   ;COIAM - 12 - Return current handle
                .dd2    doCONAME & $ffff  ;CONAME - 14 - ???
                .dd2    doCOINIT & $ffff  ;COINIT - 16 - initialise language
                .dd2    doCOKILL & $ffff  ;COKILL - 18 - kill language
                .dd2    doCOHELP & $ffff  ;COHELP - 1A - language help
                .dd2    doCoMOD & $ffff   ;COMOD - 1C - ???

********************************************************************************
* __CO 1C - COMOD - ???                                                        *
*                                                                              *
* Given an address in a module make a coroutine from the module's entry point  *
*                                                                              *
* Entry:                                                                       *
*    BHA  contains an address somewhere within a module                        *
*                                                                              *
* QRY Looks to do OPRMI then drops through to COCRE                            *
********************************************************************************
                .rwid   longm,longx
doCoMOD         ldx     #$0000
                txy
                cop     COP_34_OPRMI      ;get entry address
                bcs     @retsec
********************************************************************************
* __CO 02 - COCRE - Create a coroutine                                         *
*                                                                              *
* This sets up the initial execution address of a new coroutine and declares   *
* its stack size.                                                              *
* Entry:                                                                       *
*    BHA Entry address of coroutine                                            *
*    D   Desired size of coroutine's stack                                     *
*    X   COCRE                                                                 *
* Exit:                                                                        *
*    C=0 Coroutine created successfully                                        *
*    Y   Handle to be used in subsequent calls                                 *
* or C=1 Coroutine could not be created                                        *
*                                                                              *
* Notes: The stack size must be a non-zero multiple of 256 bytes - &200 is a   *
* good size                                                                    *
********************************************************************************
doCOCRE         phd
                phb
                pha
                tdc
                ldx     #__MMAZB          ;allocate the stack
                jsl     __MM
                bcs     @retsecpop        ;stack alloc failed
                lda     #$0006
                jsr     LFECE01           ;alloc a coroutine block??? QRY
                bcs     @freestackretsec
                phx
                pld
                sty     CO_off_DP         ;stash handle in DP slot QRY
                stz     CO_off_Parent
                stz     CO_off_flags
                phx                       ;stack X - pointer to coroutine block
; stack contents
; +6    D on entry (stack size)
; +3    BHA address of coroutine start
; +1    B0 pointer to corouting block
                ldx     #__MMTOP          ;get top of stack
                jsl     __MM
                sec                       ;assume in B0 (alloc'd with MMAZB)
                sbc     #$0004            ;subtract 4 to point at 3rd last byte
                tax                       ;put that in X
                lda     $03,S             ;get BHA on entry
                stal    f:$000000,x
                lda     $05,S
                and     #$00ff
                stal    f:$000002,x       ;store bank - TODO: this looks like it may be a bug - it stores a 0 outside our pool!
                txa                       ;put X in A
                dec     A                 ;decrement so it's suitable as a stack pointer
                plx                       ;X = block addr
                ply                       ;Y = HA on entry
                plb                       ;B = B on entry
; stack is now
; +1 is D on entry
                phx                       ;block addr
                phx                       ;block addr
                pld
                phd                       ;into D
; stack is now
; +5  D on entry
; +3  block addr
; +1  block addr
                tsx                       ;X=caller's stack
                tcs                       ;set S = coroutine stack
; coroutine stack is now
; +1      BHA of coroutine start addr
                phd
                phb
                dey
                phy
                php
; coroutine stack is now
; 
; +7   BHA on entry
; +5   D block address
; +4   B on entry
; +2   HA-1 on entry
; +1   current flags
                tsc                       ;coroutine stack pointer into A
                txs                       ;back to caller's stack
                plx                       ;X = block pointer
                stal    f:CO_off_stack,x  ;store coroutine start stack
                jsr     allocHandleQRY
                bcs     @nohandles
                lda     #$0000
                stal    f:CO_off_DP,x     ;zero the DP handle (used to stash stack handle)
                pla
                pld
                clc
                rts

@nohandles      ldal    f:CO_off_DP,x     ;get the handle for the stack we stashed earlier
                pha                       ;push it
                jsr     LFECDDA           ;free the block QRY?
                ply                       ;get back stack handle
@freestackretsec ldx    #__MMFP
                jsl     __MM
@retsecpop      pla
                plb
                pld
@retsec         sec
                rts

********************************************************************************
* COENV - Set a coroutine's environment                                        *
* This specifies the direct page to be used whenever a coroutine is entered.   *
* If the coroutine is to use any shared direct page workspace (as distinct     *
* from direct page workspace allocated by itself, this should be called        *
* immediately after a coroutine is created, or at least before it is called    *
* for the first time.                                                          *
*                                                                              *
* Entry:                                                                       *
*    Y    Handle                                                               *
*    D    Direct page to be used by coroutine                                  *
*    X    COENV                                                                *
* Exit:                                                                        *
*    C=0  Environment set correctly                                            *
* or C=1  Environment could not be set                                         *
*                                                                              *
* TODO: Documentation - Y can be 0 in which case this sets for the current     *
* coroutine                                                                    *
********************************************************************************
doCOENV         phd
                pea     EXSYS
                pld
                lda     <EXSYS_CUR_COROUTINE ;if no handle default to one at offset $10 in table
                cpy     #$0000
                beq     @yeq0
                lda     [<EXSYS_HANDLEBLOCK_LONGPTR],y ;coroutine handle's address from the handleblock
@yeq0           tcd                       ;put it in DP
                lda     $01,S             ;get pushed DP parameter
                sta     CO_off_DP         ;store in the block DP offset
                lda     CO_off_flags
                ora     #COFLAG_HASDP
                sta     CO_off_flags      ;set flag to indicate we want DP setting on subsequent continues
                pld
                clc
                rts

********************************************************************************
* __CO E - COCBH - Cancel break haniUer Tor Ibis coroutine                     *
*                                                                              *
* This call resets the break handler for the current coroutine to a 'no        *
* handler' state (as when the coroutine is created). If a BRK occurs in a      *
* routine with no BRK handler, the operating system will attempt to use its    *
* parent's handler. This carries on up the hierarchy until a valid BRK handler *
* is found or the top level is reached. In the latter case, an OPERR COP       *
* instruction is executed.                                                     *
*                                                                              *
* Entry:                                                                       *
*    X   COCBH                                                                 *
* Exit:                                                                        *
*    B,D Preserved                                                             *
*    C=0 Break handler was cancelled                                           *
*    BHA Address of old break handler                                          *
* or C=1 There was no break handler to cancel                                  *
********************************************************************************
doCOCBH         ldal    f:EXSYS_CUR_COROUTINE
                tcd
                lda     #COFLAG_hasBRKhandler
                trb     CO_off_flags
                beq     LFEDB04
                ldx     CO_off_8_BRKBLOCK
                sep     #$20
                .rwid   shortm
                ldal    f:$000002,x
                sta     $03,S             ;get K of old break handler
                rep     #$20
                .rwid   longm
                ldal    f:$000000,x       ;get HA of old break handler
                pha
                jsr     LFECDDA
                pla
                clc
                rts

LFEDB04         sec
                rts

********************************************************************************
* __CO C - COBRK - Set the coroutine break handler address                     *
*                                                                              *
* This routine sets the address of the routine to be called when a BRK is      *
* encountered within the current coroutine.                                    *
*                                                                              *
* Entry:                                                                       *
*    BHA BRK handler address X COBRK                                           *
* Exit:                                                                        *
*    C=0 Address was set OK                                                    *
* or C=1 Address could not be set                                              *
********************************************************************************
doCOBRK         pha
                pea     EXSYS
                pld
                pei     (<EXSYS_CUR_COROUTINE)
                pld
                lda     CO_off_flags
                and     #COFLAG_hasBRKhandler
                beq     LFEDB19
                ldx     CO_off_8_BRKBLOCK
                bra     LFEDB2A

LFEDB19         lda     #$0008
                jsr     LFECE01
                bcs     LFEDB35
                lda     CO_off_flags
                ora     #COFLAG_hasBRKhandler
                sta     CO_off_flags
                stx     CO_off_8_BRKBLOCK
LFEDB2A         txa
                tcd
; this is the block pointed to by 8 - not sure what goes in it!
                lda     $04,S
                sta     $01
                pla
                sta     $00
                clc
                rts

LFEDB35         pla
                rts

********************************************************************************
* __CO 6 - CODEL- Delete a coroutine                                           *
*                                                                              *
* This deletes an existing coroutine.                                          *
*                                                                              *
* Entry:                                                                       *
*    Y    Handle                                                               *
*    X    CODEL                                                                *
* Exit:                                                                        *
*    B,D  Preserved                                                            *
*    C=0 Coroutine was deleted                                                 *
* or C=l Coroutine was not deleted                                             *
********************************************************************************
doCODEL         rep     #$70              ; clear V 
coDes2          phb
                phd
                pea     MM_HANDLE_TAB
                pld
                lda     [$02],y           ;get coroutine block from hanbdle
                pha
                pld                       ;coroutine block into D
                bvs     LFEDB54           ;if V set skip parent check
                sec
                lda     $0b
                and     #$00ff
                eor     #$0006
                bne     @ret
                lda     $02
                bne     @ret
LFEDB54         phd
                lda     $00
                pea     $0000
                plb
                plb
                ldx     #__MMFND
                jsl     __MM
                bcc     @ok
                brl     syserrCoRoutineError

@ok             phy
                ldx     #__MMTOP
                jsl     __MM
                sec
                sbc     #$0004
                tax
                dex
                dex
                ldal    f:$000000,x
                cmp     $03,S
                beq     LFEDB82
                brl     syserrCoRoutineError

LFEDB82         ply
                ldx     #__MMFP
                jsl     __MM
                plx
                jsr     LFECF1E
                txa
                tcd
                pei     (DPCOP_DP)
                pei     (DPCOP_X)
                jsr     LFECDDA
                pla
                plx
                bit     #$2000
                beq     @clcret
                jsr     LFECDDA
@clcret         clc
@ret            pld
                plb
                rts

********************************************************************************
* __CO 8 - CODES - Destroy coroutine                                           *
*                                                                              *
* This acts as CODEL, but does not check that the routine to be deleted has a  *
* parent. The useof this call is to delete a routine in which a BRK (error     *
* condition) has occurred, and which has no BRK handler of its own.            *
*                                                                              *
* Entry:                                                                       *
*    Y    Handle                                                               *
*    X    CODES                                                                *
* Exit:                                                                        *
*    B,D  Preserved                                                            *
*    C=0  Coroutine was deleted                                                *
* or C=1  Coroutine could not be deleted                                       *
********************************************************************************
doCODES         sep     #$40
                bra     coDes2

********************************************************************************
* __CO 1A - COHELP - Language help                                             *
*                                                                              *
* These calls relate to the language entry point reason codes. The CO reason   *
* codes call a given coroutine at its entry point as if it were a language,    *
* with the appropriate reason code in X. The entry is called as a subroutine,  *
* not a coroutine, so is expected to return with an RTL.                       *
*                                                                              *
* COHELP calls the coroutine with X=6                                          *
*                                                                              *
* Entry:                                                                       *
*    Y    Handleof coroutine to be catted                                      *
*    BHA  Arguments                                                            *
* Exit:      B,D Preserved                                                     *
*    BHA,X,Y Results from language entry                                       *
********************************************************************************
doCOHELP        ldx     #$0006
                bra     coLangFn

********************************************************************************
* __CO 14 - CONAME - ???                                                       *
*                                                                              *
* These calls relate to the language entry point reason codes. The CO reason   *
* codes call a given coroutine at its entry point as if it were a language,    *
* with the appropriate reason code in X. The entry is called as a subroutine,  *
* not a coroutine, so is expected to return with an RTL.                       *
*                                                                              *
* COHELP calls the coroutine with X=0                                          *
*                                                                              *
* Entry:                                                                       *
*    Y    Handleof coroutine to be catted                                      *
*    BHA  Arguments                                                            *
* Exit:      B,D Preserved                                                     *
*    BHA,X,Y Results from language entry                                       *
********************************************************************************
doCONAME        ldx     #$0000
                bra     coLangFn

********************************************************************************
* __CO 16 - COINIT - initialise language                                       *
*                                                                              *
* These calls relate to the language entry point reason codes. The CO reason   *
* codes call a given coroutine at its entry point as if it were a language,    *
* with the appropriate reason code in X. The entry is called as a subroutine,  *
* not a coroutine, so is expected to return with an RTL.                       *
*                                                                              *
* COINIT calls the coroutine with X=2                                          *
*                                                                              *
* Entry:                                                                       *
*    Y    Handleof coroutine to be catted                                      *
*    BHA  Arguments                                                            *
* Exit:      B,D Preserved                                                     *
*    BHA,X,Y Results from language entry                                       *
********************************************************************************
doCOINIT        ldx     #$0002
                bra     coLangFn

********************************************************************************
* __CO 18 - COKILL - kill a language                                           *
*                                                                              *
* These calls relate to the language entry point reason codes. The CO reason   *
* codes call a given coroutine at its entry point as if it were a language,    *
* with the appropriate reason code in X. The entry is called as a subroutine,  *
* not a coroutine, so is expected to return with an RTL.                       *
*                                                                              *
* COKILL calls the coroutine with X=4                                          *
*                                                                              *
* Entry:                                                                       *
*    Y    Handleof coroutine to be catted                                      *
*    BHA  Arguments                                                            *
* Exit:      B,D Preserved                                                     *
*    BHA,X,Y Results from language entry                                       *
********************************************************************************
doCOKILL        ldx     #$0004
coLangFn        phk
                per     LFEDC0F
                phk
                phd
                php
                phb
                pha
                phx
                pea     $ff00
                pld
                lda     [DPCOP_Y+1],y
                pha
                pld
                pei     (DPCOP_AH+1)
                lda     $00
                phd
                pea     $0000
                plb
                plb
                ldx     #$0014
                jsl     __MM
                bcc     LFEDBE3
                brl     syserrCoRoutineError

LFEDBE3         ldx     #$0012
                jsl     __MM
                sec
                sbc     #$0004
                tax
                dex
                dex
                pla
                cmpl    f:$000000,x
                beq     LFEDBFB
                brl     syserrCoRoutineError

LFEDBFB         sep     #$20
                .rwid   shortm
                ldal    f:DPCOP_X+1,x
                sta     $0b,S
                rep     #$20
                .rwid   longm
                ldal    f:DPCOP_Y+1,x
                sta     $09,S
                pld
                plx
                pla
                plb
LFEDC0F         rti

                .dd1    $60

********************************************************************************
* 12 - COIAM - Return handle                                                   *
*                                                                              *
* This call returns the handle of the current coroutine, ie the coroutine from *
* which the call to COIAM is made.                                             *
*                                                                              *
* Entry:                                                                       *
*    X    COIAM                                                                *
* Exit:                                                                        *
*    B,D  Preserved                                                            *
*    C=0  The handle was found                                                 *
*    Y    The current coroutine's handle                                       *
*    C=l  No handle could be found for the caller                              *
********************************************************************************
doCOIAM         pea     EXSYS
                pld
                pei     (<EXSYS_CUR_COROUTINE)
                plx
                jmp     coGetHandleByBlockAddr_QRY

********************************************************************************
* CRS - co-routine call sibling QRY                                            *
********************************************************************************
                .rwid   shortm,shortx
default__CRS    php
                rep     #$30
                .rwid   longm,longx
                stal    f:EXSYS_CO_A_SAVE
                tsc
                phd
                pea     $ff00
                pld
                sta     [$10]
                lda     [DPCOP_Y+1],y
                pei     ($10)
                pld
                ldy     DPCOP_Y+1
                stz     DPCOP_Y+1
                bra     LFEDC5B

                .rwid   shortm,shortx
LFEDC35         rep     #$30
                .rwid   longm,longx
                stal    f:EXSYS_CO_A_SAVE
                tsc
                pha
                pea     $ff00
                pld
                lda     [DPCOP_Y+1],y
                ldy     #$0000
                bra     LFEDC5B

********************************************************************************
* CCO - Call a Co-routine                                                      *
*                                                                              *
* This is used to call a coroutine from its creator (parent). On the first     *
* call the entry address given in the COCRE call is used. Subsequently, the    *
* address after the last CWT executed by the routine is used                   *
*                                                                              *
* Entry:                                                                       *
*    Y       Handle of child                                                   *
*    BHA,X,C Arguments to child coroutine                                      *
* Exit:                                                                        *
*    BHA,X,C Results from child coroutine                                      *
*    B,D     Preserved                                                         *
*                                                                              *
* Note: C is the C flag.                                                       *
********************************************************************************
                .rwid   shortm,shortx
default__CCO    php
                phd
                rep     #$30
                .rwid   longm,longx
                stal    f:EXSYS_CO_A_SAVE ;we need to preserve A not on the stack as the stack will get switched
                pea     EXSYS
                pld
                tsc
                sta     [<EXSYS_CUR_COROUTINE] ;store current stack at offset 0 in our block
                lda     [<EXSYS_HANDLEBLOCK_LONGPTR],y
                ldy     <EXSYS_CUR_COROUTINE
LFEDC5B         tcd
                stal    f:EXSYS_CUR_COROUTINE
                lda     $0b
                and     #$00ff
                eor     #$0006
                beq     LFEDC85
                brk     $00

                .zstr   “Invalid coroutine handle”

LFEDC85         lda     CO_off_Parent
                beq     LFEDC8C
                brl     syserrCoRoutineError

LFEDC8C         sty     CO_off_Parent     ;set ourselves as the parent
                lda     $01,S             ;get parent DP
                bit     CO_off_flags-1    ;check for $40 in low byte of flags (has DP)
                bvc     @nodp
                lda     CO_off_DP         ;get stored DP for child
@nodp           sta     CO_off_DP         ;store in child DP
                pha                       ;save DP - again - TODO: there looks to be a lot of unnecessary stuff here
                pea     EXSYS
                pld
                lda     [<EXSYS_CUR_COROUTINE] ;get stack from offset 0 in block
                pld                       ;set up call DP
                tcs                       ;the rtl below will now return to the address that was last stacked by the child coroutine
                ldal    f:EXSYS_CO_A_SAVE ;get back A as passed in 
plpRetCy        bcs     @plpRetSec
                plp
                clc
                rtl

@plpRetSec      plp
                sec
                rtl

********************************************************************************
* CWT - coroutine wait / suspend                                               *
*                                                                              *
* Suspends current co-routine and return to parent                             *
********************************************************************************
                .rwid   shortm,shortx
default__CWT    php
                rep     #$30
                .rwid   longm,longx
                stal    f:EXSYS_CO_A_SAVE ;save AH - we're about to swap out stack so we can't stack it
                ldal    f:EXSYS_CUR_COROUTINE ;get pointer to this coroutine's block
                tcd                       ;in DP
                tsc
                sta     CO_off_stack      ;store stack at offset 0
                lda     CO_off_Parent
                bne     LFEDCC3
                brl     syserrCoRoutineError ;flag error - cannot call CWT when no parent?!?

LFEDCC3         stal    f:EXSYS_CUR_COROUTINE ;make parent the current coroutine
                pei     (DPCOP_Y+1)       ;push the address of the parent block on the stack
                stz     DPCOP_Y+1         ;clear current co routine's parent
                pld                       ;DP to point at parent block
                lda     $00               ;load the parent's stack pointer
                tcs                       ;and switch to that stack
                ldal    f:EXSYS_CO_A_SAVE ;return AH from coroutine
                pld                       ;pull D - the DP of the parent coroutine
                bra     plpRetCy          ;continue coroutine

********************************************************************************
* COREN - Restore current coroutine's environment                              *
*                                                                              *
* This call may be used to restore D to the value set by a previous call to    *
* COENV. It is useful as many of the OS calls corrupt D.                       *
*                                                                              *
* Entry:                                                                       *
*    X    COREN                                                                *
* Exit:                                                                        *
*    D    Value set in previous call to COENV                                  *
*                                                                              *
* TODO: Documentation also seems to restore B which is _NOT_ set up by COENV!  *
********************************************************************************
doCOREN         ldal    f:EXSYS_CUR_COROUTINE
                tcd
                sep     #$20
                .rwid   shortm
                lda     CO_off_B
                sta     $03,S
                rep     #$20
                .rwid   longm
                lda     CO_off_DP
                sta     $04,S
                rts

syserrCoRoutineError cop COP_0F_OPERR
                .zstr   “Coroutine error”
coHandleBRK     tdc
                tay
                ldal    f:EXSYS_CUR_COROUTINE
                tax
@lp_par         tcd
                lda     #COFLAG_hasBRKhandler
                bit     CO_off_flags
                bne     coCallBrkHandler  ;there's a break handler set - call it
                lda     CO_off_Parent
                bne     @lp_par           ;check parent's for break handler
; If we get this no ancestor has a break handler set so call the system one and
; hang up the machine
                cop     COP_2D_OPWRM      ;write module name to VDU
                bcc     LFEDD15
                cop     COP_01_OPWRS      ;write "?"
                .zstr   “?”
LFEDD15         cop     COP_01_OPWRS
                .zstr   “: ”
                ldx     #__STSBK
                jsl     __ST
LFEDD21         ldx     #__STTBK
                jsl     __ST
                bcs     sysErrBRKbutNoHandler
                cop     COP_00_OPWRC
                bra     LFEDD21

sysErrBRKbutNoHandler cop COP_01_OPWRS
                .zstr   “*** BRK but no handler:”
                tya
                tcd
                ldx     #$000d
                jsr     @dumpregs
                cop     COP_01_OPWRS
                .zstr   “ ***”,$0d,$0a
                cop     COP_0F_OPERR
                .zstr   “”
coCallBrkHandler tdc
                cmpl    f:EXSYS_CUR_COROUTINE
                beq     LFEDD66
                lda     CO_off_stack      ;switch current level's stack in
                tcs
LFEDD66         tdc
                stal    f:EXSYS_CUR_COROUTINE ;set this coroutine as current
                phb
                phd
                cli
                php                       ;push flags for RTI with interrupts (re)enabled
                phd
                pei     (CO_off_8_BRKBLOCK) ;QRY - dunno what's at offset 8 here
                pld
                lda     $01
                sta     $05,S
                lda     $00
                sta     $04,S
                pld
                pei     ($06)
                pld
                rti

********************************************************************************
* __CO 10 - CORTB - ???                                                        *
*                                                                              *
* Does nothing                                                                 *
********************************************************************************
doCORTB         rep     #$30
                rts

                .rwid   shortm,shortx
getCurCorParent php
                phd
                rep     #$30
                .rwid   longm,longx
                pea     EXSYS
                pld
                pei     (<EXSYS_CUR_COROUTINE)
                pld
                ldx     CO_off_Parent
                beq     @retsec
                pld
                plp
                .rwid   shortm,shortx
                clc
                rts

                .rwid   longm,longx
@retsec         pld
                plp
                .rwid   shortm,shortx
                sec
                rts

                rtl

                .dd1    $29
                .dd1    $43
                .dd1    $28
                .dd1    $00

                .rwid   longm,longx
defaultCLIV     php
                sep     #$20
                .rwid   shortm
                rep     #$10
                sta     <DPSYS_GSREAD_ptr
                xba
                sta     <DPSYS_GSREAD_ptr+1
                ldy     #$0000
LFEDDAC         lda     (<DPSYS_GSREAD_ptr),y
                cmp     #$0d
                beq     LFEDDCB
                iny
                bne     LFEDDAC
                cop     COP_26_OPBHA
                .zstr   “Line too long”
                ldx     #$0001
                plp
                .rwid   longm
                sec
                rts

                .rwid   shortm
LFEDDCB         ldy     #$ffff
LFEDDCE         iny
                lda     (<DPSYS_GSREAD_ptr),y
                cmp     #‘ ’
                beq     LFEDDCE
                cmp     #‘*’
                beq     LFEDDCE
                cmp     #$0d
                beq     LFEDDF7
                cmp     #‘|’
                beq     LFEDDF7
                cmp     #‘/’
                beq     LFEDDFF
                cmp     #‘.’
                beq     LFEDDFE
                jsr     LFEDE0B
                phk
                jsr     LFEF372
                bcc     LFEDDF7
                bvs     LFEDDFA
                plp
                .rwid   longm
                sec
                rts

                .rwid   shortm
LFEDDF7         plp
                .rwid   longm
                clc
                rts

                .rwid   shortm
LFEDDFA         plp
                .rwid   longm
                brl     LFEC764

                .rwid   shortm
LFEDDFE         clc
LFEDDFF         php
                iny
                jsr     LFEDE0B
                plp
                bcs     LFEDDFA
                plp
                brl     starCAT

LFEDE0B         clc
                tya
                adc     $ed
                xba
                lda     $ee
                adc     #$00
                xba
                rts

********************************************************************************
* OSBYTE 7F - Check for EOF                                                    *
********************************************************************************
                .rwid   shortx
OSBYTE_7F       txy
                phk
                jsr     CheckEOF
                ldx     #$00
                bcc     @ret
                dex
@ret            rts

LFEDE21         ldy     $d9
LFEDE23         jsr     LFEDE67
                cmp     #$20
                beq     LFEDE21
LFEDE2A         cmp     #$0d
                rts

LFEDE2D         bcc     LFEDE23
LFEDE2F         jsr     LFEDE23
                cmp     #$2c
                bne     LFEDE2A
                ldy     $d9
                rts

LFEDE39         jsr     LFEDE23
                jsr     LFEDE76
                bcc     LFEDE87
LFEDE41         sta     $e1
                jsr     LFEDE74
                bcc     LFEDE61
                tax
                lda     $e1
                asl     A
                bcs     LFEDE87
                asl     A
                bcs     LFEDE87
                adc     $e1
                bcs     LFEDE87
                asl     A
                bcs     LFEDE87
                sta     $e1
                txa
                adc     $e1
                bcs     LFEDE87
                bcc     LFEDE41

LFEDE61         ldx     $e1
                cmp     #$0d
                sec
                rts

LFEDE67         phx
                phy
                ldx     #$0e
                jsl     __ST
                sty     $d9
                ply
                plx
                rts

LFEDE74         ldy     $d9
LFEDE76         jsr     LFEDE67
                cmp     #$3a
                bcs     LFEDE87
                cmp     #$30
                bcc     LFEDE87
                and     #$0f
                rts

LFEDE84         jsr     LFEDE2F
LFEDE87         clc
                rts

                .dd1    $a4
                .dd1    $d9

LFEDE8B         jsr     LFEDE76
                bcs     LFEDE9E
                and     #$df
                cmp     #$47
                bcs     LFEDE84
                cmp     #$41
                bcc     LFEDE84
                php
                sbc     #$37
                plp
LFEDE9E         ldy     $d9
                rts

                .dd1    $a4
                .dd1    $d9
                .dd1    $20
                .dd1    $67
                .dd1    $de
                .dd1    $c9
                .dd1    $20
                .dd1    $f0
                .dd1    $f7
                .dd1    $c9
                .dd1    $0d
                .dd1    $60
                .dd1    $90
                .dd1    $f4
                .dd1    $20
                .dd1    $a3
                .dd1    $de
                .dd1    $c9
                .dd1    $2c
                .dd1    $d0
                .dd1    $f4
                .dd1    $a4
                .dd1    $d9
                .dd1    $60

starRESET       sep     #$20
                lda     #$08
                stal    VIA_DDRB
                lda     #$00
                stal    VIA_ORB
@here           bra     @here

********************************************************************************
* OSBYTE 9D - Fast BPUT                                                        *
*                                                                              *
* QRY - QRY - QRY this doesn't look right                                      *
********************************************************************************
OSBYTE_9D       phd
                php
                rep     #$30
                .rwid   longm,longx
                cpx     #$0010
                bcs     LFEDEFC
                ldy     #$0000
                phx
                pld
                beq     LFEDEEA
LFEDED9         lda     #$000a
                jsr     LFECE01
                bcs     LFEDEEA
                phx
                iny
                tya
                phd
                cmp     $01,S
                pld
                bcc     LFEDED9
LFEDEEA         lda     #$000a
                jsr     LFECE01
                bcc     LFEDEEA
                tya
                beq     LFEDEFC
LFEDEF5         plx
                jsr     LFECDDA
                dey
                bne     LFEDEF5
LFEDEFC         plp
                .rwid   shortm,shortx
                pld
                rts

TFEDEFF         rts

OSBYTE_7B_null  rts

OSBYTE_F        bne     OSB_FlushInputBuffer
FlushAllBuffers ldx     #$08
@lp             cli
                sei
                jsr     OSBYTE_15
                dex
                bpl     @lp
OSBYTE_15       cpx     #$09
                bcc     OSB_FlushBufferX
                rts

                .dd1    $a9
                .dd1    $00
                .dd1    $a2
                .dd1    $03
                .dd1    $ac
                .dd1    $85
                .dd1    $a5
                .dd1    $18
                .dd1    $6b
                .dd1    $20
                .dd1    $66
                .dd1    $e3
                .dd1    $eb
                .dd1    $4b
                .dd1    $ad
                .dd1    $23
                .dd1    $a5
                .dd1    $48
                .dd1    $ad
                .dd1    $22
                .dd1    $a5
                .dd1    $48
                .dd1    $eb
                .dd1    $08
                .dd1    $40

OSB_FlushInputBuffer pea $0000
                plb
                .dbank  $00
                plb
                ldx     SYSVAR_41_input_stream ;Get current input stream
OSB_FlushBufferX clc
LFEDF34         phb
                pea     $0000
                plb
                .dbank  $00
                plb
                pha
                php
                sei
                bcs     @skipsound
                txa
                and     #$04
                beq     @skipsound
                lda     SYSVAR_SOUND_EXT_FLAG ;sound flag??
                beq     @ext_sound_qry
                txa
                pha
                tay
                ldx     #$17
                jsr     donothingRTS
                pla
                tax
                bne     @skipsound
@ext_sound_qry  jsr     SOUND_RESET_CHAN_X_QRY
@skipsound      sec
                ldal    f:SYSVARS_ELK_BUFFER_BUSY,x
                ror     A
                stal    f:SYSVARS_ELK_BUFFER_BUSY,x
                cpx     #$02
                bcs     @notinput
                lda     #$00
                sta     SYSVAR_SOFTKEY_STRLEN
                sta     SYSVAR_ELK_SOFTKEY_STRLEN
                sta     SYSVAR_VDU_QLEN
@notinput       jsr     callCNPV
                plp
                pla
                plb
                rts

defaultCNPV     bvc     LFEDF83
                ldal    f:SYSVARS+204,x
                stal    f:$00a5d5,x
                rts

LFEDF83         php
                sei
                php
                sec
                ldal    f:$00a5d5,x
                sbcl    f:SYSVARS+204,x
                bcs     LFEDF99
                sec
                phb
                phk
                .dbank  K (auto)
                plb
                sbc     LFEE178 & $ffff,x
                plb
LFEDF99         plp
                bcc     LFEDFA6
                clc
                phb
                phk
                .dbank  K (auto)
                plb
                adc     LFEE178 & $ffff,x
                plb
                eor     #$ff
LFEDFA6         ldy     #$00
                tax
                plp
                rts

LFEDFAB         sei
                jsr     callINSV
                bcc     LFEDFBE
                jsr     LFEEAB6
                bcs     LFEDFBE
                pha
                jsr     LFEEC18
                pla
                cli
                bra     LFEDFAB

LFEDFBE         rts

LFEDFBF         pha
                stz     $a5e2,x
                stz     $a5e3,x
                stz     $a5e4,x
                stz     $a5e5,x
                pla
                rts

LFEDFCE         phy
                rol     A
                rol     A
                rol     A
                rol     A
                ldy     #$04
LFEDFD5         rol     A
                rol     $a5e2,x
                rol     $a5e3,x
                rol     $a5e4,x
                rol     $a5e5,x
                bcs     LFEDFE7
                dey
                bne     LFEDFD5
LFEDFE7         ply
                rts

LFEDFE9         ldx     #$1c
                jsl     __ST
                ldx     #$0c
                jsl     __ST
                pea     $0000
                plb
                plb
                rts

starLOAD        ldy     #$ff
                bra     intstarLOADSAVE

starSAVE        ldy     #$00
intstarLOADSAVE phy
                phk
                jsr     LFEF7D8
                pha
                stal    f:DPSYS_OSWORD0_BUFPTR-1
                xba
                stal    f:DPSYS_OSWORD0_BUFPTR
                xba
                phb
                pla
                stal    f:DPSYS_OSWORD0_BUFPTR+1
                pla
                ldy     #$00
                phy
                ldx     #__STGIT
                jsl     __ST
                plb
                ldx     #$04
                jsr     LFEDFBF
                ldx     #$08
                jsr     LFEDFBF
                lda     #$ff
                sta     $a5f2
                sta     $a5f3
                sta     $a5f4
                stz     $a5f5
LFEE03A         ldx     #__STGRD
                jsl     __ST
                bcc     LFEE03A
                jsr     LFEDFE9
                sty     $d9
                ldx     #$0c
                pla
                beq     LFEE086
                jsr     LFEE0F7
                bcc     LFEE075
                cop     COP_26_OPBHA
                .zstr   “Bad address”
                ldx     #$01
                sec
                rts

@reterrBadCommand cop   COP_26_OPBHA
                .zstr   “Bad command”
                ldx     #$01
                sec
                rts

LFEE075         beq     LFEE07A
                brl     @reterrBadCommand

LFEE07A         rep     #$30
                .rwid   longm,longx
                lda     #$a5e2
                cop     COP_24_OPCVD
                cop     COP_4E_OPLOD
                sep     #$30
                .rwid   shortm,shortx
                rts

LFEE086         jsr     LFEDFE9
                ldx     #$0c
                jsr     LFEE0F7
                bcs     @reterrBadCommand
                jsr     LFEDE67
                clv
                cmp     #$2b
                bne     LFEE09C
                sep     #$40
                ldy     $d9
LFEE09C         ldx     #$10
                jsr     LFEE0F7
                bcs     @reterrBadCommand
                php
                bvs     LFEE0B5
                ldx     #$fc
                sec
LFEE0A9         lda     $a4f6,x
                sbc     $a4f2,x
                sta     $a4f6,x
                inx
                bne     LFEE0A9
LFEE0B5         ldx     #$03
LFEE0B7         lda     $a5ee,x
                sta     $a5ea,x
                sta     $a5e6,x
                dex
                bpl     LFEE0B7
                plp
                beq     LFEE0DA
                ldx     #$08
                jsr     LFEE0F7
                bcs     @reterrBadCommand
                beq     LFEE0DA
                ldx     #$04
                jsr     LFEE0F7
                bcs     @reterrBadCommand
                beq     LFEE0DA
                bne     @reterrBadCommand

LFEE0DA         rep     #$30
                .rwid   longm,longx
                lda     #$a5e2
                cop     COP_24_OPCVD
                cop     COP_4F_OPSAV
                sep     #$30
                .rwid   shortm,shortx
                rts

OSBYTE77a       brl     OSBYTE_77

defaultUSERV    brk     $fe

                .zstr   “Bad command”

LFEE0F7         php
                jsr     LFEDE23
                jsr     LFEDE8B
                bcc     LFEE112
                jsr     LFEDFBF
LFEE103         jsr     LFEDFCE
                bcs     LFEE116
                jsr     LFEDE8B
                bcs     LFEE103
                plp
                cmp     #$0d
                clc
                rts

LFEE112         plp
                cmp     #$0d
                php
LFEE116         plp
                sec
                rts

starKEY         brl     starKEY2

starLCB         ldx     #$9d              ;Does OSBYTE &9D
                bra     LFEE12F

starFX          ldx     #$0c
                jsl     __ST
                jsr     LFEDE39
                bcc     defaultUSERV
                phx
                php
                bra     LFEE137

LFEE12F         phx
                php
                ldx     #$0c
                jsl     __ST
LFEE137         lda     #$00
                pha
                .dbank  $00 (auto)
                plb
                sta     $e0
                sta     $df
                plp
                jsr     LFEDE2D
                beq     LFEE15D
                jsr     LFEDE39
                bcc     defaultUSERV
                stx     $e0
                jsr     LFEDE2F
                beq     LFEE15D
                jsr     LFEDE39
                bcc     defaultUSERV
                stx     $df
                jsr     LFEDE23
                bne     defaultUSERV
LFEE15D         ldy     $df
                ldx     $e0
                pla
                cop     COP_06_OPOSB
                clc
                rts

                .dd1    $a7
                .dd1    $aa
                .dd1    $a8
                .dd1    $a7
                .dd1    $a7
                .dd1    $a7
                .dd1    $a7
                .dd1    $a7
                .dd1    $a9
                .dd1    $00
                .dd1    $00
                .dd1    $c0
                .dd1    $c0
                .dd1    $50
                .dd1    $60
                .dd1    $70
                .dd1    $80
                .dd1    $00
LFEE178         .dd1    $e0
                .dd1    $00
                .dd1    $40
                .dd1    $c0
                .dd1    $f0
                .dd1    $f0
                .dd1    $f0
                .dd1    $f0
                .dd1    $c0

LFEE181         lda     $e16f,x
                sta     $f6
                lda     $e166,x
                sta     $f7
                stz     $f8
                rts

********************************************************************************
* OSBYTE 98 - examing buffer status                                            *
********************************************************************************
OSBYTE_98       sep     #$40
                bvs     callREMV

********************************************************************************
* OSBYTE 91 - read character from buffer                                       *
********************************************************************************
OSBYTE_91       clv
callREMV        xba
                phk
                ldal    f:SYSVARS_REMV+1
                pha
                ldal    f:SYSVARS_REMV
                pha
                xba
                php
                rti

defaultREMV     phb
                php
                sei
                phk
                .dbank  K (auto)
                plb
                ldal    f:SYSVARS+204,x
                cmpl    f:$00a5d5,x
                beq     LFEE22A
                tay
                jsr     LFEE181
                lda     [$f6],y
                bvs     LFEE1D5
                pha
                iny
                tya
                bne     LFEE1C1
                lda     LFEE178 & $ffff,x
LFEE1C1         stal    f:SYSVARS+204,x
                cpx     #$02
                bcc     LFEE1D4
                cmpl    f:$00a5d5,x
                bne     LFEE1D4
                ldy     #$00
                jsr     LFEE573
LFEE1D4         pla
LFEE1D5         tay
                plp
                clc
                plb
                rts

LFEE1DA         tya
                ldy     #$02
                jsr     LFEE573
                tay
********************************************************************************
* OSBYTE 8A - place char in buffer                                             *
*                                                                              *
*    X=buffer number                                                           *
*    Y=character to place                                                      *
********************************************************************************
OSBYTE_8A       tya
callINSV        xba
                phk
                ldal    f:SYSVARS_INSV+1
                pha
                ldal    f:SYSVARS_INSV
                pha
                xba
                php
                rti

defaultINSV     phb
                php
                sei
                phk
                .dbank  K (auto)
                plb
                pha
                ldal    f:$00a5d5,x
                tay
                iny
                bne     LFEE202
                ldy     LFEE178 & $ffff,x
LFEE202         tya
                cmpl    f:SYSVARS+204,x
                beq     LFEE21E
                pha
                ldal    f:$00a5d5,x
                tay
                pla
                stal    f:$00a5d5,x
                jsr     LFEE181
                pla
                sta     [$f6],y
                plp
                clc
                plb
                rts

LFEE21E         pla
                cpx     #$02
                bcs     LFEE22A
                ldy     #$01
                jsr     LFEE573
                pha
                pla
LFEE22A         plp
                sec
                plb
                rts

LFEE22E         phb
                pea     $0000
                plb
                plb
                ldx     #$00
********************************************************************************
* OSBYTE 99 - write character to buffer                                        *
********************************************************************************
OSBYTE_99       txa
                and     SYSVAR_RS232_MODE
                bne     OSBYTE_8A
                tya
                eorl    f:SYSVARS_6C_ESCCHAR
                oral    f:SYSVARS_75_ESCACTION
                beq     @doESCape
                jsr     LFEE1DA
                plb
                rts

@doESCape       lda     SYSVAR_58_ESCBRK_EFFECT
                ror     A
                tya
                bcs     @noESC            ;Ignore ESCape
                ldy     #$06
                jsr     LFEE573
                bcc     @noESC
                jsr     OSBYTE_7D         ;Set ESCape condition
@noESC          clc
                plb
                rts

INKEY_ctdn      pea     $0000
                plb
                .dbank  $00
                plb
                php
                sei
                stx     SYSVARS_B0_INKEYCTDN
                sty     SYSVARS_B0_INKEYCTDN+1
                plp
                lda     #$ff
                bra     LFEE274

int_OPRDC       lda     #$00
LFEE274         pea     $0000
                plb
                plb
                pha
                phx
                phy
                phk
                jsr     LFEBF9B
LFEE280         rep     #$10
                .rwid   longx
                ldy     $d1
                beq     LFEE29D
                sec
                ror     $e6
                phb
                jsr     default__BGET
                plb
                php
                lsr     $e6
                plp
                sep     #$10
                .rwid   shortx
                bcc     LFEE2E8
                phb
                jsr     OSBYTE_77
                plb
                bra     LFEE280

LFEE29D         sep     #$10
                phx
                lda     #$00
                xba
                lda     #$03
                ldx     #$02
                jsl     __EV
                plx
                bcs     LFEE2E5
                lda     SYSVAR_SOFTKEY_STRLEN
                beq     LFEE2B9
                jsr     LFEE42C
                clc
                bra     LFEE2E8

LFEE2B9         php
                sei
                cop     COP_21_OPPRE
                bcs     LFEE2E0
                ldx     SYSVAR_41_input_stream
                jsr     LFEE355
                bcs     LFEE2CB
                plp
                clc
                bra     LFEE2E8

LFEE2CB         plp
                sec
                lda     $03,S
                bpl     LFEE29D
                php
                sei
                lda     SYSVARS_B0_INKEYCTDN
                ora     SYSVARS_B0_INKEYCTDN+1
                plp
                eor     #$00
                bne     LFEE29D
                bra     LFEE2EA

LFEE2E0         plp
                lda     #$00
                bra     LFEE2E7

LFEE2E5         lda     #$1b
LFEE2E7         sec
LFEE2E8         sta     $03,S
LFEE2EA         ply
                plx
                pla
                rts

LFEE2EE         ror     A
                pla
                bcs     LFEE304
LFEE2F2         tya
                pha
                jsr     LFEE44E
                cmp     #$01
                bne     LFEE2FE
                brl     LFEE35B

LFEE2FE         pla
                bcc     LFEE30B
                jsr     LFEE459
LFEE304         clc
                rts

LFEE306         jsr     Serv8_QRY
                pla
                tax
LFEE30B         jsr     OSBYTE_91
                bcs     LFEE358
                cpx     #$01
                bne     LFEE319
                ldy     SYSVAR_RS232_MODE
                bne     LFEE357
LFEE319         tay
                cmp     #$80
                bcc     LFEE357
                and     #$0f
                cmp     #$0b
                bcc     LFEE2F2
                jsr     LFEE448
                pha
                lda     SYSVARS+125
                bne     LFEE2EE
                lda     SYSVARS_7C_OUTDEST
                ror     A
                ror     A
                pla
                bcs     LFEE30B
                cmp     #$87
                bne     LFEE349
                txa
                pha
                ldx     #$26
                phk
                jsr     callModVDU
                tay
                beq     LFEE306
                pla
                tax
                tya
                clc
                rts

LFEE349         tay
                txa
                pha
                tya
                ldx     #$28
                phk
                jsr     callModVDU
                pla
                tax
LFEE355         bra     LFEE30B

LFEE357         clc
LFEE358         bcs     LFEE373
                rts

LFEE35B         pla
                jsr     LFEE418
                jsr     LFEE41B
                bra     LFEE355

                lda     #$06
QOSBY_VECTORthruA524 xba
                phk
                lda     QOSBY_VECTOR+1
                pha
                lda     QOSBY_VECTOR
                pha
                xba
                php                       ;jump to address - why not just jmp (X) as bank is 0?
                rti

LFEE373         pha
                jsr     LFEEC18
                pla
                sec
                rts

; QRY suspect next two are dead code for rom select or something?
                txa
                lda     #$08
                sta     $f0
                stal    sheila_ULA_PAG_IRQCLR
                rts

                pha
                lda     #$0c
                stal    sheila_ULA_PAG_IRQCLR
                pla
                rts

                .dd1    $60

LFEE38E         ply
LFEE38F         bcc     LFEE394
                plp
                sec
                rts

LFEE394         plp
                clc
                rts

@reterrBadKey   cop     COP_26_OPBHA
                .zstr   “Bad key”
                ldx     #$01
                sec
                rts

starKEY2        ldx     #__STGLN
                jsl     __ST
                pea     $0000
                plb
                plb
                jsr     LFEDE39
                bcc     @reterrBadKey
                cpx     #$10
                bcs     @reterrBadKey
                jsr     LFEDE2F
                php
                ldx     SYSFNK+16
                tya
                pha
                jsr     LFEE4BD
                bcs     LFEE38E
                pla
                tay
                plp
                bne     LFEE3CE
                clc
                rts

LFEE3CE         phx
                ldx     #$0e
                jsl     __ST
                plx
                bcs     LFEE3E2
                inx
                beq     @reterrBadKey
                dex
                jsr     Fnkey_StoreXpl1
                inx
                bra     LFEE3CE

LFEE3E2         cmp     #$0d
                bne     @reterrBadKey
                php
                sei
                jsr     LFEE4BD
                bcs     LFEE38F
                ldx     #$10
LFEE3EF         cpx     $e1
                beq     LFEE412
                php
                phx
                phx
                tyx
                jsr     FnKey_LoadX
                plx
                pha
                jsr     FnKey_LoadX
                pha
                cmp     $02,S
                php
                pla
                sta     $04,S
                pla
                plx
                plx
                plp
                bne     LFEE412
                lda     SYSFNK+16
                jsr     FnKey_StoreX
LFEE412         dex
                bpl     LFEE3EF
                plp
                clc
                rts

LFEE418         and     #$0f
                rts

LFEE41B         tay
                jsr     LFEE479
                sta     SYSVAR_SOFTKEY_STRLEN
                phx
                tyx
                jsr     FnKey_LoadX
                plx
                sta     SYSVARS+121
                rts

LFEE42C         phx
                ldx     SYSVARS+121
                jsr     FnKey_LoadXpl1
                inc     SYSVARS+121
                dec     SYSVAR_SOFTKEY_STRLEN
                xba
                lda     SYSVAR_SOFTKEY_STRLEN
                xba
                plx
                rts

                .dd1    $48
                .dd1    $a9
                .dd1    $01
                .dd1    $8d
                .dd1    $68
                .dd1    $a5
                .dd1    $68
                .dd1    $60

LFEE448         sec
                and     #$0f
                adc     #$7b
                rts

LFEE44E         lsr     A
                lsr     A
                lsr     A
                lsr     A
                eor     #$04
                tay
                lda     SYSVARS+101,y
                rts

LFEE459         pha
                jsr     LFEE44E
                pla
                and     #$0f
                clc
                adc     SYSVARS+101,y
                rts

; Character buffer interpretation settings
OSBYTE_DDtoE4   phx
                phy
                sec
                sbc     #$dd
                tay
                lda     SYSVARS+109,y
                tax
                and     $01,S
                eor     $02,S
                sta     SYSVARS+109,y
                pla
                pla
                rts

LFEE479         php
                sei
                lda     SYSFNK+16
                sec
                phx
                pha
                tyx
                jsr     FnKey_LoadX
                plx
                pha
                txa
                sbc     $01,S
                plx
                plx
                sta     $f5
                txa
                pha
                ldx     #$10
LFEE492         php
                phx
                phx
                tyx
                jsr     FnKey_LoadX
                plx
                pha
                jsr     FnKey_LoadX
                sec
                sbc     $01,S
                pha
                php
                pla
                sta     $04,S
                pla
                plx
                plx
                plp
                bcc     LFEE4B4
                beq     LFEE4B4
                cmp     $f5
                bcs     LFEE4B4
                sta     $f5
LFEE4B4         dex
                bpl     LFEE492
                pla
                tax
                lda     $f5
                plp
                rts

LFEE4BD         php
                sei
                txa
                pha
                ldy     $e1
                jsr     LFEE479
                sta     $f5
                phx
                tyx
                jsr     FnKey_LoadX
                plx
                tay
                clc
                adc     $f5
                tax
                sta     $f4
                lda     SYSVAR_SOFTKEY_STRLEN
                beq     LFEE4ED
                pla
                plp
                cop     COP_26_OPBHA
                .zstr   “Key in use”
                ldx     #$01
                sec
                rts

LFEE4ED         dec     SYSVAR_SOFTKEY_CONS
                pla
                sec
                sbc     $f4
                sta     $f4
                beq     LFEE507
LFEE4F8         jsr     FnKey_LoadXpl1
                phx
                tyx
                jsr     Fnkey_StoreXpl1
                plx
                iny
                inx
                dec     $f4
                bne     LFEE4F8
LFEE507         tya
                pha
                ldy     $e1
                ldx     #$10
LFEE50D         php
                phx
                phx
                tyx
                jsr     FnKey_LoadX
                plx
                pha
                jsr     FnKey_LoadX
                pha
                cmp     $02,S
                php
                pla
                sta     $04,S
                pla
                plx
                plx
                plp
                bcc     LFEE52D
                beq     LFEE52D
                sbc     $f5
                jsr     FnKey_StoreX
LFEE52D         dex
                bpl     LFEE50D
                lda     SYSFNK+16
                phx
                tyx
                jsr     FnKey_StoreX
                plx
                pla
                sta     SYSFNK+16
                tax
                inc     SYSVAR_SOFTKEY_CONS
                plp
                clc
                rts

OSB_ResetFnKeys lda     #$11
                sta     SYSVAR_SOFTKEY_CONS
                ldx     #$10
@lp             jsr     FnKey_StoreX
                dex
                bpl     @lp
                lda     #$10
                ldx     #$00
                jsr     FnKey_StoreX
                lda     #$1e
                ldx     #$10
                jsr     Fnkey_StoreXpl1
                stz     SYSVAR_SOFTKEY_CONS
                rts

FnKey_LoadXpl1  lda     SYSFNK+1,x
                rts

Fnkey_StoreXpl1 sta     SYSFNK+1,x
                rts

FnKey_LoadX     lda     SYSFNK,x
                rts

FnKey_StoreX    sta     SYSFNK,x
                rts

LFEE573         php
                phb
                pea     $0000
                plb
                .dbank  $00
                plb
                sei
                pha
                sta     $f6
                lda     SYSVARS+181,y
                beq     LFEE58E
                tya
                ldy     $f6
                jsr     LFEEAA9
                pla
                plb
                plp
                clc
                rts

LFEE58E         pla
                plb
                plp
                sec
                rts

****************************************************************
* Converts the char in A into an upper case module name char.  *
*                                                              *
* On Entry: A contains a character                             *
*                                                              *
* On Exit:  If C = 0 A contains the original character, B      *
* contains the character                                       *
*           converted to uppercase                             *
*           If C = 1 A contains the original character, B      *
* contains the original                                        *
*           character which was not in the range A..Z or a..z  *
****************************************************************
                .rwid   longm,longx
modNameToUpper  php
                sep     #$20
                .rwid   shortm
                pha
                and     #$df              ;convert to upper case
                cmp     #‘A’
                bcc     @notname
                cmp     #‘[’
                bcc     @ok
@notname        sec                       ;set carry and return un modified A
                lda     $01,S
@ok             xba
                pla
                bcs     @retsec
                plp
                .rwid   longm
                clc
                rts

                .rwid   shortm
@retsec         plp
                .rwid   longm
                sec
                rts

tblOSBYTDispatch .dd2   OSBYTE_0 & $ffff  ;OSBYTE 0 - Get Host OS
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff ;OSBYTE 1 - R/W user flag
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff ;OSBYTE 2 - select input stream - manual lies, this does nothing
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff ;OSBYTE 3 - select output stream - manual lies this does nothing
                .dd2    OSBYTE_4 & $ffff  ;OSBYTE 4 - cursor keys action
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_F & $ffff  ;OSBYTE 0F - Flush buffers
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_12 & $ffff ;OSBYTE 12 - reset function keys
                .dd2    OSBYTE_13 & $ffff ;OSBYTE 13 - Wait vsync
                .dd2    OSBYTE_14 & $ffff ;OSBYTE 14 - Explode and reset font
                .dd2    OSBYTE_15 & $ffff
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_1A & $ffff ;OSBYTE 1A - Handset detection
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
; --- break in numbers here restart at 73 ---
                .dd2    OSBYTE_73 & $ffff ;OSBYTE 73 - blank / restore palette
                .dd2    OSBYTE_74 & $ffff ;OSBYTE 74 - reset sound system
                .dd2    OSBYTE_75 & $ffff ;OSBYTE 75 - read VDU status byte
                .dd2    OSBYTE_76 & $ffff ;OSBYTE 76 - reflect keyboard in LEDS
                .dd2    OSBYTE77a & $ffff ;OSBYTE 77 - Close all SPOOL / EXEC files
                .dd2    OSBYTE_78 & $ffff ;OSBYTE 78 - Write key pressed data
                .dd2    OSBYTE_79 & $ffff ;OSBYTE 79 - Keyboard scan
                .dd2    OSBYTE_7A & $ffff ;OSBYTE_7A - keyboard scan from &10
                .dd2    OSBYTE_7B_null & $ffff ;OSBYTE 7B - printer dormancy warning
                .dd2    OSBYTE_7C & $ffff ;OSBYTE 7C - Clear ESCape, inform tube
                .dd2    OSBYTE_7D & $ffff ;OSBYTE 7D - Set ESCape
                .dd2    OSBYTE_7E & $ffff ;OSBYTE 7E - Acknowledge ESCape condition
                .dd2    OSBYTE_7F & $ffff ;OSBYTE 7F - Check for EOF
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_81 & $ffff ;OSBYTE 81 - INKEY
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_84 & $ffff ;OSBYTE 84 - read top of memory HIMEM
                .dd2    OSBYTE_85 & $ffff ;OSBYTE 85 - get HIMEM for MODE in X
                .dd2    OSBYTE_86 & $ffff ;OSBYTE 86 - Get text cursor
                .dd2    OSBYTE_87 & $ffff ;OSBYTE 87 - get char at XY and MODE
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_8A & $ffff ;OSBYTE 8A - place char in buffer
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_91 & $ffff ;OSBYTE 91 - read character from buffer
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_98 & $ffff ;OSBYTE 98 - examine buffer status
                .dd2    OSBYTE_99 & $ffff ;OSBYTE 99 - write character to buffer
                .dd2    OSBYTE_9A & $ffff ;OSBYTE 9A - write vdu ULA
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_9D & $ffff ;OSBYTE 9D - QRY
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_DOESNOTHINGBADLY & $ffff
                .dd2    OSBYTE_A0 & $ffff ;OSBYTE A0 - read VDU variable
                .dd2    OSBYTE_A6_FF & $ffff ;OSBYTE A6-FF - read variable
                .dd2    QRY_Call_UKOSWORD & $ffff ;OSWORD > E0 QRY
                .dd2    OSWORD_0 & $ffff  ;OSWORD 0 - read line
                .dd2    TFEE963 & $ffff
                .dd2    TFEE976 & $ffff
                .dd2    TFEE95F & $ffff
                .dd2    TFEE972 & $ffff
                .dd2    OSBYTE_0_X & $ffff
                .dd2    OSBYTE_0_X & $ffff
                .dd2    TFEE890 & $ffff
                .dd2    TFEE919 & $ffff
                .dd2    TFEE6D1 & $ffff
                .dd2    TFEE6D5 & $ffff
                .dd2    TFEE6D9 & $ffff
                .dd2    TFEE6DD & $ffff
                .dd2    TFEE6E1 & $ffff
                .rwid   shortm,shortx
                lda     #$00
QRY_Call_UKOSWORD xba
                phk
                lda     SYSVARS+1
                pha
                lda     SYSVARS
                pha
                xba
                php
                rti

                .dd1    $ee
                .dd1    $49
                .dd1    $a5
                .dd1    $60

********************************************************************************
* OSBYTE 7E - Acknowledge ESCape condition                                     *
********************************************************************************
OSBYTE_7E       ldx     #$00
                .dd1    $af
                .dd1    $13
                .dd1    $ff
                .dd1    $00
                .dd1    $29
                .dd1    $03
                .dd1    $f0
                .dd1    $12
                .dd1    $ad
                .dd1    $76
                .dd1    $a5
                .dd1    $d0
                .dd1    $0b
                .dd1    $58
                .dd1    $a9
                .dd1    $00
                .dd1    $8b
                .dd1    $20
                .dd1    $14
                .dd1    $ee
                .dd1    $ab
                .dd1    $20
                .dd1    $03
                .dd1    $df
                .dd1    $a2
                .dd1    $ff
********************************************************************************
* OSBYTE 7C - Clear ESCape, inform tube                                        *
********************************************************************************
OSBYTE_7C       rep     #$30
                .dd4    SYS_ESCAPE_FLAG_QRY+$fe149c
                .dd1    $29
                .dd1    $fc
                .dd1    $ff
                .dd1    $8f
                .dd1    $13
                .dd1    $ff
                .dd1    $00
                .dd1    $e2
                .dd1    $30
                .dd1    $60
********************************************************************************
* OSBYTE 7D - Set ESCape                                                       *
********************************************************************************
OSBYTE_7D       lda     #$00
                xba
                lda     #$03
                cop     COP_20_OPSEV
                rts

********************************************************************************
* OSBYTE 14 - Explode                                                          *
********************************************************************************
OSBYTE_14       txa
                ldx     #VDUMOD_OPX_8_EXPLODE
                bra     phkCallModVDU

********************************************************************************
* OSBYTE 73 - unknown VDU operation                                            *
*                                                                              *
* Blank restore palette                                                        *
*                                                                              *
* calls VDU module with A=X, X=#&A                                             *
********************************************************************************
OSBYTE_73       txa
                ldx     #VDUMOD_OPX_A
                bra     phkCallModVDU

********************************************************************************
* OSBYTE 75 - read VDU status byte                                             *
********************************************************************************
OSBYTE_75       txa
                ldx     #VDUMOD_OPX_22_READSTATUS
                bra     phkCallModVDU

********************************************************************************
* OSBYTE 84 - read top of memory HIMEM                                         *
*                                                                              *
* QRY what does this actually return                                           *
********************************************************************************
OSBYTE_84       txa
                ldx     #VDUMOD_OPX_C_HIMEM
                bra     phkCallModVDU

********************************************************************************
* OSBYTE 85 - get HIMEM for MODE in X                                          *
********************************************************************************
OSBYTE_85       txa
                ldx     #VDUMOD_OPX_E_HIMEMBYX
                bra     phkCallModVDU

********************************************************************************
* OSBYTE 86 - Get text cursor                                                  *
********************************************************************************
OSBYTE_86       txa
                ldx     #VDUMOD_OPX_10_GETCURSOR
                bra     phkCallModVDU

********************************************************************************
* OSBYTE 87 - get char at XY and MODE                                          *
********************************************************************************
OSBYTE_87       txa
                ldx     #VDUMOD_OPX_16_GETCHARXY
                bra     phkCallModVDU

********************************************************************************
* OSBYTE A0 - read VDU variable                                                *
********************************************************************************
OSBYTE_A0       txa
                ldx     #VDUMOD_OPX_24_READVDUVAR+12
                bra     phkCallModVDU

TFEE6D1         ldx     #$18
                bra     LFEE6E3

TFEE6D5         ldx     #$1a
                bra     LFEE6E3

TFEE6D9         ldx     #$1c
                bra     LFEE6E3

TFEE6DD         ldx     #$1e
                bra     LFEE6E3

TFEE6E1         ldx     #$20
LFEE6E3         pha
                lda     $ec
                pha
                plb
                pla
phkCallModVDU   phk
                jsr     callModVDU
                rts

********************************************************************************
* OSBYTE 9A - write vdu ULA                                                    *
*                                                                              *
* This doesn't seem to work as documented on MDFS.net for the Electron instead *
* it:                                                                          *
*                                                                              *
* ULA/COPY = (OLD AND Y) EOR X                                                 *
*                                                                              *
* returns OLD in X                                                             *
********************************************************************************
OSBYTE_9A       phx
                phy
                ldx     SYSVARS_ULA_MISC_COPY
                txa
                and     $01,S
                eor     $02,S
                sta     SYSVARS_ULA_MISC_COPY
                stal    shiela_ULA_MISC
                pla
                pla
                jmp     resetFlashCounters

********************************************************************************
* OSBYTE 1A - handset detection                                                *
********************************************************************************
OSBYTE_1A       ldx     <DPVAR_ACD4_HANDSET_STATUS_QRY
                rts

                .dd1    $c8
                .dd1    $18
                .dd1    $b9
                .dd1    $52
                .dd1    $a5
                .dd1    $48
                .dd1    $8a
                .dd1    $99
                .dd1    $52
                .dd1    $a5
                .dd1    $68
                .dd1    $a8
                .dd1    $ad
                .dd1    $51
                .dd1    $a5
                .dd1    $d0
                .dd1    $19
                .dd1    $8e
                .dd1    $51
                .dd1    $a5
                .dd1    $a9
                .dd1    $00
                .dd1    $90
                .dd1    $02
                .dd1    $a9
                .dd1    $07
                .dd1    $8d
                .dd1    $48
                .dd1    $a5
                .dd1    $98
                .dd1    $48
                .dd1    $ac
                .dd1    $48
                .dd1    $a5
                .dd1    $a2
                .dd1    $14
                .dd1    $4b
                .dd1    $20
                .dd1    $38
                .dd1    $fe
                .dd1    $68
                .dd1    $a8
                .dd1    $50
                .dd1    $0b
                .dd1    $98
                .dd1    $e0
                .dd1    $0a
                .dd1    $b0
                .dd1    $07
                .dd1    $bc
                .dd1    $b5
                .dd1    $a5
                .dd1    $9d
                .dd1    $b5
                .dd1    $a5
                .dd1    $98
                .dd1    $aa
                .dd1    $60

********************************************************************************
* OSBYTE 81 - INKEY                                                            *
*                                                                              *
*  On entry: XY=16-bit argument                                                *
*  On exit:  XY=returned character or state                                    *
*            Cy=when waiting for a character, no character returned            *
********************************************************************************
OSBYTE_81       tya
                bmi     LFEE74F
                cli
                jsr     INKEY_ctdn
                bcs     LFEE74D
                tax
LFEE74B         lda     #$00
LFEE74D         tay
                rts

LFEE74F         txa
                and     #$0f
                beq     LFEE769
                txa
                eor     #$7f
                tax
                txy
                ldx     #$04
                jsl     __KB
                rol     A
LFEE760         ldx     #$ff
                ldy     #$ff
                bcs     LFEE768
                inx
                iny
LFEE768         rts

LFEE769         txa
                beq     LFEE773
                jsr     OSBYTE_DOESNOTHINGBADLY
                clc
                bne     LFEE760
                rts

LFEE773         ldx     #$f9
                bra     LFEE74B

                .dd1    $8a
                .dd1    $49
                .dd1    $ff
                .dd1    $aa
                .dd1    $e0
                .dd1    $02
                .dd1    $b8
                .dd1    $50
                .dd1    $02

; calls the CNPV vector
; 
; TODO: check with MAME - must CNPV be called from this ROM -
; bank not passed?
; 
; TODO: replace with
;   PER +
;   JMP (CNPV)
; +
callCNPV        sep     #$40
                xba
                phk
                lda     SYSVARS_CNPV+1
                pha
                lda     SYSVARS_CNPV
                pha
                xba
                php
                rti

                .dd1    $30
                .dd1    $e6
                .dd1    $f0
                .dd1    $0d
                .dd1    $20
                .dd1    $b6
                .dd1    $e7
                .dd1    $f0
                .dd1    $07
                .dd1    $bc
                .dd1    $fb
                .dd1    $a5
                .dd1    $bd
                .dd1    $f7
                .dd1    $a5
                .dd1    $aa
                .dd1    $60
                .dd1    $20
                .dd1    $b6
                .dd1    $e7
                .dd1    $f0
                .dd1    $02
                .dd1    $a2
                .dd1    $00
                .dd1    $ac
                .dd1    $f7
                .dd1    $a5
                .dd1    $a9
                .dd1    $00
                .dd1    $8d
                .dd1    $f7
                .dd1    $a5
                .dd1    $60
                .dd1    $8a
                .dd1    $0d
                .dd1    $41
                .dd1    $a5
                .dd1    $f0
                .dd1    $b2

; This looks to be some sort of vestigial attempt at implementing r/w variables
; in OSBYTE but just does an RTS
OSBYTE_DOESNOTHINGBADLY ldx #$07
                jsr     donothingRTS
                ldx     <DPSYS_OSB_X
                ldy     <DPSYS_OSB_Y
                eor     #$00
                rts

OSBYTE_7A       ldx     #$01
OSBYTE_79       txy
                ldx     #$04
                jsl     __KB
                rts

doDispatchOSBYTE pea    DPLOC_SYS
                pld
                pea     $0000
                plb
                .dbank  $00
                plb
                pha
                php
                sei
                sta     <DPSYS_OSB_A
                stx     <DPSYS_OSB_X
                sty     <DPSYS_OSB_Y
                ldx     #$07
                cmp     #$73
                bcc     @osb_0to72
                cmp     #$a1
                bcc     @osb_73toA0
                cmp     #$a6
                bcc     @exitNotImpl
                clc
LFEE7ED         lda     #$a1              ;numbers A1..A6 get turned to A1; A2 if SEC entered below at e85b
                adc     #$00
@osb_73toA0     sbc     #$56              ;73..A2 get turned into 1C..4B
LFEE7F3         asl     A                 ;; multiply by 2
                sec
                sty     <DPSYS_OSB_Y
dispatchOSWORDinA tay                     ;When OSWORD enters here A=98..B4
                bit     SYSVAR_FLAGS_SOMETHINGOSBYTEY
                bpl     LFEE804
                txa
                clv
                jsr     QOSBY_VECTORthruA524
                bvs     @restoreflags_returnCy
LFEE804         phb
                phk
                .dbank  K (auto)
                plb
                lda     0+(tblOSBYTDispatch & $ffff)+1,y
                sta     <DPSYS_OSB_IND+1
                lda     tblOSBYTDispatch & $ffff,y
                sta     <DPSYS_OSB_IND
                plb
                lda     <DPSYS_OSB_A
                ldy     <DPSYS_OSB_Y
                bcs     @notosw
                lda     [<DPSYS_OSB_X]    ;if carry clear (OSWORD) A = first byte from long ptr
@notosw         sec
                ldx     <DPSYS_OSB_X
                jsr     callDP_F6_SEC_ZeqX
@restoreflags_returnCy ror A
                plp
                rol     A
                pla
                clv
                rts

@osb_0to72      ldy     #$00
                cmp     #$1c
                bcc     LFEE7F3
@exitNotImpl    php
                php
OSB_plaplaplpplaSECSEV pla
                pla
                bra     OSB_plpplaSECSEV

                .dd1    $a6
                .dd1    $ea
                .dd1    $4c
                .dd1    $20
                .dd1    $e8

OSB_plpplaSECSEV plp
                pla
                sep     #$41
                rts

                .dd1    $60

enterOSWORD_BHA sep     #$30
                phx                       ;caller's A - TODO: pointless push here? Check if to align with OSBYTE entry?
                php
                sei
                sta     <DPSYS_OSB_X
                xba
                sta     <DPSYS_OSB_Y
                phb
                pla
                sta     <DPSYS_OSB_A
                txa
                pea     DPSYS
                pld
                .dbank  $00
                pea     $0000
                plb
                plb
                ldx     #$08
                cmp     #$e0
                bcc     LFEE85E
                brl     LFEE7ED           ;enter OSBYTE dispatcher with carry set to index into rest of table

LFEE85E         cmp     #$0e
                bcs     @exitNotImpl
                adc     #$4c
                asl     A
                bcs     OSBYTE_0_X
                brl     dispatchOSWORDinA

OSBYTE_0_X      ldx     #$00
                rts

********************************************************************************
* OSBYTE 0 - print OS version or return in X                                   *
********************************************************************************
OSBYTE_0        bne     OSBYTE_0_X
                brk     $f7

                .zstr   “Version 1.00 13/Nov/86 (C)1986”

TFEE890         ldy     #$00
                lda     SYSVARS+98
                bne     LFEE8DF
                lda     SYSVAR_SOUND_EXT_FLAG
                bne     LFEE8A1
                iny
                lda     [$ea],y
                cmp     #$20
LFEE8A1         ldx     #$08
                bcc     LFEE8A8
                brl     OSB_plaplaplpplaSECSEV

LFEE8A8         dey
                lda     [$ea],y
                jsr     LFEE941
                jsr     LFEE957
                ora     #$04
                tax
                bcc     LFEE8BB
                jsr     LFEDF34
                ldy     #$01
LFEE8BB         jsr     LFEE957
                sta     $f6
                php
                ldy     #$06
                lda     [$ea],y
                pha
                ldy     #$04
                lda     [$ea],y
                pha
                ldy     #$02
                lda     [$ea],y
                rol     A
                sec
                sbc     #$02
                asl     A
                asl     A
                ora     $f6
                jsr     LFEDFAB
                bcc     LFEE90B
                pla
                pla
                plp
LFEE8DF         rts

Serv8_QRY       pea     $0000
                plb
                plb
                lda     SYSVARS+98
                bne     LFEE8DF
                lda     SYSVAR_SOUND_EXT_FLAG
                beq     LFEE8F4
                ldx     #$16
                jmp     donothingRTS

LFEE8F4         php
                sei
                lda     SYSVARS+99
                jsr     LFEE941
                tax
                lda     SYSVARS+100
                jsr     callINSV
                lda     SYSVARS+102
                pha
                lda     SYSVARS+101
                pha
LFEE90B         sec
                ror     SOUND_QRY_T
                pla
                jsr     callINSV
                pla
                jsr     callINSV
                plp
                rts

TFEE919         ldx     SYSVARS+98
                bne     LFEE8DF
                ldx     SYSVAR_SOUND_EXT_FLAG
                beq     LFEE926
                brl     LFEE8A1

LFEE926         sbc     #$01
                asl     A
                asl     A
                asl     A
                asl     A
                ora     #$0f
                tax
                lda     #$00
                ldy     #$10
LFEE933         cpy     #$0e
                bcs     LFEE939
                lda     [$ea],y
LFEE939         sta     $a8c0,x
                dex
                dey
                bne     LFEE933
                rts

LFEE941         and     #$03
                ora     #$04
                cmp     SOUND_CUR_CHAN_QRY
                beq     LFEE956
                pha
                clc
                ldx     SOUND_CUR_CHAN_QRY
                sta     SOUND_CUR_CHAN_QRY
                jsr     LFEDF34
                pla
LFEE956         rts

LFEE957         lda     [$ea],y
                cmp     #$10
                and     #$03
                iny
                rts

TFEE95F         ldx     #$0f
                bne     LFEE966

TFEE963         ldx     SYSVARS+131
LFEE966         ldy     #$04
LFEE968         lda     SYSVARS+140,x
                sta     [$ea],y
                inx
                dey
                bpl     LFEE968
LFEE971         rts

TFEE972         lda     #$0f
                bne     LFEE97C

TFEE976         lda     SYSVARS+131
                eor     #$0f
                clc
LFEE97C         pha
                tax
                ldy     #$04
LFEE980         lda     [$ea],y
                sta     SYSVARS+140,x
                inx
                dey
                bpl     LFEE980
                pla
                bcs     LFEE971
                sta     SYSVARS+131
                rts

********************************************************************************
* OSWORD 0 - readline                                                          *
* As per BBC - not sure what the implied bank for the pointer in the block is  *
********************************************************************************
                .dbank  $00
OSWORD_0        ldy     #$04
; Copy bytes 2,3,4 to SYSVARS+B0 (different to BBC)
@lp             lda     [<DPSYS_OSB_X],y
                tyx                       ;TODO - remove
                sta     SYSVARS_OSWORD_0_PARMS-2,x ;TODO - use Y here
                dey
                cpy     #$02
                bcs     @lp
; store the address pointer in DP
                lda     [<DPSYS_OSB_X],y
                sta     <DPSYS_OSWORD0_BUFPTR+1
                dey
                sty     DPSYS_PAGEMODE_CTR-$700 ;Y is zero here; TODO: use STZ
                lda     [<DPSYS_OSB_X],y
                sta     <DPSYS_OSWORD0_BUFPTR
                cli
                bra     @loop

@OSW0_BELL      lda     #VDU_07_BELL      ;beep and go round the loop without incrementing Y
                dey
@OSW0_inyecho   iny
@badcharNoInc   ldx     DPSYS_D8_B_SAV
                phx                       ;TODO: pointless push - OPWRC preserves all regs
                cop     COP_00_OPWRC
                plx
                stx     DPSYS_D8_B_SAV
@loop           ldx     DPSYS_D8_B_SAV
                phx
                cop     COP_04_OPRDC      ;read char from input stream
                plx
                stx     DPSYS_D8_B_SAV
                bcs     @ESC_ret          ;ESCape
                tax
                lda     SYSVARS_7C_OUTDEST
                ror     A
                ror     A                 ;rotate twice to see if output disabled
                txa                       ;restore A
                bcs     @novdu            ;if VDU disabled skip forward
                ldx     SYSVAR_VDU_QLEN
                bne     @badcharNoInc     ;if there's stuff in the VDU Q just output the char and continue
@novdu          cmp     #VDU_7F_BKSP
                bne     @notbksp
                cpy     #$00
                beq     @loop             ;if zero just loop around
                dey                       ;decrement pointer
                bcs     @badcharNoInc     ;always branch round - TODO: change to more meaningful BRA
@notbksp        cmp     #VDU_15_DELLN
                bne     @storeInBuf
                tya                       ;check pointer for 0
                beq     @loop             ;nothing in current line got back to reading
                lda     #VDU_7F_BKSP
@dellnlp        cop     COP_00_OPWRC
                dey
                bne     @dellnlp
                beq     @loop

@storeInBuf     phb                       ;preserve our Bank
                xba                       ;preserve A (char to store)
                lda     DPSYS_D8_B_SAV    ;get dest bank
                pha
                plb
                xba                       ;get back A
                sta     (<DPSYS_OSWORD0_BUFPTR),y
                plb                       ;back to our bank
                cmp     #VDU_0D_CR        ;check for EOL
                beq     @newlClcRet
                cpy     SYSVARS_OSWORD_0_PARMS
                bcs     @OSW0_BELL        ;too long - beep
                cmp     SYSVARS_OSWORD_0_PARMS+1
                bcc     @badcharNoInc     ;bad char silently store in buffer no increment
                cmp     SYSVARS_OSWORD_0_PARMS+2
                beq     @OSW0_inyecho
                bcc     @OSW0_inyecho
                bcs     @badcharNoInc

@newlClcRet     cop     COP_03_OPNLI
                clc
@ESC_ret        tax
                rts

                .dd1    $58
                .dd1    $78
                .dd1    $da
                .dd1    $a9
                .dd1    $00
                .dd1    $eb
                .dd1    $a9
                .dd1    $03
                .dd1    $a2
                .dd1    $02
                .dd1    $22
                .dd1    $b0
                .dd1    $ff
                .dd1    $00
                .dd1    $fa
                .dd1    $90
                .dd1    $3e
                .dd1    $2c
                .dd1    $c6
                .dd1    $a5
                .dd1    $10
                .dd1    $ea
                .dd1    $20
                .dd1    $16
                .dd1    $df
                .dd1    $a0
                .dd1    $00
                .dd1    $84
                .dd1    $eb
                .dd1    $86
                .dd1    $ea
                .dd1    $20
                .dd1    $b6
                .dd1    $e7
                .dd1    $a9
                .dd1    $05
                .dd1    $09
                .dd1    $f0
                .dd1    $80
                .dd1    $0d
                .dd1    $d0
                .dd1    $07
                .dd1    $a2
                .dd1    $32
                .dd1    $48
                .dd1    $a9
                .dd1    $03
                .dd1    $aa
                .dd1    $68
                .dd1    $60

OSBYTE_4        clc
                adc     #$e9              ;TODO: make this relative to SYSVARS/VDUVARS
                stx     <DPSYS_OSB_X      ;TODO: suspect this is superfluous?
OSBYTE_A6_FF    cmp     #$dd
                bcc     @sk1
                cmp     #$e5
                bcc     @skDDtoE4
@sk1            tay
                lda     SYSVARS-112,y
                tax
                and     <DPSYS_OSB_Y
                eor     <DPSYS_OSB_X
                sta     SYSVARS-112,y
                lda     SYSVARS-111,y
                tay
                rts

@skDDtoE4       jsr     OSBYTE_DDtoE4     ;;TODO: replace with jump
                rts

                .dd1    $49
                .dd1    $8c
                .dd1    $0a
                .dd1    $8d
                .dd1    $47
                .dd1    $a5
                .dd1    $60

********************************************************************************
* OSBYTE 13 (19) - Wait for Vsync                                              *
********************************************************************************
                .dbank  $00
OSBYTE_13       lda     SYSVAR_CFS_TIMEOUT
@lp             cli
                sei
                cmp     SYSVAR_CFS_TIMEOUT
                beq     @lp
                rts

********************************************************************************
* OSBYTE 12 - Reset Soft Key Definitions                                       *
********************************************************************************
OSBYTE_12       jsr     OSB_ResetFnKeys
                rts

                .rwid   longm,longx
LFEEA7B         php
                rep     #$30
                lda     #$0000
                tay
                ldx     #$003a
                phk
                jsr     callModVDU
                plp
                rts

********************************************************************************
* OSBYTE 76 - reflect keyboard in LEDS                                         *
********************************************************************************
                .rwid   shortm,shortx
OSBYTE_76       php
                sei
                lda     #$40
                jsr     LFEEAB6
                bcs     LFEEA9E
                clc
                clv
                phx
                ldx     #$1c
                jsl     __KB
                plx
LFEEA9E         plp
                rol     A
                rts

********************************************************************************
* OSBYTE 78 - write key pressed data                                           *
********************************************************************************
OSBYTE_78       txy
                ldx     #$18
                jsl     __KB
                rts

LFEEAA9         xba
                phk
                lda     SYSVARS+33
                pha
                lda     SYSVARS+32
                pha
                xba
                php
                rti

LFEEAB6         bcc     @skCC
                pha
                lda     SYSVARS_ULA_MISC_COPY
                eor     #$c0
                stal    shiela_ULA_MISC
                eor     #$c0
                stal    shiela_ULA_MISC
                pla
@skCC           pha
                phx
                lda     #$00
                xba
                lda     #$03
                ldx     #$02
                jsl     __EV
                plx
                pla
                rts

                .dd1    $ad
                .dd1    $87
                .dd1    $a5
                .dd1    $49
                .dd1    $4c
                .dd1    $d0
                .dd1    $04
                .dd1    $5c
                .dd1    $87
                .dd1    $a5
                .dd1    $00
                .dd1    $60
                .dd1    $60
                .dd1    $2f
                .dd1    $21
                .dd1    $42
                .dd1    $4f
                .dd1    $2e
                .dd1    $0d

; QRY this appears to do a jump indirect to (f6) in DP setting flags Z if X==0
; and Cy=1
; 
; As this is called once in OSBYTE dispatch where DP is known why not just
; 
; CPX#0
; SEC
; JMP(ACF6)
callDP_F6_SEC_ZeqX phk
                phd
                pha
                xba
                pha
; +7  RETH
; +6  RETL
; +5  K
; +3  D
; +2  A
; +1  B
                lda     <DPSYS_OSB_IND+1
                sta     $04,S
                lda     <DPSYS_OSB_IND
                sta     $03,S
; +7  RETH
; +6  RETL
; +5  K
; +3  F6,F7
; +2  A
; +1  B
                pla
                xba
                pla
; +5  RETH
; +4  RETL
; +3  K
; +1  F6,F7
                cpx     #$00
                sec
                php
; +6  RETH
; +5  RETL
; +4  K
; +2  F6,F7
; +1  FLAGS with Cy=1, Z if X==0
                rti

; TODO - this looks dead as it will trip over the string
                ldx     #$09
                jsr     donothingRTS
                jsr     LFEEE0B_rts
                .zstr   $0d,“Version 1.00 13/Nov/86 (C)1986”
                rts

                dec     SYSVARS+73
                rts

                ldy     SYSVARS+68
                ldx     #$00
                rts

resetFlashCounters php
                sei
                ldx     #$00
                stx     SYSVAR_48_UNKNOWN_ULA
                lda     SYSVAR_FLASH_MARK
                sta     SYSVAR_51_FLASHCTDN
                ldx     #VDUMOD_OPX_14_FLASH_QRY
                phk
                jsr     callModVDU
                plp
                rts

                phb
                pea     $0000
                .dbank  $00
                plb
                plb
                lda     SYSVAR_SOUND_EXT_FLAG
                bne     LFEEB5C
                lda     SOUND_QRY_T
                beq     LFEEB5C
                jsr     LFEEB5E
LFEEB5C         plb
                rts

LFEEB5E         ldx     SOUND_CUR_CHAN_QRY
                lda     SYSVARS_ELK_BUFFER_BUSY,x
                bmi     LFEEB6B
                lda     SOUND_QRY_S
                bne     LFEEB6E
LFEEB6B         jsr     LFEEC5D
LFEEB6E         lda     SOUND_QRY_S
                beq     LFEEB84
                cmp     #$ff
                beq     LFEEB87
                dec     $a81c
                bne     LFEEB87
                jsr     LFEECDA
                dec     SOUND_QRY_S
                bne     LFEEB87
LFEEB84         jsr     LFEEC5D
LFEEB87         ldy     $a81d
                cpy     #$ff
                bne     LFEEB91
                brl     sound_QRY1

LFEEB91         lda     $a81e
                beq     LFEEB9E
                dec     $a81e
                beq     LFEEB9E
                brl     sound_QRY1

LFEEB9E         lda     $a819
                cmp     #$03
                beq     sound_QRY1
                lda     $a8c0,y
                and     #$7f
                sta     $a81e
                lda     SOUND_QRY_S-1
                bne     LFEEBDC
                inc     $a819
                lda     $a819
                cmp     #$03
                bne     LFEEBCC
                ldy     $a81d
                lda     $a8c0,y
                bmi     sound_QRY1
                lda     #$00
                sta     $a819
                jsr     LFEECEB
LFEEBCC         lda     $a819
                clc
                adc     $a81d
                tay
                lda     $a8c4,y
                sta     SOUND_QRY_S-1
                beq     sound_QRY1
LFEEBDC         dec     SOUND_QRY_S-1
                lda     $a81d
                clc
                adc     $a819
                tay
                lda     $a8c1,y
                beq     sound_QRY1
                clc
                adc     SOUND_STATUS_QRY-1
                jsr     LFEECEB
                .dbank  $00
sound_QRY1      lda     $e5               ;QRY E5?
                ora     SYSVARS+98        ;or with sound suppression status
                bne     @ret              ;if ne then exit
                php
                sei
                lda     SYSVARS_ULA_MISC_COPY
                and     #$f9
                ora     SOUND_STATUS_QRY
                cmp     SYSVARS_ULA_MISC_COPY
                beq     LFEEC10
                sta     SYSVARS_ULA_MISC_COPY
                stal    shiela_ULA_MISC
LFEEC10         plp
                lda     SOUND_TONE_QRY
                stal    sheila_UKA_TONE
LFEEC18         lda     SOUND_QRY_X
                beq     @ret
                lda     $e5
                bne     @ret
                txa
                pha
                inc     SOUND_CUR_CHAN_QRY-1
                ldx     SOUND_CUR_CHAN_QRY-1
                stal    sheila_UKA_TONE
                pla
                tax
@ret            rts

********************************************************************************
* OSBYTE 74                                                                    *
*                                                                              *
* Reset the sound system - Electron                                            *
********************************************************************************
OSBYTE_74       phb
                pea     $0000
                plb
                .dbank  $00
                plb
                ldx     #$04
                stx     SOUND_CUR_CHAN_QRY
@lp             jsr     SOUND_RESET_CHAN_X_QRY
                inx
                cpx     #$07
                bne     @lp
                plb
SOUND_RESET_CHAN_X_QRY phb
                pea     $0000
                plb
                .dbank  $00
                plb
                lda     #$00
                sta     SOUND_QRY_S
                sta     SYSVARS_ELK_BUFFER_BUSY,x
                sta     SOUND_QRY_T
                jsr     SOUND_CLR_QRY
                jsr     sound_QRY1
                plb
                rts

LFEEC5D         ldx     SOUND_CUR_CHAN_QRY
                jsr     SOUND_CLR_QRY
                lda     SYSVARS_ELK_BUFFER_BUSY,x
                beq     LFEEC70
                lda     #$00
                sta     SYSVARS_ELK_BUFFER_BUSY,x
                sta     SOUND_QRY_S
LFEEC70         jsr     OSBYTE_98
                bcc     LFEEC84
                php
                sei
                jsr     OSBYTE_98
                bcc     LFEEC81
                lda     #$00
                sta     SOUND_QRY_T
LFEEC81         plp
                bra     SOUND_CLR_QRY

LFEEC84         php
                sei
                jsr     OSBYTE_91
                pha
                and     #$04
                beq     LFEEC9C
                pla
                jsr     SOUND_CLR_QRY
                jsr     OSBYTE_91
                jsr     OSBYTE_91
                plp
                jmp     LFEECD7

LFEEC9C         lda     #$02
                sta     SOUND_STATUS_QRY
                pla
                and     #$f8
                asl     A
                bcc     LFEECB2
                cmp     #$f0
                bne     LFEECB0
                lda     #$00
                sta     SOUND_STATUS_QRY
LFEECB0         lda     #$ff
                .dbank  $00
LFEECB2         sta     $a81d
                ldy     #$01
                sty     $a81e
                dey
                sty     SOUND_QRY_S-1
                sty     SOUND_STATUS_QRY-1
                dey
                sty     $a819
                jsr     OSBYTE_91
                sta     $a818
                jsr     OSBYTE_91
                plp
                pha
                lda     $a818
                jsr     LFEECF2
                pla
LFEECD7         sta     SOUND_QRY_S
LFEECDA         lda     #$05
                sta     $a81c
                rts

SOUND_CLR_QRY   lda     #$00
                sta     SOUND_STATUS_QRY
LFEECE5         lda     #$00
LFEECE7         sta     SOUND_QRY_X
                rts

LFEECEB         sta     SOUND_STATUS_QRY-1
                clc
                adc     $a818
LFEECF2         pha
                and     #$03
                tax
                lda     SOUND_CUR_CHAN_QRY
                cmp     #$04
                bne     LFEED1E
                pla
                and     #$04
                beq     LFEED12
                phb
                phk
                .dbank  K (auto)
                plb
                lda     LFEED63 & $ffff,x
                stal    f:$00a823
                lda     LFEED6B & $ffff,x
                plb
                bra     LFEECE7

LFEED12         phb
                phk
                .dbank  K (auto)
                plb
                lda     LFEED67 & $ffff,x
                plb
                sta     $a821
                bra     LFEECE5

LFEED1E         inx
                lda     #$00
                sta     $a821
                pla
                lsr     A
                lsr     A
LFEED27         cmp     #$0c
                bcc     LFEED32
                inc     $a821
                sbc     #$0c
                bne     LFEED27
LFEED32         tay
                lda     $a821
                pha
                phb
                phk
                .dbank  K (auto)
                plb
                lda     0+(LFEED59 & $ffff)-2,y
                .dbank  $00
                plb
LFEED3E         cpy     #$07
                sbc     #$02
                dex
                bne     LFEED3E
                sta     SOUND_TONE_QRY
                pla
                tay
                beq     LFEED52
LFEED4C         lsr     SOUND_TONE_QRY
                dey
                bne     LFEED4C
LFEED52         dec     SOUND_TONE_QRY
                bne     LFEECE5
                brk     $f0

LFEED59         .dd1    $e3
                .dd1    $d6
                .dd1    $cb
                .dd1    $bf
                .dd1    $b5
                .dd1    $aa
                .dd1    $a0
                .dd1    $97
                .dd1    $8f
                .dd1    $87
LFEED63         .dd1    $40
                .dd1    $80
                .dd1    $c0
                .dd1    $80
LFEED67         .dd1    $3b
                .dd1    $76
                .dd1    $f0
                .dd1    $76
LFEED6B         .dd1    $7f
                .dd1    $ff
                .dd1    $ff
                .dd1    $ff
                .dd1    $60
                .dd1    $02
                .dd1    $0f
                .dd1    $75
                .dd1    $73
                .dd1    $65
                .dd1    $20
                .dd1    $43
                .dd1    $4f
                .dd1    $50
                .dd1    $20
                .dd1    $6e
                .dd1    $6f
                .dd1    $74
                .dd1    $20
                .dd1    $63
                .dd1    $61
                .dd1    $6c
                .dd1    $6c
                .dd1    $20
                .dd1    $74
                .dd1    $6f
                .dd1    $20
                .dd1    $61
                .dd1    $62
                .dd1    $73
                .dd1    $6f
                .dd1    $6c
                .dd1    $75
                .dd1    $74
                .dd1    $65
                .dd1    $20
                .dd1    $61
                .dd1    $64
                .dd1    $64
                .dd1    $72
                .dd1    $65
                .dd1    $73
                .dd1    $73
                .dd1    $00

default__OSB    cop     COP_06_OPOSB
                rtl

default__OSW    cop     COP_07_OPOSW
                rtl

                .rwid   longx
default__BGET   cop     COP_0A_OPBGT
                rts

                .rwid   shortx
default__BPUT   cop     COP_0B_OPBPUT
                rts

syserrorTestEsc cop     COP_0F_OPERR
                .zstr   “use TESTESC in $.I.SYSTEM not XXOSESC”
********************************************************************************
* FFB0 - EV - ????                                                             *
*                                                                              *
* Well known entry point not documented in Systems Documentation               *
*                                                                              *
* Given an even mask in A test escape/preempt status                           *
********************************************************************************
default__EV     php
                rep     #$20
                .rwid   longm
                pha
                and     #$00fc
                beq     @ok
                cop     COP_0F_OPERR
                .zstr   “invalid A contents in call to `EV”
@ok             pla
                andl    f:SYS_ESCAPE_FLAG_QRY
                cmp     #__EVESC
                bcc     @retCCPL
                plp
                .rwid   shortm
                sep     #$81
                rtl

                .rwid   longm
@retCCPL        plp
                .rwid   shortm
                clc
                rep     #$81
                rtl

; TODO: dead code?
LFEEE0B_rts     rts

starEXEC        ldx     #$0c              ;GSINIT
                jsl     __ST
                bra     closeEXEC2

********************************************************************************
* OSBYTE 77 - close all EXEC / SPOOL files                                     *
********************************************************************************
OSBYTE_77       sec
closeEXEC2      php
                rep     #$10
                .rwid   longx
                sep     #$20
                php
                phy
                ldx     #$0000
                ldy     <DPSYS_D1_EXEC_handle
                stx     <DPSYS_D1_EXEC_handle
                beq     LFEEE27
                cop     COP_45_OPCLS
LFEEE27         ply
                plp
                bcs     LFEEE3E
                ldx     #$001c
                jsl     __ST              ;Get BHA pointer to first character of filename
                ldy     #$0040
                cop     COP_44_OPOPN
                bcc     LFEEE3C
                ldy     #$0000
LFEEE3C         sty     <DPSYS_D1_EXEC_handle
LFEEE3E         bcc     LFEEE43
                plp
                sec
                rts

LFEEE43         plp
                clc
                rts

                .rwid   shortx
LFEEE46         rts

donothingRTS    rts

LFEEE48         brl     LFEEE54           ;todo: remove?

                .rwid   longm,longx
brlFindModule   brl     findModule        ;todo: remove?

brlGetModCallRef brl    getModCallRef     ;todo: remove?

LFEEE51         brl     getOrCreateModCallBlock ;todo: remove?

                .rwid   shortm,shortx
LFEEE54         php
                phd
                phb
                rep     #$30
                .rwid   longm,longx
                pea     $0000
                phk
                phk
                pea     LFEAE00 & $ffff
                per     LFEF0E4
                tsc
                tcd
                plx
                phx
                phk
                .dbank  K (auto)
                plb
                bpl     LFEEE6F
                ldx     #$f0ea
LFEEE6F         jsr     LFEEF9D
                ldal    f:B0LST_MODULES_QRY
                tax
                ldal    f:DPCOP_B,x
                beq     LFEEE89
                tay
                jsr     LFECEDA
                ldal    f:B0LST_MODULES_QRY
                stal    f:DPCOP_DP,x
LFEEE89         lda     #$0000
                sta     DPCOP_X
                sta     DPCOP_AH
                plx
                phx
                lda     a:$0004,x
                sta     DPCOP_B
                lda     a:$0002,x
                sta     DPCOP_X+1
                cmp     #$0100
                bcs     LFEEEBE
                phb
                tay
                ldx     #$000e
                jsl     __MM
                phb
                pha
                plb
                pla
                sta     DPCOP_X+1
                ldx     #$0012
                jsl     __MM
                phb
                pha
                plb
                pla
                sta     DPCOP_B
                plb
LFEEEBE         jsr     LFEEF2D
                bcs     LFEEEF3
                plx
                phx
                jsr     LFEEF9D
                phb
                cop     COP_26_OPBHA
                .zstr   “MOS”
                ldx     #$0000
                txy
                cop     COP_34_OPRMI
                bcs     LFEEEEB
                phb
                phb
                pha
                per     LFEAE00
                pla
                cmp     $01,S
                bne     LFEEEEE
                phk
                phk
                pla
                cmp     $03,S
                bne     LFEEEEE
                pla
                pla
LFEEEEB         plb
                bra     LFEEEBE

LFEEEEE         ldx     #$0002
                php
                rti

LFEEEF3         plx
                phx
                lda     a:$0000,x
                dec     A
                eor     #$ffff
                and     DPCOP_X
                clc
                adc     a:$0000,x
                sta     DPCOP_X
                lda     DPCOP_AH
                adc     #$0000
                sta     DPCOP_AH
                bit     #$ff00
                bne     LFEEF16
                lda     DPCOP_X+1
                cmp     DPCOP_B
                bcc     LFEEEBE
LFEEF16         pla
                clc
                adc     #$0006
                pha
                tax
                lda     a:$0000,x
                beq     LFEEF25
                brl     LFEEE89

LFEEF25         pld
                pld
                pld
                pld
                plb
                pld
                plp
                rtl

LFEEF2D         ldy     #$0000
                lda     [DPCOP_X],y
                and     #$00ff
                cmp     LFEF0E1 & $ffff
                beq     LFEEF3D
                brl     LFEEF9B

LFEEF3D         ldy     #$0005
                lda     [DPCOP_X],y
                and     #$00ff
                bne     LFEEF9B
                ldy     #$0003
                lda     [DPCOP_X],y
                sec
                sbc     #$0003
                bcc     LFEEF9B
                ldy     #$0001
                cmp     [DPCOP_X],y
                bcc     LFEEF9B
                ldy     #$000e
                lda     [DPCOP_X],y
                jsr     checkValidModnameChar
                bcs     LFEEF9B
LFEEF63         lda     [DPCOP_X],y
                and     #$00ff
                beq     LFEEF74
                jsr     LFEF0BF
                bcs     LFEEF9B
                iny
                beq     LFEEF9B
                bra     LFEEF63

LFEEF74         tya
                ldy     #$0003
                cmp     [DPCOP_X],y
                bcs     LFEEF9B
                ldy     #$0003
                lda     [DPCOP_X],y
                clc
                adc     DPCOP_X
                adc     #$0002
                bcs     LFEEF9B
                ldy     #$0003
                lda     [DPCOP_X],y
                tay
                phb
                pei     (DPCOP_X+1)
                plb
                plb
                pei     (DPCOP_X)
                pla
                cop     COP_32_OPSUM
                plb
                rts

LFEEF9B         sec
                rts

LFEEF9D         jsr     LFEF067
                bcc     LFEEFA5
                brl     LFEF03D

LFEEFA5         pha
                lda     a:$0002,x
                cmp     #$0100
                ldy     #$0000
                bcs     LFEEFD1
                phd
                phb
                ldy     #$0003
                lda     [DPCOP_X],y
                pha
                inc     A
                inc     A
                lda     a:$0002,x
                tay
                pei     (DPCOP_X+1)
                plb
                plb
                lda     DPCOP_X
                pld
                ldx     #$0004
                jsl     __MM
                plb
                pld
                bcs     LFEF03D
LFEEFD1         plx
                beq     LFEEFE9
                ldal    f:DPCOP_B,x
                beq     LFEEFE6
                phx
                phy
                tay
                ldx     #$0002
                jsl     __MM
                ply
                plx
LFEEFE6         sec
                bra     LFEEFF1

LFEEFE9         lda     #$000c
                jsr     LFECE01
                bcs     LFEF033
LFEEFF1         lda     DPCOP_X+1
                stal    f:DPCOP_AH,x
                lda     DPCOP_X
                stal    f:DPCOP_X+1,x
                tya
                stal    f:DPCOP_B,x
                bcs     LFEF030
                phb
                phx
                ldal    f:DPCOP_AH,x
                pha
                plb
                plb
                ldal    f:DPCOP_X+1,x
                clc
                adc     #$000e
                ldx     #$0000
                ldy     #$0000
                phk
                jsr     LFEF231
                tyx
                ldal    f:$000000,x
                plx
                stal    f:$000000,x
                txa
                tyx
                stal    f:$000000,x
                plb
LFEF030         clc
                bra     LFEF03E

LFEF033         tya
                beq     LFEF03D
                ldx     #$0002
                jsl     __MM
LFEF03D         sec
LFEF03E         php
                ldy     #$0003
                lda     [DPCOP_X],y
                clc
                adc     DPCOP_X
                pha
                iny
                iny
                lda     [DPCOP_X],y
                and     #$00ff
                adc     DPCOP_AH
                sta     DPCOP_AH
                pla
                sta     DPCOP_X
                lda     DPCOP_X
                clc
                adc     #$0002
                sta     DPCOP_X
                lda     DPCOP_AH
                adc     #$0000
                sta     DPCOP_AH
                plp
                rts

LFEF067         php
                phd
                phb
                phx
                pea     0+(LFEFE0C & $ffff)+2
                .rwid   shortm
LFEF06E         rep     #$20
                .rwid   longm
                plx
                ldal    f:$000000,x
                cmp     #$fe0e
                beq     LFEF0B3
                pha
                jsr     getModCallBlock
                tcd
                sep     #$20
                .rwid   shortm
                lda     $11,S
                pha
                plb
                ldy     #$000d
LFEF088         iny
                lda     [$00],y
                jsr     checkValidModnameChar
                bcs     LFEF098
                eor     ($0f,S),y
                and     #$df
                bne     LFEF06E
                bra     LFEF088

LFEF098         lda     ($0f,S),y
                jsr     checkValidModnameChar
                bcc     LFEF06E
                ldy     #$0006
                rep     #$20
                .rwid   longm
                lda     [$00],y
                cmp     ($0f,S),y
                sep     #$20
                .rwid   shortm
                bcc     LFEF0B6
                pld
                plx
                plb
                pld
                plp
                .rwid   longm
                sec
                rts

LFEF0B3         pea     $0000
                .rwid   shortm
LFEF0B6         rep     #$20
                .rwid   longm
                pla
                plx
                plb
                pld
                plp
                clc
                rts

LFEF0BF         cmp     #$002c
                bcc     LFEF0DD
                cmp     #$003a
                bcc     LFEF0DF
                cmp     #$0040
                bcc     LFEF0DD
                cmp     #$005b
                bcc     LFEF0DF
                cmp     #$0061
                bcc     LFEF0DD
                cmp     #$007b
                bcc     LFEF0DF
LFEF0DD         sec
                rts

LFEF0DF         clc
                rts

LFEF0E1         .dd1    $82
                .dd1    $00
                .dd1    $00
LFEF0E4         .dd1    $00
                .dd1    $01
                .dd1    $01
                .dd1    $00
                .dd1    $00
                .dd1    $00
LFEF0EA         .dd1    $00
                .dd1    $01
                .dd1    $00
                .dd1    $80
                .dd1    $ff
                .dd1    $ff
                .dd1    $00
                .dd1    $00

getModCallRef   php
                phd
                rep     #$30
                phk
                jsr     findModule
                bcs     @retsec
                phk
                jsr     getOrCreateModCallBlock
                bcs     @retsec
                tax
                sep     #$20
                .rwid   shortm
                ldal    f:$000007,x       ;increment module reference count by 1
                inc     A
                bne     @ok
                cop     COP_0F_OPERR      ;panic if mod ref >= 255
                .zstr   “Use Count Overflow”
@ok             stal    f:DPCOP_B,x
                rep     #$20
                .rwid   longm
                txa
                pld
                plp
                clc
                rtl

@retsec         pld
                plp
                sec
                rtl

; 
; Entry:  BHA is pointer to module name
;         Y is either 0 or required version number
; 
; Exit:   CC for found, pointer to module list entry in X
;         CS, X=-1 for not found
findModule      php
                phd
                rep     #$30
                pea     $ffff             ;this looks to be the return value, -1 means not found
                phy
                phb
                phb
                pha                       ;push BHA pointer
                pea     B0LST_MODULES_QRY
                lda     $03,S             ;back off stacked BHA by 14 TODO:why not do this before pushing!?
                sec
                sbc     #$000e
                sta     $03,S
                lda     $05,S
                sbc     #$0000
                sta     $05,S
@modsrchlp      plx                       ;get back list pointer
                ldal    f:$000000,x
                cmp     #B0LST_MODULES_QRY
                beq     @unstackExit      ;if at head of list exit
                pha
                jsr     getModCallBlock
                tax
                ldy     #$000d
@strmatchlp     iny
                beq     @modsrchlp
                tsc
                tcd
                lda     [$03],y           ;get character from stacked long BHA-14 pointer
                jsr     checkValidModnameChar ;check it's a valid module name char
                phx
                pld                       ;point to current module name in list
                bcs     @skend            ;end of string
                eor     [$00],y           ;check for equality
                and     #$00df
                bne     @modsrchlp        ;no match, next module please
                bra     @strmatchlp

@skend          lda     [$00],y           ;we got to the end of the passed in string
                jsr     checkValidModnameChar ;were we at the end of the module string?
                bcc     @modsrchlp        ;no, next module...
                lda     $07,S             ;retrieve passed in Y
                beq     @checkVerGt
                ldy     #$0006
                lda     [$00],y           ;get module version number
                cmp     $07,S             ;compare with passed in Y
                bne     @modsrchlp        ;doesn't match, next module
@setWinner      pla                       ;get back list entry pointer
                pha
                sta     $09,S             ;store in return value
                bra     @modsrchlp        ;keep going - why TODO: check if this happens, document?

@checkVerGt     lda     $09,S             ;get return value
                cmp     #$ffff            ;has it been set already?
                beq     @setWinner        ;if it hasn't set current as result
                jsr     getModCallBlock
                tcd
                ldy     #$0006
                lda     [$00],y           ;get winner's version
                pha                       ;save it
                lda     $03,S             ;get current module list entry
                jsr     getModCallBlock   ;get module pointer
                tcd
                lda     [$00],y           ;get current module version number
                and     #$00ff            ;mask off low part?!?!?
                cmp     $01,S             ;compare
                pla                       ;discard pushed
                bcc     @modsrchlp
                bra     @setWinner

@unstackExit    pld
                pld
                pld
                pla
                cmp     #$ffff            ;check for winner
                pld
                bcs     @retsec
                plp
                clc
                rtl

@retsec         plp
                sec
                rtl

getModCallBlock phd
                clc
                adc     #$0004            ;HA+=4
                tcd                       ;DP=HA
                lda     $02               ;HA=[DP,2]
                and     #$00ff
                sec
                bne     @ret
                lda     $00
                tax
                clc
                adc     #$0002
                tcd
                clc
@ret            tdc
                pld
                rts

getOrCreateModCallBlock jsr getModCallBlock
                bcc     @retTxa
                phd
                tcd
                lda     #$0006
                jsr     LFECE01
                bcs     @ret
                lda     #$0000
                sep     #$20
                .rwid   shortm
                stal    f:$000007,x       ;refernce count
                rep     #$20
                .rwid   longm
                stal    f:$000008,x       ;QRY what is at offset 8
                phk
                .dbank  K (auto)
                plb
                lda     templateModCallBlock & $ffff ;get phd, jsl opcodes
                stal    f:$000000,x       ;store at offset 0
                lda     0+(templateModCallBlock & $ffff)+5 ;get pld, rtl opcodes
                stal    f:$000005,x       ;store at offset 5
                lda     $01               ;get program bank and high byte of module service
                stal    f:$000003,x       ;store at offset 3
                lda     $00               ;get 16 bit low address of module
                stal    f:$000002,x       ;store at offset 2
                stz     $01
                stx     $00               ;store DPX at 0 - QRY why?
                pld
@retTxa         txa
@ret            rtl

; This is a template module call that is copied to Bank 0 when a module is first
; referenced
                .rwid   shortm,shortx
templateModCallBlock phd
                jsl     $000000
                pld
                rtl

                brl     LFEF231

                brl     LFEF372

                .rwid   longm,longx
brlFindModuleByAddress brl findModuleByAddress

LFEF22E         brl     LFEF2B7

                .rwid   shortm,shortx
LFEF231         phd
                phx
                phy
                pea     0+(LFEFE0C & $ffff)+2
                pea     $0000
                pea     $0000
                phb
                pha
                phd
                phd
                tsc
                inc     A
                tcd
                lda     $0f
                bne     LFEF24F
                ldx     #$0e
                inc ▼   a:$00bf,x
LFEF24B         ldal ▼  f:$000000,x
                brk     $00

LFEF24F         cmp     #$0e
                inc ▼   $3ff0,x
                .rwid   longm,longx
                beq     LFEF293
                .rwid   shortm,shortx
                tax
                phk
                jsr     LFEF2B7
                phk
                jsr     LFEF2E7
                bvs     LFEF267
                rol     DPCOP_DP+1
                ror     DPCOP_DP+1
                bne     LFEF267
                stx     DPCOP_PC
LFEF267         bcs     LFEF28F
                cpy     #$00
                brk ▼   $d0

                .rwid   longm,longx
                bne     LFEF276
                sta     DPCOP_B
                stx     DPCOP_DP+1
                sty     DPCOP_PC
                bra     LFEF293

LFEF276         rol     DPCOP_K
                ror     DPCOP_K
                beq     LFEF28F
                rol     DPCOP_DP+1
                ror     DPCOP_DP+1
                beq     LFEF289
                lda     #$ffff
                sta     DPCOP_DP+1
                bra     LFEF28F

LFEF289         sta     DPCOP_B
                stx     DPCOP_DP+1
                sty     DPCOP_PC
                .rwid   shortm,shortx
LFEF28F         lda     $0f
                beq     LFEF24B
LFEF293         lda     DPCOP_DP+1
                sec
                beq     LFEF2A0
                inc     A
                beq     LFEF29D
                bra     LFEF29F

LFEF29D         stz     DPCOP_DP+1
LFEF29F         clc
LFEF2A0         pld
                pld
                pla
                php
                clc
                adc     $03,S
                bcc     LFEF2AE
                plp
                plx
                inx
                phx
                php
LFEF2AE         plp
                plb
                pld
                plx
                ply
                pld
                pld
                pld
                rtl

LFEF2B7         phx
                ldal    f:DPCOP_X+1,x
                sta     $00
                sep     #$20
                ldal    f:DPCOP_AH+1,x
                sta     DPCOP_Y+1
                rep     #$20
                .rwid   longm
                and     #$00ff
                sec
                bne     LFEF2E5
                ldal    f:DPCOP_X+1,x
                tax
                ldal    f:DPCOP_Y+1,x
                sta     $00
                sep     #$20
                .rwid   shortm
                ldal    f:DPCOP_X+1,x
                sta     DPCOP_Y+1
                rep     #$20
                .rwid   longm
                txa
                clc
LFEF2E5         plx
                rtl

                .rwid   longx
LFEF2E7         ldy     #$000e
                jsr     LFEF343
; Action: This call checks a list of names to see if a specific name is present.
; If it is then the offset of the name from the start of the list is given in Y.
; 
; On entry: The 4 byte address at D,0 points to the start of the name list.
;           The 4 byte address at D,4 points to the name to be located.
;           If Y = 0 then the slash "/" character is used as a delimiter.
;           If Y <> 0 then the character whose ASCII code is in Y is used as 
;           a delimiter.
; On exit:  If C = 0 then the name is in the list at offset Y from the start 
;           If C = 1 then the name is not in the list
;           No registers preserved
doNameSearch    phx
                phy
                ldx     #$0000
                txy
LFEF2F3         inx
                dex
                bne     LFEF2F9
                sep     #$40
LFEF2F9         lda     [$00],y
                jsr     LFEF4DE
                bcs     LFEF30A
                eor     [DPCOP_X+1],y
                and     #$00df
                bne     LFEF317
                iny
                bra     LFEF2F9

LFEF30A         lda     [DPCOP_X+1],y
                jsr     LFEF4DE
                bcc     LFEF331
                tya
                txy
                clc
                plx
                plx
                rtl

LFEF317         lda     [DPCOP_X+1],y
                jsr     LFEF4DE
                bcs     LFEF32C
                and     #$00df
                pha
                lda     [$00],y
                and     #$00df
                cmp     $01,S
                pla
                bcs     LFEF331
LFEF32C         inx
                dex
                bne     LFEF331
                clv
LFEF331         lda     $01,S
                jsr     LFEF35E
                cmp     #$0000
                beq     LFEF33F
                inx
                inx
                bra     LFEF2F3

LFEF33F         sec
                plx
                plx
                rtl

LFEF343         pha
                php
                tya
                clc
                adc     $00
                sta     $00
                sep     #$20
                .rwid   shortm
                lda     #$00
                adc     DPCOP_Y+1
                sta     DPCOP_Y+1
                rep     #$20
                .rwid   longm
                ldy     #$0000
                plp
                pla
                rts

LFEF35B         lda     #$0000
LFEF35E         pha
                bra     LFEF362

LFEF361         iny
LFEF362         lda     [$00],y
                jsr     LFEF4DE
                bcc     LFEF361
                iny
                jsr     LFEF343
                ply
                ldy     #$0000
                rts

                .rwid   shortm,shortx
LFEF372         php
                phd
                rep     #$30
                .rwid   longm,longx
                phb
                pha
                phb
                pha
                tsc
                inc     A
                tcd
                ldy     #$0000
                jsr     LFEF35B
                ldx     #$0000
                cmp     #$002f
                bne     LFEF3A4
                pla
                plb
                phb
                pha
                ldx     #$0000
                ldy     #$0000
                phk
                jsr     LFEF231
                bcc     LFEF39E
                brl     @reterrModNotFound

LFEF39E         txa
                bne     LFEF3A4
                brl     @reterrCommandError

LFEF3A4         jsr     LFEF475
                pla
                plb
                phb
                pha
                ldy     #$0001
                phk
                jsr     LFEF231
                bcc     LFEF3B7
                brl     @retSev

LFEF3B7         txa
                bne     LFEF3BD
                brl     @reterrAmbiuousCommand

LFEF3BD         phx
                phy
                txa
                phk
                jsr     getOrCreateModCallBlock
                ldy     #$0000
                jsr     LFEF35B
                cmp     #$002f
                bne     LFEF3D2
                jsr     LFEF35B
LFEF3D2         lda     $00
                cmp     #$0001
                dec     $00
                bcs     LFEF3E1
                sep     #$20
                .rwid   shortm
                dec     DPCOP_Y+1
                rep     #$20
                .rwid   longm
LFEF3E1         ply
                plx
                lda     [$00]
                and     #$00ff
                cmp     #$0021
                bcs     LFEF411
                pla
                plb
                phb
                pha
                phk
                pea     LFEF40C & $ffff
                phb
                pha
                phk
                jsr     LFEF2B7
                bcs     @plaplberrCommandError
                tax
                sep     #$20
                .rwid   shortm
                lda     #$00
                sta     $03,S
                rep     #$20
                .rwid   longm
                pla
                phx
                ldx     #$0000
                php
LFEF40C         rti

                .rwid   shortm,shortx
                rep     #$30
                .rwid   longm,longx
                bra     LFEF459

LFEF411         jsr     LFEF475
@retSev         sep     #$40
                bra     @popsandret

@reterrModNotFound cop  COP_26_OPBHA
                .zstr   “Module not found”
                bra     @xeq1retsec

@reterrAmbiuousCommand cop COP_26_OPBHA
                .zstr   “Ambiguous command”
                bra     @xeq1retsec

@plaplberrCommandError pla
                plb
@reterrCommandError cop COP_26_OPBHA
                .zstr   “Command error”
@xeq1retsec     ldx     #$0001
                sec
LFEF459         clv
@popsandret     pld
                pld
                pld
                pld
                bcc     @retClcSev
                bvc     @retsecclv
                plp
                sep     #$41
                rtl

@retsecclv      plp
                sec
                clv
                rtl

@retClcSev      bvc     @retClcClv
                plp
                clc
                sep     #$40
                rtl

@retClcClv      plp
                clc
                clv
                rtl

LFEF475         lda     DPCOP_X
                sta     $00
                sep     #$20
                .rwid   shortm
                lda     DPCOP_AH
                sta     DPCOP_Y+1
                rep     #$20
                .rwid   longm
                rts

findModuleByAddress phd
                phd
                phd
                phb
                phb
                pha
                phb
                pha
                tsc
                inc     A
                tcd
                ldx     #$fe0e
                .rwid   shortm
LFEF490         rep     #$20
                .rwid   longm
                ldal    f:$000000,x
                ldx     #$0000
                cmp     #$fe0e
                beq     LFEF4D6
                tax
                phk
                jsr     LFEF2B7
                sep     #$20
                .rwid   shortm
                sec
                lda     DPCOP_X
                sbc     $00
                sta     DPCOP_B
                lda     DPCOP_X+1
                sbc     DPCOP_Y
                sta     DPCOP_DP
                lda     DPCOP_AH
                sbc     DPCOP_Y+1
                sta     DPCOP_DP+1
                bcc     LFEF490
                ldy     #$0003
                lda     [$00],y
                sbc     DPCOP_B
                iny
                lda     [$00],y
                sbc     DPCOP_DP
                iny
                lda     [$00],y
                sbc     DPCOP_DP+1
                bcc     LFEF490
                rep     #$20
                .rwid   longm
                ldy     #$000e
                jsr     LFEF343
                clc
LFEF4D6         pla
                plb
                pld
                pld
                pld
                pld
                pld
                rtl

LFEF4DE         and     #$00ff
                pha
                lda     $05,S
                cmp     #$0001
                pla
                bcc     checkValidModnameChar
                cmp     #$0000
                beq     LFEF4F5
                cmp     $03,S
                beq     LFEF4F5
                clc
                rts

LFEF4F5         sec
                rts

; Check if the character passed in A is in '!', '.', '0'..'9', 'A'..'Z',
; 'a'..'z'
                .rwid   shortm
checkValidModnameChar php
                rep     #$20
                .rwid   longm
                and     #$00ff
                cmp     #‘{’
                bcs     @retsec
                cmp     #‘a’
                bcs     @retCLC
                cmp     #‘[’
                bcs     @retsec
                cmp     #‘A’
                bcs     @retCLC
                cmp     #‘:’
                bcs     @retsec
                cmp     #‘0’
                bcs     @retCLC
                cmp     #‘.’
                beq     @retCLC
                cmp     #‘!’
                beq     @retCLC
@retsec         plp
                .rwid   shortm
                sec
                rts

                .rwid   longm
@retCLC         plp
                .rwid   shortm
                clc
                rts

                .rwid   longm
LFEF52B         pha
                txa
                lsr     A
                bcs     LFEF53B
                pla
                cop     COP_26_OPBHA
                .zstr   “Error”
                sec
                rtl

LFEF53B         pla
                sec
                rtl

********************************************************************************
* Given a Handle in Y returns details - QRY - what details                     *
*                                                                              *
* On Entry:                                                                    *
*    Y   A file handle                                                         *
*                                                                              *
* On Exit:                                                                     *
*    C=0 The file handle was found                                             *
*    V=1 if the file handle was an odd number QRY - what is the significance?  *
*    X   pointer to filing system module entry point in B0 - QRY check this    *
*    Y   file handle with bottom bit cleared                                   *
*                                                                              *
* or C=1 The file handle was not found of not of type file                     *
*    X=1                                                                       *
*    BHA An error string                                                       *
********************************************************************************
getFileHandleInfo pha                     ;save through routine (unless there's an error)
                tya                       ;get bottom bit of Y into V and clear
                lsr     A
                php
                asl     A
                plp
                tay
                tax
                clv
                bcc     @nosev
                sep     #$40
@nosev          cpx     #$0100            ;check handle validity
                bcc     @err_badHandle
                ldal    f:HND_off_B_type,x ;get handle block type
                and     #$00ff
                cmp     #HND_type_10_file ;check it's a file
                bne     @err_unknown_handle
                ldal    f:HNDFILE_off_module,x ;get offset 3 QRY - what is this?
                tax                       ;return in X
                pla                       ;restore A
                clc
                rtl

@err_badHandle  cop     COP_26_OPBHA
                .zstr   “Bad handle (top byte zero)”
                bra     @popXeq1retsec

@err_unknown_handle cop COP_26_OPBHA
                .zstr   “Bad handle (not known)”
@popXeq1retsec  plx
                ldx     #$0001
                sec
                rtl

doBGET          phk
                jsr     getFileHandleInfo
                bcs     @ret
                phk
                per     LFEFE63_anRTL
                pea     $0000
                .dbank  $00
                plb
                dex
                phx                       ;push the module jump pointer - 1 suitable for the RTL
                ldx     #FSOP_16_BGET
                bvc     @ret
                ldx     #FSOP_1A_BGET_odd
@ret            rtl

doBPUT          phk
                jsr     getFileHandleInfo
                bcs     @ret
                phk
                per     LFEFE63_anRTL     ;the module will return to here - QRY check this out, seems a bit convoluted!
                pea     $0000
                plb
                dex
                phx
                ldx     #FSOP_18_BPUT
                bvc     @ret
                ldx     #FSOP_1C_BPUT_odd
@ret            rtl

CheckEOF        phk
                jsr     getFileHandleInfo
                bcs     LFEF5E7
                phk
                per     LFEFE63_anRTL
                pea     $0000
                plb
                dex
                phx
                ldx     #FSOP_1E_CheckEOF
LFEF5E7         rtl

; QRY - dead code?
                .rwid   shortm,shortx
                rtl

; QRY - dead code?
                .rwid   longm,longx
                pha
                tya
                and     #$00ff
                tay
                pla
                phy
                ply
                bne     @sk2
                pha
                pla
                bne     @sk
                brl     LFEF7BA

@sk             tay
                brl     closeDevice

@sk2            phd
                tsx
                phd
                phd
                pea     $0000
                phd
                phd
                phd
                phd
                phy
                phb
                pha
                phx
                tsx
                phx
                pld
                phy
                phk
                jsr     LFEF828
                sty     __MMFND
                ply
                bcs     @errModuleNotFoundRestoreEnv
                sta     DPCOP_DP
                phb
                phb
                pla
                sta     DPCOP_P
                dex
                stx     DPCOP_PC+1
                phk
                per     LFEF695-1
                pea     $0000
                .dbank  $00
                plb
                phx
                tya
                and     #$00c0
                tay
                lda     DPCOP_DP
                pei     (DPCOP_P)
                plb
                plb
                ldx     #$0012
                rtl

LFEF63D         clc
                bra     LFEF690

opbhaFileClosedByDriver cop COP_26_OPBHA
                .zstr   “File closed by driver”
                bra     LFEF685

opbhaCouldntConfig cop  COP_26_OPBHA
                .zstr   “Could not configure”
                bra     LFEF685

@errModuleNotFoundRestoreEnv cop COP_26_OPBHA
                .zstr   “Module not known”
LFEF685         ldx     #$0001            ;TODO - bad code move ldx to end save 2
LFEF688         txy
                plx
                txs
                pld
                tyx
                brl     LFEF52B

LFEF690         plx
                txs
                pld
                tya
                .rwid   shortm,shortx
LFEF694_rts     rtl

                .rwid   longm,longx
LFEF695         bcs     LFEF688
                sty     $0e
                lda     #$0020
                bit     DPCOP_AH+1
                bne     LFEF6AC
                lda     __MMFND
                and     #$0020
                bne     LFEF63D
                jsr     LFEF6FA
                bcs     opbhaCouldntConfig
LFEF6AC         pei     (DPCOP_P)
                plb
                plb
                lda     DPCOP_DP
                phk
                jsr     LFEF804
                sta     DPCOP_DP
                phb
                phb
                pla
                sta     DPCOP_P
                bcs     LFEF6DC
                ldy     #$0000
LFEF6C2         lda     [DPCOP_DP],y
                and     #$00ff
                cmp     #$0020
                bcc     LFEF6DC
                cmp     #$003b
                bne     LFEF6D4
                lda     #$000d
LFEF6D4         phy
                jsr     LFEF788
                ply
                iny
                bra     LFEF6C2

LFEF6DC         jsr     LFEF785
                lda     #$003b
                jsr     LFEF788
                jsr     LFEF785
                jsr     LFEF78D
                bcc     LFEF6F0
                brl     LFEF63D

LFEF6F0         cop     $45
                bcc     LFEF6F7

                .dd1    $82
                .dd1    $91
                .dd1    $ff

LFEF6F7         brl     opbhaFileClosedByDriver

LFEF6FA         phd
                cop     $10
                ora     ($00)
                pld
                bcs     LFEF77A
                sta     $10
                tax
                lda     #$4152
                stal    f:$000000,x
                lda     #$3a4d
                stal    f:DPCOP_Y+1,x
                lda     #$4321
                stal    f:DPCOP_X+1,x
                lda     #$002e
                stal    f:DPCOP_AH+1,x
                ldy     #$0000
LFEF724         lda     [DPCOP_X],y
                sep     #$20
                .rwid   shortm
                cmp     #$3a
                bne     LFEF72E
                lda     #$00
LFEF72E         stal    f:DPCOP_B,x
                rep     #$20
                .rwid   longm
                beq     LFEF73F
                inx
                iny
                cpy     #$000b
                bcs     LFEF77A
                bra     LFEF724

LFEF73F         pea     $0000
                plb
                plb
                lda     $10
                ldy     #$0060
                phk
                jsr     @sk2
                bcs     LFEF779
                sty     $12
LFEF751         ldy     $12
                cop     $0a
                bcs     LFEF772
                and     #$00ff
                cmp     #$003b
                bne     LFEF76D
LFEF75F         cop     $0a
                bcs     LFEF772
                and     #$00ff
                cmp     #$000d
                bne     LFEF75F
                bra     LFEF751

LFEF76D         jsr     LFEF788
                bra     LFEF751

LFEF772         phk
                jsr     closeDevice
                jsr     LFEF785
LFEF779         clc
LFEF77A         php
                lda     $10
                beq     LFEF783
                cop     $1a
                stz     $10
LFEF783         plp
                rts

LFEF785         lda     #$000d
LFEF788         ldx     #$001c
                bra     LFEF790

LFEF78D         ldx     #$001a
LFEF790         phk
                per     LFEF79C
                pea     $0000
                plb
                pei     (DPCOP_PC+1)
                ldy     $0e
LFEF79C         rtl

                .dd1    $a4
                .dd1    $0e
                .dd1    $60

closeDevice     phk
                jsr     getFileHandleInfo
                bcs     LFEF7B9
                phk
                per     LFEFE63_anRTL
                pea     $0000
                plb
                dex
                phx
                lda     #$0000
                bvc     LFEF7B6
                inc     A
LFEF7B6         ldx     #$0014
LFEF7B9         rtl

LFEF7BA         ldx     #$fdfe
                phx
                ldal    f:$000000,x
LFEF7C2         cmp     $01,S
                beq     LFEF7D5
                tax
                ldal    f:$000000,x
                pha
                txy
                iny
                phk
                jsr     closeDevice
                pla
                bra     LFEF7C2

LFEF7D5         plx
                clc
                rtl

                .rwid   shortm,shortx
LFEF7D8         php
                rep     #$30
                .rwid   longm,longx
                phd
                phy
                bra     LFEF7E2

LFEF7DF         jsr     LFEF8B4
LFEF7E2         phb
                pha
                ldy     #$0000
                lda     ($01,S),y
                and     #$00ff
                tay
                pla
                plb
                cpy     #$0020
                beq     LFEF7DF
                bcs     LFEF7F9
                sec
                bra     LFEF7FA

LFEF7F9         clc
LFEF7FA         ply
                pld
                bcs     LFEF801
                plp
                clc
                rtl

LFEF801         plp
                sec
                rtl

LFEF804         phd
                phy
LFEF806         phb
                pha
                ldy     #$0000
                lda     ($01,S),y
                and     #$00ff
                tay
                pla
                plb
                jsr     LFEF8B4
                cpy     #$0020
                beq     LFEF820
                bcs     LFEF806
                sec
                bra     LFEF825

LFEF820         phk
                jsr     LFEF7D8
                clc
LFEF825         ply
                pld
                rtl

LFEF828         phd
                phy
                phb
                pha
                tsc
                tcd
                lda     [DPCOP_Y]
                and     #$00ff
                cmp     #$003a
                beq     LFEF84D
                ldy     #$0000
LFEF83B         lda     [DPCOP_Y],y
                and     #$00ff
                cmp     #$0021
                bcc     LFEF84D
                cmp     #$003a
                beq     LFEF861
                iny
                bne     LFEF83B
LFEF84D         cop     $26
                .zstr   “NET:”
                phk
                jsr     LFEF828
                sty     DPCOP_X+1
                bcs     LFEF8A9
                pla
                plb
                clc
                bra     LFEF8AF

LFEF861         pla
                plb
                phb
                pha
                ldx     #$0000
                ldy     #$0002
                cop     COP_34_OPRMI
                bcs     LFEF8A9
                sta     DPCOP_X+1
                and     #$0060
                beq     LFEF8A9
                pla
                plb
                ldx     #$0000
                ldy     #$0000
                phk
                jsr     LFEF231
                bcs     LFEF8AB
                phb
                pha
                txa
                phk
                jsr     getOrCreateModCallBlock
                bcs     LFEF8A9
                tax
                pla
                plb
                pha
                ldy     #$0000
                lda     ($01,S),y
                and     #$00ff
                eor     #$003a
                cmp     #$0001
                pla
                bcs     LFEF8AB
                jsr     LFEF8B4
                clv
                clc
                bra     LFEF8B1

LFEF8A9         pla
                plb
LFEF8AB         ldx     #$0000
                sec
LFEF8AF         sep     #$40
LFEF8B1         ply
                pld
                rtl

LFEF8B4         php
                rep     #$20
                phd
                phb
                pha
                tsc
                tcd
                sep     #$20
                .rwid   shortm
                inc     DPCOP_Y
                bne     LFEF8C8
                inc     DPCOP_Y+1
                bne     LFEF8C8
                inc     DPCOP_X
LFEF8C8         rep     #$20
                .rwid   longm
                pla
                plb
                pld
                plp
                rts

                .dd1    $08
                .dd1    $8b
                .dd1    $48
                .dd1    $68
                .dd1    $ab
                .dd1    $28
                .dd1    $60
                .dd1    $5a
                .dd1    $bb
                .dd1    $bf
                .dd1    $00
                .dd1    $00
                .dd1    $00
                .dd1    $c3
                .dd1    $01
                .dd1    $f0
                .dd1    $02
                .dd1    $aa
                .dd1    $18
                .dd1    $7a
                .dd1    $60

LFEF8E4         jsr     LFECE01
                bcs     LFEF8EC
                jsr     LFEF8ED
LFEF8EC         rts

LFEF8ED         phx
                phy
                tyx
                jsr     LFEF942
                bcc     LFEF91D
                brk     $00

                .dd1    $4c
                .dd1    $69
                .dd1    $73
                .dd1    $74
                .dd1    $20
                .dd1    $68
                .dd1    $65
                .dd1    $61
                .dd1    $64
                .dd1    $65
                .dd1    $72
                .dd1    $20
                .dd1    $6e
                .dd1    $6f
                .dd1    $74
                .dd1    $20
                .dd1    $66
                .dd1    $6f
                .dd1    $75
                .dd1    $6e
                .dd1    $64
                .dd1    $20
                .dd1    $2d
                .dd1    $20
                .dd1    $73
                .dd1    $65
                .dd1    $72
                .dd1    $69
                .dd1    $6f
                .dd1    $75
                .dd1    $73
                .dd1    $20
                .dd1    $65
                .dd1    $72
                .dd1    $72
                .dd1    $6f
                .dd1    $72
                .dd1    $00

LFEF91D         pla
                plx
                stal    f:$000000,x
                txa
                tyx
                stal    f:$000000,x
                tax
                clc
                rts

LFEF92C         jsr     LFEF935
                bcs     LFEF934
                jsr     LFECDDA
LFEF934         rts

LFEF935         jsr     LFEF942
                bcs     LFEF941
                phx
                tyx
                stal    f:$000000,x
                plx
LFEF941         rts

LFEF942         phx
                phy
                tya
LFEF945         tax
                ldal    f:$000000,x
                cmp     $03,S
                beq     LFEF956
                cmp     $01,S
                bne     LFEF945
                ply
                plx
                sec
                rts

LFEF956         txy
                plx
                plx
                ldal    f:$000000,x
                clc
                rts

doOPSTAR        rep     #$30
                cop     COP_0E_OPCOM
                php                       ;TODO - bcc before all the pushing and popping!
                phb
                pha
                phx
                phy
                bcc     @sk
                cop     COP_61_OPERC
                ldx     #$0000
                cop     COP_02_OPWRA
                cop     COP_03_OPNLI
                sec
@sk             ply
                plx
                pla
                plb
                plp
                rts

                .rwid   shortm,shortx
starDELETE      cop     COP_5B_OPDEL
                rts

starRENAME      cop     COP_5C_OPREN
                rts

starEX          phd
                rep     #$30
                .rwid   longm,longx
                ldy     #$ffff
                bra     LFEF98E

                .rwid   shortm,shortx
starCAT         phd
                rep     #$30
                .rwid   longm,longx
                ldy     #$0000
LFEF98E         tsx
                pea     $0000
                pea     $0000
                phb
                phb
                pha
                phx
                phy
                cop     COP_10_OPADP
                .dd2    $0100             ;direct page size to allocate
                ply
                bcc     LFEF9CA
                plx
                txs
                pld
                cop     COP_26_OPBHA
                .zstr   “Failed to allocate direct page”
                ldx     #$0001
                sec
                rts

LFEF9CA         tcd
                sty     $00
                lda     $03,S
                phk
                jsr     LFEF7D8
                sta     $03,S
                pea     $0000
                plb
                plb
                tsx
                inx
                inx
                inx
                phd
                lda     #$000a
                clc
                adc     $01,S
                sta     $09,S
                txa
                plx
                cop     $59
                bcc     LFEF9F0
                jmp     LFEFAA1

LFEF9F0         ldx     #$000d
                ldy     #$000a
                jsr     LFEFB85
                lda     #$0020
                cop     $00
                lda     #$0028
                cop     $00
                lda     DPCOP_PC
                and     #$00ff
                sta     DPCOP_Y+1
                lda     #$0064
                sta     DPCOP_X+1
                jsr     LFEFB5F
                lda     #$000a
                sta     DPCOP_X+1
                jsr     LFEFB5F
                lda     #$0030
                clc
                adc     DPCOP_Y+1
                cop     $00
                lda     #$0029
                cop     $00
                ldx     #$0004
                jsr     LFEFB79
                lda     DPCOP_P
                and     #$00ff
                bne     LFEFA3E
                cop     $01
                eorl    $656e77
                adc     ($00)
                bra     LFEFA47

LFEFA3E         cop     $01
                bvc     LFEFAB7
                per     $63b1
                adc     $00,S
LFEFA47         cop     $03
                ldx     #$0017
                ldy     #$0010
                jsr     LFEFB85
                ldx     #$0004
                jsr     LFEFB79
                cop     $01
                eorl    $697470
                adcl    f:$00206e
                lda     DPCOP_PC+1
                and     #$0003
                asl     A
                tax
                phk
                .dbank  K (auto)
                plb
                lda     LFEFB93 & $ffff,x
                ldx     #$0000
                cop     $02
                cop     $03
                cop     $01
                mvp     #$72,#$69
                rol     a:$0020
                ldx     #$0027
                ldy     #$000a
                jsr     LFEFB85
                ldx     #$0005
                jsr     LFEFB79
                cop     $01
                jmp     $6269

                .dd1    $2e
                .dd1    $20
                .dd1    $00
                .dd1    $a2
                .dd1    $31
                .dd1    $00
                .dd1    $a0
                .dd1    $0a
                .dd1    $00
                .dd1    $20
                .dd1    $85
                .dd1    $fb
                .dd1    $02
                .dd1    $03
                .dd1    $02
                .dd1    $03

LFEFAA1         plx
                pla
                plb
                plb
                sta     DPCOP_Y+1
                pla
                pla
                ldy     #$0008
LFEFAAC         pea     $0000
                dey
                bne     LFEFAAC
                pea     $000c
                lda ▼   #$0001
LFEFAB7         brk ▼   $24

                bit     $00
                bpl     LFEFABD
                inc     A
LFEFABD         pha
                pea     $0000
                phd
                lda     #$000a
                clc
                adc     $01,S
                sta     $01,S
                phb
                phb
                pei     (DPCOP_Y+1)
                phx
                ldx     #$0008
                lda     #$00a0
                cop     $06
                stx     DPCOP_X+1
                ldx     #$000a
                cop     $06
                txa
                sec
                sbc     DPCOP_X+1
                sta     DPCOP_X+1
                sta     DPCOP_AH+1
                tsx
                txa
                inc     A
                inc     A
                inc     A
                sta     DPCOP_Y+1
LFEFAED         pea     $0000
                plb
                plb
                cop     $5a
                bcc     LFEFB08
                stx     DPCOP_Y+1
                plx
                txs
                ldx     DPCOP_Y+1
                phx
                phb
                pha
                tdc
                cop     $1a
                pla
                plb
                plx
                pld
                sec
                rts

LFEFB08         pea     $0000
                plb
                plb
                txy
                bne     LFEFB20
                ldx     DPCOP_X+1
                cpx     DPCOP_AH+1
                beq     LFEFB18
                cop     $03
LFEFB18         tdc
                cop     $1a
                plx
                txs
                pld
                clc
                rts

LFEFB20         ldx     #$0000
LFEFB23         lda     #$0014
                sta     DPCOP_DP
                sep     #$20
                .rwid   shortm
LFEFB2A         lda     DPCOP_P,x
                beq     LFEFB35
                inx
                cop     $00
                dec     DPCOP_DP
                bra     LFEFB2A

LFEFB35         inx
                bit     $00
                bmi     LFEFB54
                lda     DPCOP_AH+1
                sec
                sbc     #$14
                sta     DPCOP_AH+1
                bcc     LFEFB50
                phx
                ldx     DPCOP_DP
                rep     #$30
                .rwid   longm
                jsr     LFEFB79
                sep     #$20
                .rwid   shortm
                plx
                bra     LFEFB56

LFEFB50         lda     DPCOP_X+1
                sta     DPCOP_AH+1
LFEFB54         cop     $03
LFEFB56         rep     #$30
                .rwid   longm
                dey
                bne     LFEFB23
                lda     DPCOP_Y+1
                bra     LFEFAED

LFEFB5F         stz     DPCOP_AH+1
                lda     DPCOP_Y+1
                sec
LFEFB64         sbc     DPCOP_X+1
                bcc     LFEFB6C
                inc     DPCOP_AH+1
                bra     LFEFB64

LFEFB6C         adc     DPCOP_X+1
                sta     DPCOP_Y+1
                clc
                lda     #$0030
                adc     DPCOP_AH+1
                cop     $00
                rts

LFEFB79         txa
                beq     LFEFB84
                lda     #$0020
LFEFB7F         cop     $00
                dex
                bne     LFEFB7F
LFEFB84         rts

LFEFB85         pea     $0000
                plb
                plb
                lda     $00,x
                cop     $00
                inx
                dey
                bne     LFEFB85
                rts

LFEFB93         .dd1    $9b
                .dd1    $fb
                .dd1    $a4
                .dd1    $fb
                .dd1    $ae
                .dd1    $fb
                .dd1    $b7
                .dd1    $fb
                .dd1    $30
                .dd1    $30
                .dd1    $20
                .dd1    $28
                .dd1    $4f
                .dd1    $66
                .dd1    $66
                .dd1    $29
                .dd1    $00
                .dd1    $30
                .dd1    $31
                .dd1    $20
                .dd1    $28
                .dd1    $4c
                .dd1    $6f
                .dd1    $61
                .dd1    $64
                .dd1    $29
                .dd1    $00
                .dd1    $30
                .dd1    $32
                .dd1    $20
                .dd1    $28
                .dd1    $52
                .dd1    $75
                .dd1    $6e
                .dd1    $29
                .dd1    $00
                .dd1    $30
                .dd1    $33
                .dd1    $20
                .dd1    $28
                .dd1    $45
                .dd1    $78
                .dd1    $65
                .dd1    $63
                .dd1    $29
                .dd1    $00
                .dd1    $60

                .rwid   shortm,shortx
default_IVIRQ   rep     #$30
                .rwid   longm,longx
                phb
                pha
                phx
                ldal    f:$00fe10
                beq     LFEFBDF
                tsx
                tcs
                phk
                per     LFEFC1E
                pea     $0400
                pha
                phx
                lda     #$0000
                stal    f:$00fe10
LFEFBDF         phd
                phy
                pea     0+(LFEFE05 & $ffff)+1
                sep     #$30
                .rwid   shortm,shortx
                pld
LFEFBE7         pei     ($00)
                pld
                lda     [DPCOP_Y+1]
                tay
                and     [DPCOP_DP+1]
                eor     DPCOP_AH+1
                and     DPCOP_AH
                beq     LFEFBE7
                phd
                phk
                pea     LFEFC12 & $ffff
                pei     (DPCOP_B)
                pld
                inc     DPCOP_B
                bne     LFEFC0B
                inc     DPCOP_DP
                bne     LFEFC0B
                inc     DPCOP_DP+1
                bne     LFEFC0B
                inc     DPCOP_P
LFEFC0B         pei     (DPCOP_AH)
                pei     (DPCOP_X)
                pei     (DPCOP_Y)
                pld
LFEFC12         rti

                .dd1    $b0
                .dd1    $cf
                .dd1    $2b
                .dd1    $c2
                .dd1    $30
                .dd1    $7a
                .dd1    $2b
                .dd1    $fa
                .dd1    $68
                .dd1    $ab
                .dd1    $40
LFEFC1E         .dd1    $8f
                .dd1    $10
                .dd1    $fe
                .dd1    $00
                .dd1    $9a
                .dd1    $fa
                .dd1    $68
                .dd1    $ab
                .dd1    $40

********************************************************************************
* Action: This call is used to add a device's interrupt service to the list of *
* such services maintained by the operating system.                            *
*                                                                              *
* On entry: Inline 3 byte hardware address of the device which requires        *
*           servicing's status register.                                       *
*           Inline 1 byte EOR mask, allowing inversion of bits to the correct  *
*           logic level if necessary.                                          *
*           BHA points to the start address of the interrupt routine.          *
*           X contains an AND mask to discriminate between different devices   *
*           causing interrupts. (X must be set to zero if a call to OPMIQ is   *
*           required.)                                                         *
*           Y contains the priority (range 1 to 255). This will be the         *
*           position within the list of devices which the new entry will       *
* occupy.                                                                      *
*           The lower the value the higher the priority.                       *
*           D is set to the direct page required whilst in the interrupt       *
*           routine.                                                           *
*           P flags are set to give the mode required in the interrupt         *
* routine.                                                                     *
*           (The operating system sets the I flag.)                            *
* On exit:  If C = O then the call succeeded. Y = handle and HA = handle.      *
*           If C = 1 then the call failed. Y = 0 and HA = O.                   *
*           No registers preserved                                             *
********************************************************************************
                .rwid   longm,longx
COP_2F          cpy     #$0000
                bne     @YnZ
                ldal    f:$00fe06
                beq     @YnZ
                brl     @retSec

@YnZ            lda     #$000e
                jsr     LFECE01
                bcc     LFEFC40
                brl     @retSec

LFEFC40         phx
                lda     #$000e
                jsr     LFECE01
                bcc     LFEFC4C
                brl     LFEFCF2

LFEFC4C         sep     #$20
                .rwid   shortm
                lda     DPCOP_Y
                stal    f:$000000,x
                lda     DPCOP_P
                ora     #$04
                stal    f:DPCOP_X,x
                rep     #$20
                .rwid   longm
                lda     DPCOP_AH+1
                stal    f:DPCOP_AH,x
                lda     DPCOP_AH
                stal    f:DPCOP_X+1,x
                lda     DPCOP_DP
                stal    f:DPCOP_Y,x
                lda     #$0000
                stal    f:DPCOP_B,x
                stal    f:DPCOP_DP+1,x
                txa
                plx
                stal    f:DPCOP_B,x
                ldy     #$0001
                lda     [DPCOP_PC],y
                stal    f:DPCOP_Y+1,x
                iny
                lda     [DPCOP_PC],y
                stal    f:DPCOP_X,x
                sep     #$20
                .rwid   shortm
                iny
                iny
                lda     [DPCOP_PC],y
                stal    f:DPCOP_AH+1,x
                lda     DPCOP_X
                stal    f:DPCOP_AH,x
                rep     #$20
                .rwid   longm
                lda     #$fd06
                stal    f:DPCOP_DP+1,x
                sep     #$20
                .rwid   shortm
                phk
                pla
                stal    f:DPCOP_PC,x
                rep     #$20
                .rwid   longm
                pea     $0000
                plb
                plb
                pei     (DPCOP_Y)
                phd
                php
                sei
                phx
                pea     0+(LFEFE05 & $ffff)+1
                pld
LFEFCC3         phd
                lda     $00
                beq     LFEFCD5
                tcd
                lda     (DPCOP_B)
                and     #$00ff
                cmp     $08,S
                pla
                bcs     LFEFCC3
                pha
                tdc
LFEFCD5         pld
                plx
                stal    f:$000000,x
                txa
                sta     $00
                plp
                pld
                plx
                tax
                jsr     allocHandleQRY
                sty     DPCOP_Y
                bcc     @retY
                phx
                ldal    f:DPCOP_B,x
                tax
                jsr     LFECDDA
LFEFCF2         plx
                jsr     LFECDDA
@retSec         sec
                stz     DPCOP_Y
@retY           lda     DPCOP_Y
                sta     DPCOP_AH
                inc     DPCOP_PC
                inc     DPCOP_PC
                inc     DPCOP_PC
                inc     DPCOP_PC
                rtl

                .dd1    $ff

********************************************************************************
* COP 30 - OPMIQ - Modify interrupt intercept                                  *
*                                                                              *
* Action: This call allows the modification of the address of the AND mask (by *
* default set to a location coniaining &FF), and the value of the AND mask     *
* contained in X. (X should be set to zero by OPIIQ before using OPMIQ. OPMIQ  *
* is then used to specify the required mask.)                                  *
*                                                                              *
* On entry: Y = handle returned by OPIIQ.                                      *
*           BHA = 0 means do not modify the address of the AND mask.           *
*           BHA <> 0 means BHA is the new address of the AND mask.             *
*           X = 0 means do not modify the AND mask.                            *
*           X <> 0 means X is the new AND mask.                                *
* On exit:  C = 0 means that the inieirupt intercept was modified.             *
*           C = 1 means that the interrupt intercept was not modified.         *
*           No registers preserved                                             *
********************************************************************************
COP_31          jsr     LFECEDA
                bcs     LFEFD42
                phx
                ldal    f:DPCOP_B,x
                tax
                ldal    f:DPCOP_PC,x
                plx
                and     #$00ff
                cmp     #$000e
                bne     LFEFD42
                lda     DPCOP_AH+1
                ora     DPCOP_AH
                php
                sei
                beq     LFEFD33
                lda     DPCOP_AH+1
                stal    f:DPCOP_P,x
                lda     DPCOP_AH
                stal    f:DPCOP_DP+1,x
LFEFD33         lda     DPCOP_X
                beq     LFEFD3F
                sep     #$20
                .rwid   shortm
                stal    f:DPCOP_AH,x
                rep     #$20
                .rwid   longm
LFEFD3F         plp
                clc
                rtl

LFEFD42         sec
                rtl

********************************************************************************
* COP 30 - OPRIQ - release interrupt                                           *
*                                                                              *
* Action: This call removes the specified interrupt service from the list      *
*                                                                              *
* On entry: Y = handle returned by OPIIQ.                                      *
* On exit:  C = 0 means that the call released the interrupt intercept.        *
*           C = 1 means that the call failed to release the interrupt          *
* intercept                                                                    *
*           No registers preserved                                             *
********************************************************************************
COP_30          jsr     LFECEDA
                bcs     LFEFD7B
                phx
                php
                sei
                ldal    f:$000000,x
                pha
                lda     #$fe06
LFEFD54         tax
                ldal    f:$000000,x
                beq     LFEFD78
                cmp     $04,S
                bne     LFEFD54
                pla
                stal    f:$000000,x
                plp
                plx
                jsr     LFECF1E
                phx
                ldal    f:DPCOP_B,x
                tax
                jsr     LFECDDA
                plx
                jsr     LFECDDA
                clc
                rtl

LFEFD78         plp
                pld
                pld
LFEFD7B         rtl

                .rwid   shortm,shortx
LFEFD7C         php
                rep     #$30
                .rwid   longm,longx
                phd
                phb
                cop     COP_13_OPAST
                .dd2    $0100             ;stack size
LFEFD85         bcs     LFEFD85
                stal    f:$00fe10
                lda     #$0000
                stal    f:$00fe06
                phk
                .dbank  K (auto)
                plb
                sep     #$30
                .rwid   shortm,shortx
                lda     #$cc
                xba
                lda     #$b9
                ldx     #$ff
                ldy     #$00
                pea     DPSYS
                pld
                cop     COP_2F_OPIIQ
                .dd3    $00ffff           ;device address
                .dd1    $00               ;device eor mask
                lda     #$cd
                xba
                lda     #$00
                ldy     #$21
                jsr     LFEFDFB
                ldx     #$08
                jsr     LFEFDEE
                lda     #$cc
                xba
                lda     #$ca
                ldy     #$20
                jsr     LFEFDFB
                ldx     #$04
                jsr     LFEFDEE
                lda     #$cc
                xba
                lda     #$ba
                phk
                .dbank  K (auto)
                plb
                ldx     #$00
                ldy     #$10
                pea     $ac00
                pld
                cop     $2f
                ora     $4200
                brk     $a2

                .dd1    $10
                .dd1    $f4
                .dd1    $00
                .dd1    $42
                .dd1    $ab
                .dd1    $ab
                .dd1    $a9
                .dd1    $00
                .dd1    $eb
                .dd1    $a9
                .dd1    $0e
                .dd1    $02
                .dd1    $31
                .dd1    $ab
                .dd1    $2b
                .dd1    $28
                .dd1    $60

LFEFDEE         pea     $0000
                plb
                plb
                lda     #$a5
                xba
                lda     #$5b
                cop     $31
                rts

LFEFDFB         phk
                .dbank  K (auto)
                plb
                ldx     #$00
                pea     $ac00
                pld
                cop     $2f
LFEFE05         brk     $fe

                .dd1    $45
                .dd1    $00
                .dd1    $60

                .rwid   longm,longx
LFEFE0A         cop     COP_26_OPBHA
LFEFE0C         .zstr   “VDU”
                ldx     #DPSYS_MOD_VDU-$ac00
                ldy     #$0000
                cop     COP_29_OPRFR
                cop     COP_26_OPBHA
                .zstr   “NET”
                ldx     #DPSYS_MOD_NET-$ac00
                ldy     #$0000
                cop     COP_29_OPRFR
                cop     COP_26_OPBHA
                .zstr   “ECONET”
                ldx     #$009f
                ldy     #$0000
                cop     COP_29_OPRFR
                rts

                .rwid   shortm,shortx
callModVDU      php
                phd
                phk
                jsr     _callModVduInt
                pld
                plp
                rtl

_callModVduInt  pea     DPSYS
                pld
                pei     (<DPSYS_MOD_VDU+4)
                pei     (<DPSYS_MOD_VDU+2)
                pei     (<DPSYS_MOD_VDU)
                rtl

                .rwid   longm,longx
_callModNetwork pei     (<DPSYS_MOD_NET+4)
                pei     (<DPSYS_MOD_NET+2)
                pei     (<DPSYS_MOD_NET)
                rtl

_callModEconet  pei     (<DPSYS_MOD_ECO+4)
                pei     (<DPSYS_MOD_ECO+2)
                pei     (<DPSYS_MOD_ECO)
                pei     (<DPSYS_DPECO)
                pld
                rtl

                .rwid   shortm,shortx
default__KB     pei     ($cb)
                pei     ($c9)
                pei     ($c7)
LFEFE63_anRTL   rtl

LFEFE64_anRTL   rtl                       ;This is where module calls return to by default

                .dd2    $7966             ;checksum TODO - generate post assemble
                .fill   153,$ff           ;padding TODO - remove
                .adrend ↑ $feae00
